/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value2) => {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value2) => {
      try {
        step(generator.throw(value2));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/.pnpm/is-buffer@2.0.5/node_modules/is-buffer/index.js
var require_is_buffer = __commonJS({
  "node_modules/.pnpm/is-buffer@2.0.5/node_modules/is-buffer/index.js"(exports, module2) {
    module2.exports = function isBuffer2(obj) {
      return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    };
  }
});

// node_modules/.pnpm/extend@3.0.2/node_modules/extend/index.js
var require_extend = __commonJS({
  "node_modules/.pnpm/extend@3.0.2/node_modules/extend/index.js"(exports, module2) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray2 = function isArray3(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject3 = function isPlainObject4(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn.call(obj, key);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty && options.name === "__proto__") {
        defineProperty(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name) {
      if (name === "__proto__") {
        if (!hasOwn.call(obj, name)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name).value;
        }
      }
      return obj[name];
    };
    module2.exports = function extend2() {
      var options, name, src, copy, copyIsArray, clone;
      var target = arguments[0];
      var i = 1;
      var length = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i < length; ++i) {
        options = arguments[i];
        if (options != null) {
          for (name in options) {
            src = getProperty(target, name);
            copy = getProperty(options, name);
            if (target !== copy) {
              if (deep && copy && (isPlainObject3(copy) || (copyIsArray = isArray2(copy)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone = src && isArray2(src) ? src : [];
                } else {
                  clone = src && isPlainObject3(src) ? src : {};
                }
                setProperty(target, { name, newValue: extend2(deep, clone, copy) });
              } else if (typeof copy !== "undefined") {
                setProperty(target, { name, newValue: copy });
              }
            }
          }
        }
      }
      return target;
    };
  }
});

// node_modules/.pnpm/mdast-util-to-markdown@0.6.5/node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js
var require_pattern_compile = __commonJS({
  "node_modules/.pnpm/mdast-util-to-markdown@0.6.5/node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js"(exports, module2) {
    module2.exports = patternCompile2;
    function patternCompile2(pattern) {
      var before;
      var after;
      if (!pattern._compiled) {
        before = pattern.before ? "(?:" + pattern.before + ")" : "";
        after = pattern.after ? "(?:" + pattern.after + ")" : "";
        if (pattern.atBreak) {
          before = "[\\r\\n][\\t ]*" + before;
        }
        pattern._compiled = new RegExp((before ? "(" + before + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(pattern.character) ? "\\" : "") + pattern.character + (after || ""), "g");
      }
      return pattern._compiled;
    }
  }
});

// node_modules/.pnpm/mdast-util-to-markdown@0.6.5/node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js
var require_pattern_in_scope = __commonJS({
  "node_modules/.pnpm/mdast-util-to-markdown@0.6.5/node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js"(exports, module2) {
    module2.exports = patternInScope2;
    function patternInScope2(stack, pattern) {
      return listInScope2(stack, pattern.inConstruct, true) && !listInScope2(stack, pattern.notInConstruct);
    }
    function listInScope2(stack, list2, none) {
      var index2;
      if (!list2) {
        return none;
      }
      if (typeof list2 === "string") {
        list2 = [list2];
      }
      index2 = -1;
      while (++index2 < list2.length) {
        if (stack.indexOf(list2[index2]) !== -1) {
          return true;
        }
      }
      return false;
    }
  }
});

// node_modules/.pnpm/mdast-util-to-markdown@0.6.5/node_modules/mdast-util-to-markdown/lib/util/safe.js
var require_safe = __commonJS({
  "node_modules/.pnpm/mdast-util-to-markdown@0.6.5/node_modules/mdast-util-to-markdown/lib/util/safe.js"(exports, module2) {
    module2.exports = safe3;
    var patternCompile2 = require_pattern_compile();
    var patternInScope2 = require_pattern_in_scope();
    function safe3(context, input, config) {
      var value2 = (config.before || "") + (input || "") + (config.after || "");
      var positions = [];
      var result = [];
      var infos = {};
      var index2 = -1;
      var before;
      var after;
      var position2;
      var pattern;
      var expression;
      var match;
      var start;
      var end;
      while (++index2 < context.unsafe.length) {
        pattern = context.unsafe[index2];
        if (!patternInScope2(context.stack, pattern)) {
          continue;
        }
        expression = patternCompile2(pattern);
        while (match = expression.exec(value2)) {
          before = "before" in pattern || pattern.atBreak;
          after = "after" in pattern;
          position2 = match.index + (before ? match[1].length : 0);
          if (positions.indexOf(position2) === -1) {
            positions.push(position2);
            infos[position2] = { before, after };
          } else {
            if (infos[position2].before && !before) {
              infos[position2].before = false;
            }
            if (infos[position2].after && !after) {
              infos[position2].after = false;
            }
          }
        }
      }
      positions.sort(numerical2);
      start = config.before ? config.before.length : 0;
      end = value2.length - (config.after ? config.after.length : 0);
      index2 = -1;
      while (++index2 < positions.length) {
        position2 = positions[index2];
        if (position2 < start || position2 >= end) {
          continue;
        }
        if (position2 + 1 < end && positions[index2 + 1] === position2 + 1 && infos[position2].after && !infos[position2 + 1].before && !infos[position2 + 1].after) {
          continue;
        }
        if (start !== position2) {
          result.push(escapeBackslashes2(value2.slice(start, position2), "\\"));
        }
        start = position2;
        if (/[!-/:-@[-`{-~]/.test(value2.charAt(position2)) && (!config.encode || config.encode.indexOf(value2.charAt(position2)) === -1)) {
          result.push("\\");
        } else {
          result.push("&#x" + value2.charCodeAt(position2).toString(16).toUpperCase() + ";");
          start++;
        }
      }
      result.push(escapeBackslashes2(value2.slice(start, end), config.after));
      return result.join("");
    }
    function numerical2(a, b) {
      return a - b;
    }
    function escapeBackslashes2(value2, after) {
      var expression = /\\(?=[!-/:-@[-`{-~])/g;
      var positions = [];
      var results = [];
      var index2 = -1;
      var start = 0;
      var whole = value2 + after;
      var match;
      while (match = expression.exec(whole)) {
        positions.push(match.index);
      }
      while (++index2 < positions.length) {
        if (start !== positions[index2]) {
          results.push(value2.slice(start, positions[index2]));
        }
        results.push("\\");
        start = positions[index2];
      }
      results.push(value2.slice(start));
      return results.join("");
    }
  }
});

// node_modules/.pnpm/format@0.2.2/node_modules/format/format.js
var require_format = __commonJS({
  "node_modules/.pnpm/format@0.2.2/node_modules/format/format.js"(exports, module2) {
    (function() {
      var namespace;
      if (typeof module2 !== "undefined") {
        namespace = module2.exports = format2;
      } else {
        namespace = function() {
          return this || (1, eval)("this");
        }();
      }
      namespace.format = format2;
      namespace.vsprintf = vsprintf;
      if (typeof console !== "undefined" && typeof console.log === "function") {
        namespace.printf = printf;
      }
      function printf() {
        console.log(format2.apply(null, arguments));
      }
      function vsprintf(fmt, replacements) {
        return format2.apply(null, [fmt].concat(replacements));
      }
      function format2(fmt) {
        var argIndex = 1, args = [].slice.call(arguments), i = 0, n = fmt.length, result = "", c, escaped = false, arg, tmp, leadingZero = false, precision, nextArg = function() {
          return args[argIndex++];
        }, slurpNumber = function() {
          var digits = "";
          while (/\d/.test(fmt[i])) {
            digits += fmt[i++];
            c = fmt[i];
          }
          return digits.length > 0 ? parseInt(digits) : null;
        };
        for (; i < n; ++i) {
          c = fmt[i];
          if (escaped) {
            escaped = false;
            if (c == ".") {
              leadingZero = false;
              c = fmt[++i];
            } else if (c == "0" && fmt[i + 1] == ".") {
              leadingZero = true;
              i += 2;
              c = fmt[i];
            } else {
              leadingZero = true;
            }
            precision = slurpNumber();
            switch (c) {
              case "b":
                result += parseInt(nextArg(), 10).toString(2);
                break;
              case "c":
                arg = nextArg();
                if (typeof arg === "string" || arg instanceof String)
                  result += arg;
                else
                  result += String.fromCharCode(parseInt(arg, 10));
                break;
              case "d":
                result += parseInt(nextArg(), 10);
                break;
              case "f":
                tmp = String(parseFloat(nextArg()).toFixed(precision || 6));
                result += leadingZero ? tmp : tmp.replace(/^0/, "");
                break;
              case "j":
                result += JSON.stringify(nextArg());
                break;
              case "o":
                result += "0" + parseInt(nextArg(), 10).toString(8);
                break;
              case "s":
                result += nextArg();
                break;
              case "x":
                result += "0x" + parseInt(nextArg(), 10).toString(16);
                break;
              case "X":
                result += "0x" + parseInt(nextArg(), 10).toString(16).toUpperCase();
                break;
              default:
                result += c;
                break;
            }
          } else if (c === "%") {
            escaped = true;
          } else {
            result += c;
          }
        }
        return result;
      }
    })();
  }
});

// node_modules/.pnpm/normalize-path@3.0.0/node_modules/normalize-path/index.js
var require_normalize_path = __commonJS({
  "node_modules/.pnpm/normalize-path@3.0.0/node_modules/normalize-path/index.js"(exports, module2) {
    module2.exports = function(path3, stripTrailing) {
      if (typeof path3 !== "string") {
        throw new TypeError("expected path to be a string");
      }
      if (path3 === "\\" || path3 === "/")
        return "/";
      var len = path3.length;
      if (len <= 1)
        return path3;
      var prefix = "";
      if (len > 4 && path3[3] === "\\") {
        var ch = path3[2];
        if ((ch === "?" || ch === ".") && path3.slice(0, 2) === "\\\\") {
          path3 = path3.slice(2);
          prefix = "//";
        }
      }
      var segs = path3.split(/[/\\]+/);
      if (stripTrailing !== false && segs[segs.length - 1] === "") {
        segs.pop();
      }
      return prefix + segs.join("/");
    };
  }
});

// node_modules/.pnpm/github-slugger@1.5.0/node_modules/github-slugger/regex.js
var require_regex = __commonJS({
  "node_modules/.pnpm/github-slugger@1.5.0/node_modules/github-slugger/regex.js"(exports, module2) {
    module2.exports = /[\0-\x1F!-,\.\/:-@\[-\^`\{-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0378\u0379\u037E\u0380-\u0385\u0387\u038B\u038D\u03A2\u03F6\u0482\u0530\u0557\u0558\u055A-\u055F\u0589-\u0590\u05BE\u05C0\u05C3\u05C6\u05C8-\u05CF\u05EB-\u05EE\u05F3-\u060F\u061B-\u061F\u066A-\u066D\u06D4\u06DD\u06DE\u06E9\u06FD\u06FE\u0700-\u070F\u074B\u074C\u07B2-\u07BF\u07F6-\u07F9\u07FB\u07FC\u07FE\u07FF\u082E-\u083F\u085C-\u085F\u086B-\u089F\u08B5\u08C8-\u08D2\u08E2\u0964\u0965\u0970\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09F2-\u09FB\u09FD\u09FF\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF0-\u0AF8\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B54\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B70\u0B72-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BF0-\u0BFF\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C7F\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0CFF\u0D0D\u0D11\u0D45\u0D49\u0D4F-\u0D53\u0D58-\u0D5E\u0D64\u0D65\u0D70-\u0D79\u0D80\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF4-\u0E00\u0E3B-\u0E3F\u0E4F\u0E5A-\u0E80\u0E83\u0E85\u0E8B\u0EA4\u0EA6\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F01-\u0F17\u0F1A-\u0F1F\u0F2A-\u0F34\u0F36\u0F38\u0F3A-\u0F3D\u0F48\u0F6D-\u0F70\u0F85\u0F98\u0FBD-\u0FC5\u0FC7-\u0FFF\u104A-\u104F\u109E\u109F\u10C6\u10C8-\u10CC\u10CE\u10CF\u10FB\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u1360-\u137F\u1390-\u139F\u13F6\u13F7\u13FE-\u1400\u166D\u166E\u1680\u169B-\u169F\u16EB-\u16ED\u16F9-\u16FF\u170D\u1715-\u171F\u1735-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17D4-\u17D6\u17D8-\u17DB\u17DE\u17DF\u17EA-\u180A\u180E\u180F\u181A-\u181F\u1879-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u1945\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DA-\u19FF\u1A1C-\u1A1F\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1AA6\u1AA8-\u1AAF\u1AC1-\u1AFF\u1B4C-\u1B4F\u1B5A-\u1B6A\u1B74-\u1B7F\u1BF4-\u1BFF\u1C38-\u1C3F\u1C4A-\u1C4C\u1C7E\u1C7F\u1C89-\u1C8F\u1CBB\u1CBC\u1CC0-\u1CCF\u1CD3\u1CFB-\u1CFF\u1DFA\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FBD\u1FBF-\u1FC1\u1FC5\u1FCD-\u1FCF\u1FD4\u1FD5\u1FDC-\u1FDF\u1FED-\u1FF1\u1FF5\u1FFD-\u203E\u2041-\u2053\u2055-\u2070\u2072-\u207E\u2080-\u208F\u209D-\u20CF\u20F1-\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F-\u215F\u2189-\u24B5\u24EA-\u2BFF\u2C2F\u2C5F\u2CE5-\u2CEA\u2CF4-\u2CFF\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D70-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E00-\u2E2E\u2E30-\u3004\u3008-\u3020\u3030\u3036\u3037\u303D-\u3040\u3097\u3098\u309B\u309C\u30A0\u30FB\u3100-\u3104\u3130\u318F-\u319F\u31C0-\u31EF\u3200-\u33FF\u4DC0-\u4DFF\u9FFD-\u9FFF\uA48D-\uA4CF\uA4FE\uA4FF\uA60D-\uA60F\uA62C-\uA63F\uA673\uA67E\uA6F2-\uA716\uA720\uA721\uA789\uA78A\uA7C0\uA7C1\uA7CB-\uA7F4\uA828-\uA82B\uA82D-\uA83F\uA874-\uA87F\uA8C6-\uA8CF\uA8DA-\uA8DF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA954-\uA95F\uA97D-\uA97F\uA9C1-\uA9CE\uA9DA-\uA9DF\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A-\uAA5F\uAA77-\uAA79\uAAC3-\uAADA\uAADE\uAADF\uAAF0\uAAF1\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB5B\uAB6A-\uAB6F\uABEB\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uE000-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB29\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBB2-\uFBD2\uFD3E-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFC-\uFDFF\uFE10-\uFE1F\uFE30-\uFE32\uFE35-\uFE4C\uFE50-\uFE6F\uFE75\uFEFD-\uFF0F\uFF1A-\uFF20\uFF3B-\uFF3E\uFF40\uFF5B-\uFF65\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFFF]|\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDD3F\uDD75-\uDDFC\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEE1-\uDEFF\uDF20-\uDF2C\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDF9F\uDFC4-\uDFC7\uDFD0\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56-\uDC5F\uDC77-\uDC7F\uDC9F-\uDCDF\uDCF3\uDCF6-\uDCFF\uDD16-\uDD1F\uDD3A-\uDD7F\uDDB8-\uDDBD\uDDC0-\uDDFF\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE36\uDE37\uDE3B-\uDE3E\uDE40-\uDE5F\uDE7D-\uDE7F\uDE9D-\uDEBF\uDEC8\uDEE7-\uDEFF\uDF36-\uDF3F\uDF56-\uDF5F\uDF73-\uDF7F\uDF92-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCFF\uDD28-\uDD2F\uDD3A-\uDE7F\uDEAA\uDEAD-\uDEAF\uDEB2-\uDEFF\uDF1D-\uDF26\uDF28-\uDF2F\uDF51-\uDFAF\uDFC5-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC47-\uDC65\uDC70-\uDC7E\uDCBB-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD40-\uDD43\uDD48-\uDD4F\uDD74\uDD75\uDD77-\uDD7F\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDFF\uDE12\uDE38-\uDE3D\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEA9-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC4B-\uDC4F\uDC5A-\uDC5D\uDC62-\uDC7F\uDCC6\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDC1-\uDDD7\uDDDE-\uDDFF\uDE41-\uDE43\uDE45-\uDE4F\uDE5A-\uDE7F\uDEB9-\uDEBF\uDECA-\uDEFF\uDF1B\uDF1C\uDF2C-\uDF2F\uDF3A-\uDFFF]|\uD806[\uDC3B-\uDC9F\uDCEA-\uDCFE\uDD07\uDD08\uDD0A\uDD0B\uDD14\uDD17\uDD36\uDD39\uDD3A\uDD44-\uDD4F\uDD5A-\uDD9F\uDDA8\uDDA9\uDDD8\uDDD9\uDDE2\uDDE5-\uDDFF\uDE3F-\uDE46\uDE48-\uDE4F\uDE9A-\uDE9C\uDE9E-\uDEBF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC41-\uDC4F\uDC5A-\uDC71\uDC90\uDC91\uDCA8\uDCB7-\uDCFF\uDD07\uDD0A\uDD37-\uDD39\uDD3B\uDD3E\uDD48-\uDD4F\uDD5A-\uDD5F\uDD66\uDD69\uDD8F\uDD92\uDD99-\uDD9F\uDDAA-\uDEDF\uDEF7-\uDFAF\uDFB1-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD824-\uD82B\uD82D\uD82E\uD830-\uD833\uD837\uD839\uD83D\uD83F\uD87B-\uD87D\uD87F\uD885-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDECF\uDEEE\uDEEF\uDEF5-\uDEFF\uDF37-\uDF3F\uDF44-\uDF4F\uDF5A-\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE80-\uDEFF\uDF4B-\uDF4E\uDF88-\uDF8E\uDFA0-\uDFDF\uDFE2\uDFE5-\uDFEF\uDFF2-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD823[\uDCD6-\uDCFF\uDD09-\uDFFF]|\uD82C[\uDD1F-\uDD4F\uDD53-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A-\uDC9C\uDC9F-\uDFFF]|\uD834[\uDC00-\uDD64\uDD6A-\uDD6C\uDD73-\uDD7A\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDE41\uDE45-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3\uDFCC\uDFCD]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDCFF\uDD2D-\uDD2F\uDD3E\uDD3F\uDD4A-\uDD4D\uDD4F-\uDEBF\uDEFA-\uDFFF]|\uD83A[\uDCC5-\uDCCF\uDCD7-\uDCFF\uDD4C-\uDD4F\uDD5A-\uDFFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDFFF]|\uD83C[\uDC00-\uDD2F\uDD4A-\uDD4F\uDD6A-\uDD6F\uDD8A-\uDFFF]|\uD83E[\uDC00-\uDFEF\uDFFA-\uDFFF]|\uD869[\uDEDE-\uDEFF]|\uD86D[\uDF35-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD884[\uDF4B-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]/g;
  }
});

// node_modules/.pnpm/github-slugger@1.5.0/node_modules/github-slugger/index.js
var require_github_slugger = __commonJS({
  "node_modules/.pnpm/github-slugger@1.5.0/node_modules/github-slugger/index.js"(exports, module2) {
    var regex2 = require_regex();
    module2.exports = BananaSlug;
    var own7 = Object.hasOwnProperty;
    function BananaSlug() {
      const self = this;
      if (!(self instanceof BananaSlug))
        return new BananaSlug();
      self.reset();
    }
    BananaSlug.prototype.slug = function(value2, maintainCase) {
      const self = this;
      let slug = slugger(value2, maintainCase === true);
      const originalSlug = slug;
      while (own7.call(self.occurrences, slug)) {
        self.occurrences[originalSlug]++;
        slug = originalSlug + "-" + self.occurrences[originalSlug];
      }
      self.occurrences[slug] = 0;
      return slug;
    };
    BananaSlug.prototype.reset = function() {
      this.occurrences = /* @__PURE__ */ Object.create(null);
    };
    function slugger(string3, maintainCase) {
      if (typeof string3 !== "string")
        return "";
      if (!maintainCase)
        string3 = string3.toLowerCase();
      return string3.replace(regex2, "").replace(/ /g, "-");
    }
    BananaSlug.slug = slugger;
  }
});

// node_modules/.pnpm/eastasianwidth@0.2.0/node_modules/eastasianwidth/eastasianwidth.js
var require_eastasianwidth = __commonJS({
  "node_modules/.pnpm/eastasianwidth@0.2.0/node_modules/eastasianwidth/eastasianwidth.js"(exports, module2) {
    var eaw = {};
    if (typeof module2 == "undefined") {
      window.eastasianwidth = eaw;
    } else {
      module2.exports = eaw;
    }
    eaw.eastAsianWidth = function(character) {
      var x = character.charCodeAt(0);
      var y = character.length == 2 ? character.charCodeAt(1) : 0;
      var codePoint = x;
      if (55296 <= x && x <= 56319 && (56320 <= y && y <= 57343)) {
        x &= 1023;
        y &= 1023;
        codePoint = x << 10 | y;
        codePoint += 65536;
      }
      if (codePoint == 12288 || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510) {
        return "F";
      }
      if (codePoint == 8361 || 65377 <= codePoint && codePoint <= 65470 || 65474 <= codePoint && codePoint <= 65479 || 65482 <= codePoint && codePoint <= 65487 || 65490 <= codePoint && codePoint <= 65495 || 65498 <= codePoint && codePoint <= 65500 || 65512 <= codePoint && codePoint <= 65518) {
        return "H";
      }
      if (4352 <= codePoint && codePoint <= 4447 || 4515 <= codePoint && codePoint <= 4519 || 4602 <= codePoint && codePoint <= 4607 || 9001 <= codePoint && codePoint <= 9002 || 11904 <= codePoint && codePoint <= 11929 || 11931 <= codePoint && codePoint <= 12019 || 12032 <= codePoint && codePoint <= 12245 || 12272 <= codePoint && codePoint <= 12283 || 12289 <= codePoint && codePoint <= 12350 || 12353 <= codePoint && codePoint <= 12438 || 12441 <= codePoint && codePoint <= 12543 || 12549 <= codePoint && codePoint <= 12589 || 12593 <= codePoint && codePoint <= 12686 || 12688 <= codePoint && codePoint <= 12730 || 12736 <= codePoint && codePoint <= 12771 || 12784 <= codePoint && codePoint <= 12830 || 12832 <= codePoint && codePoint <= 12871 || 12880 <= codePoint && codePoint <= 13054 || 13056 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42124 || 42128 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 55216 <= codePoint && codePoint <= 55238 || 55243 <= codePoint && codePoint <= 55291 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65106 || 65108 <= codePoint && codePoint <= 65126 || 65128 <= codePoint && codePoint <= 65131 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127490 || 127504 <= codePoint && codePoint <= 127546 || 127552 <= codePoint && codePoint <= 127560 || 127568 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 194367 || 177984 <= codePoint && codePoint <= 196605 || 196608 <= codePoint && codePoint <= 262141) {
        return "W";
      }
      if (32 <= codePoint && codePoint <= 126 || 162 <= codePoint && codePoint <= 163 || 165 <= codePoint && codePoint <= 166 || codePoint == 172 || codePoint == 175 || 10214 <= codePoint && codePoint <= 10221 || 10629 <= codePoint && codePoint <= 10630) {
        return "Na";
      }
      if (codePoint == 161 || codePoint == 164 || 167 <= codePoint && codePoint <= 168 || codePoint == 170 || 173 <= codePoint && codePoint <= 174 || 176 <= codePoint && codePoint <= 180 || 182 <= codePoint && codePoint <= 186 || 188 <= codePoint && codePoint <= 191 || codePoint == 198 || codePoint == 208 || 215 <= codePoint && codePoint <= 216 || 222 <= codePoint && codePoint <= 225 || codePoint == 230 || 232 <= codePoint && codePoint <= 234 || 236 <= codePoint && codePoint <= 237 || codePoint == 240 || 242 <= codePoint && codePoint <= 243 || 247 <= codePoint && codePoint <= 250 || codePoint == 252 || codePoint == 254 || codePoint == 257 || codePoint == 273 || codePoint == 275 || codePoint == 283 || 294 <= codePoint && codePoint <= 295 || codePoint == 299 || 305 <= codePoint && codePoint <= 307 || codePoint == 312 || 319 <= codePoint && codePoint <= 322 || codePoint == 324 || 328 <= codePoint && codePoint <= 331 || codePoint == 333 || 338 <= codePoint && codePoint <= 339 || 358 <= codePoint && codePoint <= 359 || codePoint == 363 || codePoint == 462 || codePoint == 464 || codePoint == 466 || codePoint == 468 || codePoint == 470 || codePoint == 472 || codePoint == 474 || codePoint == 476 || codePoint == 593 || codePoint == 609 || codePoint == 708 || codePoint == 711 || 713 <= codePoint && codePoint <= 715 || codePoint == 717 || codePoint == 720 || 728 <= codePoint && codePoint <= 731 || codePoint == 733 || codePoint == 735 || 768 <= codePoint && codePoint <= 879 || 913 <= codePoint && codePoint <= 929 || 931 <= codePoint && codePoint <= 937 || 945 <= codePoint && codePoint <= 961 || 963 <= codePoint && codePoint <= 969 || codePoint == 1025 || 1040 <= codePoint && codePoint <= 1103 || codePoint == 1105 || codePoint == 8208 || 8211 <= codePoint && codePoint <= 8214 || 8216 <= codePoint && codePoint <= 8217 || 8220 <= codePoint && codePoint <= 8221 || 8224 <= codePoint && codePoint <= 8226 || 8228 <= codePoint && codePoint <= 8231 || codePoint == 8240 || 8242 <= codePoint && codePoint <= 8243 || codePoint == 8245 || codePoint == 8251 || codePoint == 8254 || codePoint == 8308 || codePoint == 8319 || 8321 <= codePoint && codePoint <= 8324 || codePoint == 8364 || codePoint == 8451 || codePoint == 8453 || codePoint == 8457 || codePoint == 8467 || codePoint == 8470 || 8481 <= codePoint && codePoint <= 8482 || codePoint == 8486 || codePoint == 8491 || 8531 <= codePoint && codePoint <= 8532 || 8539 <= codePoint && codePoint <= 8542 || 8544 <= codePoint && codePoint <= 8555 || 8560 <= codePoint && codePoint <= 8569 || codePoint == 8585 || 8592 <= codePoint && codePoint <= 8601 || 8632 <= codePoint && codePoint <= 8633 || codePoint == 8658 || codePoint == 8660 || codePoint == 8679 || codePoint == 8704 || 8706 <= codePoint && codePoint <= 8707 || 8711 <= codePoint && codePoint <= 8712 || codePoint == 8715 || codePoint == 8719 || codePoint == 8721 || codePoint == 8725 || codePoint == 8730 || 8733 <= codePoint && codePoint <= 8736 || codePoint == 8739 || codePoint == 8741 || 8743 <= codePoint && codePoint <= 8748 || codePoint == 8750 || 8756 <= codePoint && codePoint <= 8759 || 8764 <= codePoint && codePoint <= 8765 || codePoint == 8776 || codePoint == 8780 || codePoint == 8786 || 8800 <= codePoint && codePoint <= 8801 || 8804 <= codePoint && codePoint <= 8807 || 8810 <= codePoint && codePoint <= 8811 || 8814 <= codePoint && codePoint <= 8815 || 8834 <= codePoint && codePoint <= 8835 || 8838 <= codePoint && codePoint <= 8839 || codePoint == 8853 || codePoint == 8857 || codePoint == 8869 || codePoint == 8895 || codePoint == 8978 || 9312 <= codePoint && codePoint <= 9449 || 9451 <= codePoint && codePoint <= 9547 || 9552 <= codePoint && codePoint <= 9587 || 9600 <= codePoint && codePoint <= 9615 || 9618 <= codePoint && codePoint <= 9621 || 9632 <= codePoint && codePoint <= 9633 || 9635 <= codePoint && codePoint <= 9641 || 9650 <= codePoint && codePoint <= 9651 || 9654 <= codePoint && codePoint <= 9655 || 9660 <= codePoint && codePoint <= 9661 || 9664 <= codePoint && codePoint <= 9665 || 9670 <= codePoint && codePoint <= 9672 || codePoint == 9675 || 9678 <= codePoint && codePoint <= 9681 || 9698 <= codePoint && codePoint <= 9701 || codePoint == 9711 || 9733 <= codePoint && codePoint <= 9734 || codePoint == 9737 || 9742 <= codePoint && codePoint <= 9743 || 9748 <= codePoint && codePoint <= 9749 || codePoint == 9756 || codePoint == 9758 || codePoint == 9792 || codePoint == 9794 || 9824 <= codePoint && codePoint <= 9825 || 9827 <= codePoint && codePoint <= 9829 || 9831 <= codePoint && codePoint <= 9834 || 9836 <= codePoint && codePoint <= 9837 || codePoint == 9839 || 9886 <= codePoint && codePoint <= 9887 || 9918 <= codePoint && codePoint <= 9919 || 9924 <= codePoint && codePoint <= 9933 || 9935 <= codePoint && codePoint <= 9953 || codePoint == 9955 || 9960 <= codePoint && codePoint <= 9983 || codePoint == 10045 || codePoint == 10071 || 10102 <= codePoint && codePoint <= 10111 || 11093 <= codePoint && codePoint <= 11097 || 12872 <= codePoint && codePoint <= 12879 || 57344 <= codePoint && codePoint <= 63743 || 65024 <= codePoint && codePoint <= 65039 || codePoint == 65533 || 127232 <= codePoint && codePoint <= 127242 || 127248 <= codePoint && codePoint <= 127277 || 127280 <= codePoint && codePoint <= 127337 || 127344 <= codePoint && codePoint <= 127386 || 917760 <= codePoint && codePoint <= 917999 || 983040 <= codePoint && codePoint <= 1048573 || 1048576 <= codePoint && codePoint <= 1114109) {
        return "A";
      }
      return "N";
    };
    eaw.characterLength = function(character) {
      var code2 = this.eastAsianWidth(character);
      if (code2 == "F" || code2 == "W" || code2 == "A") {
        return 2;
      } else {
        return 1;
      }
    };
    function stringToArray(string3) {
      return string3.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\uD800-\uDFFF]/g) || [];
    }
    eaw.length = function(string3) {
      var characters = stringToArray(string3);
      var len = 0;
      for (var i = 0; i < characters.length; i++) {
        len = len + this.characterLength(characters[i]);
      }
      return len;
    };
    eaw.slice = function(text4, start, end) {
      textLen = eaw.length(text4);
      start = start ? start : 0;
      end = end ? end : 1;
      if (start < 0) {
        start = textLen + start;
      }
      if (end < 0) {
        end = textLen + end;
      }
      var result = "";
      var eawLen = 0;
      var chars2 = stringToArray(text4);
      for (var i = 0; i < chars2.length; i++) {
        var char = chars2[i];
        var charLen = eaw.length(char);
        if (eawLen >= start - (charLen == 2 ? 1 : 0)) {
          if (eawLen + charLen <= end) {
            result += char;
          } else {
            break;
          }
        }
        eawLen += charLen;
      }
      return result;
    };
  }
});

// node_modules/.pnpm/emoji-regex@9.2.2/node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS({
  "node_modules/.pnpm/emoji-regex@9.2.2/node_modules/emoji-regex/index.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
      return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ExportToTeXPlugin
});
var import_obsidian7 = require("obsidian");

// node_modules/.pnpm/bail@2.0.2/node_modules/bail/index.js
function bail(error) {
  if (error) {
    throw error;
  }
}

// node_modules/.pnpm/unified@10.1.2/node_modules/unified/lib/index.js
var import_is_buffer2 = __toESM(require_is_buffer(), 1);
var import_extend = __toESM(require_extend(), 1);

// node_modules/.pnpm/is-plain-obj@4.1.0/node_modules/is-plain-obj/index.js
function isPlainObject(value2) {
  if (typeof value2 !== "object" || value2 === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value2);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value2) && !(Symbol.iterator in value2);
}

// node_modules/.pnpm/trough@2.2.0/node_modules/trough/lib/index.js
function trough() {
  const fns = [];
  const pipeline = { run, use };
  return pipeline;
  function run(...values) {
    let middlewareIndex = -1;
    const callback = values.pop();
    if (typeof callback !== "function") {
      throw new TypeError("Expected function as last argument, not " + callback);
    }
    next(null, ...values);
    function next(error, ...output) {
      const fn = fns[++middlewareIndex];
      let index2 = -1;
      if (error) {
        callback(error);
        return;
      }
      while (++index2 < values.length) {
        if (output[index2] === null || output[index2] === void 0) {
          output[index2] = values[index2];
        }
      }
      values = output;
      if (fn) {
        wrap(fn, next)(...output);
      } else {
        callback(null, ...output);
      }
    }
  }
  function use(middelware) {
    if (typeof middelware !== "function") {
      throw new TypeError("Expected `middelware` to be a function, not " + middelware);
    }
    fns.push(middelware);
    return pipeline;
  }
}
function wrap(middleware, callback) {
  let called;
  return wrapped;
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware.length > parameters.length;
    let result;
    if (fnExpectsCallback) {
      parameters.push(done);
    }
    try {
      result = middleware.apply(this, parameters);
    } catch (error) {
      const exception = error;
      if (fnExpectsCallback && called) {
        throw exception;
      }
      return done(exception);
    }
    if (!fnExpectsCallback) {
      if (result && result.then && typeof result.then === "function") {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }
  function done(error, ...output) {
    if (!called) {
      called = true;
      callback(error, ...output);
    }
  }
  function then(value2) {
    done(null, value2);
  }
}

// node_modules/.pnpm/vfile@5.3.7/node_modules/vfile/lib/index.js
var import_is_buffer = __toESM(require_is_buffer(), 1);

// node_modules/.pnpm/unist-util-stringify-position@3.0.3/node_modules/unist-util-stringify-position/lib/index.js
function stringifyPosition(value2) {
  if (!value2 || typeof value2 !== "object") {
    return "";
  }
  if ("position" in value2 || "type" in value2) {
    return position(value2.position);
  }
  if ("start" in value2 || "end" in value2) {
    return position(value2);
  }
  if ("line" in value2 || "column" in value2) {
    return point(value2);
  }
  return "";
}
function point(point3) {
  return index(point3 && point3.line) + ":" + index(point3 && point3.column);
}
function position(pos) {
  return point(pos && pos.start) + "-" + point(pos && pos.end);
}
function index(value2) {
  return value2 && typeof value2 === "number" ? value2 : 1;
}

// node_modules/.pnpm/vfile-message@3.1.4/node_modules/vfile-message/lib/index.js
var VFileMessage = class extends Error {
  constructor(reason, place, origin) {
    const parts = [null, null];
    let position2 = {
      start: { line: null, column: null },
      end: { line: null, column: null }
    };
    super();
    if (typeof place === "string") {
      origin = place;
      place = void 0;
    }
    if (typeof origin === "string") {
      const index2 = origin.indexOf(":");
      if (index2 === -1) {
        parts[1] = origin;
      } else {
        parts[0] = origin.slice(0, index2);
        parts[1] = origin.slice(index2 + 1);
      }
    }
    if (place) {
      if ("type" in place || "position" in place) {
        if (place.position) {
          position2 = place.position;
        }
      } else if ("start" in place || "end" in place) {
        position2 = place;
      } else if ("line" in place || "column" in place) {
        position2.start = place;
      }
    }
    this.name = stringifyPosition(place) || "1:1";
    this.message = typeof reason === "object" ? reason.message : reason;
    this.stack = "";
    if (typeof reason === "object" && reason.stack) {
      this.stack = reason.stack;
    }
    this.reason = this.message;
    this.fatal;
    this.line = position2.start.line;
    this.column = position2.start.column;
    this.position = position2;
    this.source = parts[0];
    this.ruleId = parts[1];
    this.file;
    this.actual;
    this.expected;
    this.url;
    this.note;
  }
};
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.fatal = null;
VFileMessage.prototype.column = null;
VFileMessage.prototype.line = null;
VFileMessage.prototype.source = null;
VFileMessage.prototype.ruleId = null;
VFileMessage.prototype.position = null;

// node_modules/.pnpm/vfile@5.3.7/node_modules/vfile/lib/minpath.browser.js
var path = { basename, dirname, extname, join, sep: "/" };
function basename(path3, ext) {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath(path3);
  let start = 0;
  let end = -1;
  let index2 = path3.length;
  let seenNonSlash;
  if (ext === void 0 || ext.length === 0 || ext.length > path3.length) {
    while (index2--) {
      if (path3.charCodeAt(index2) === 47) {
        if (seenNonSlash) {
          start = index2 + 1;
          break;
        }
      } else if (end < 0) {
        seenNonSlash = true;
        end = index2 + 1;
      }
    }
    return end < 0 ? "" : path3.slice(start, end);
  }
  if (ext === path3) {
    return "";
  }
  let firstNonSlashEnd = -1;
  let extIndex = ext.length - 1;
  while (index2--) {
    if (path3.charCodeAt(index2) === 47) {
      if (seenNonSlash) {
        start = index2 + 1;
        break;
      }
    } else {
      if (firstNonSlashEnd < 0) {
        seenNonSlash = true;
        firstNonSlashEnd = index2 + 1;
      }
      if (extIndex > -1) {
        if (path3.charCodeAt(index2) === ext.charCodeAt(extIndex--)) {
          if (extIndex < 0) {
            end = index2;
          }
        } else {
          extIndex = -1;
          end = firstNonSlashEnd;
        }
      }
    }
  }
  if (start === end) {
    end = firstNonSlashEnd;
  } else if (end < 0) {
    end = path3.length;
  }
  return path3.slice(start, end);
}
function dirname(path3) {
  assertPath(path3);
  if (path3.length === 0) {
    return ".";
  }
  let end = -1;
  let index2 = path3.length;
  let unmatchedSlash;
  while (--index2) {
    if (path3.charCodeAt(index2) === 47) {
      if (unmatchedSlash) {
        end = index2;
        break;
      }
    } else if (!unmatchedSlash) {
      unmatchedSlash = true;
    }
  }
  return end < 0 ? path3.charCodeAt(0) === 47 ? "/" : "." : end === 1 && path3.charCodeAt(0) === 47 ? "//" : path3.slice(0, end);
}
function extname(path3) {
  assertPath(path3);
  let index2 = path3.length;
  let end = -1;
  let startPart = 0;
  let startDot = -1;
  let preDotState = 0;
  let unmatchedSlash;
  while (index2--) {
    const code2 = path3.charCodeAt(index2);
    if (code2 === 47) {
      if (unmatchedSlash) {
        startPart = index2 + 1;
        break;
      }
      continue;
    }
    if (end < 0) {
      unmatchedSlash = true;
      end = index2 + 1;
    }
    if (code2 === 46) {
      if (startDot < 0) {
        startDot = index2;
      } else if (preDotState !== 1) {
        preDotState = 1;
      }
    } else if (startDot > -1) {
      preDotState = -1;
    }
  }
  if (startDot < 0 || end < 0 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path3.slice(startDot, end);
}
function join(...segments) {
  let index2 = -1;
  let joined;
  while (++index2 < segments.length) {
    assertPath(segments[index2]);
    if (segments[index2]) {
      joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
    }
  }
  return joined === void 0 ? "." : normalize(joined);
}
function normalize(path3) {
  assertPath(path3);
  const absolute = path3.charCodeAt(0) === 47;
  let value2 = normalizeString(path3, !absolute);
  if (value2.length === 0 && !absolute) {
    value2 = ".";
  }
  if (value2.length > 0 && path3.charCodeAt(path3.length - 1) === 47) {
    value2 += "/";
  }
  return absolute ? "/" + value2 : value2;
}
function normalizeString(path3, allowAboveRoot) {
  let result = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let index2 = -1;
  let code2;
  let lastSlashIndex;
  while (++index2 <= path3.length) {
    if (index2 < path3.length) {
      code2 = path3.charCodeAt(index2);
    } else if (code2 === 47) {
      break;
    } else {
      code2 = 47;
    }
    if (code2 === 47) {
      if (lastSlash === index2 - 1 || dots === 1) {
      } else if (lastSlash !== index2 - 1 && dots === 2) {
        if (result.length < 2 || lastSegmentLength !== 2 || result.charCodeAt(result.length - 1) !== 46 || result.charCodeAt(result.length - 2) !== 46) {
          if (result.length > 2) {
            lastSlashIndex = result.lastIndexOf("/");
            if (lastSlashIndex !== result.length - 1) {
              if (lastSlashIndex < 0) {
                result = "";
                lastSegmentLength = 0;
              } else {
                result = result.slice(0, lastSlashIndex);
                lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
              }
              lastSlash = index2;
              dots = 0;
              continue;
            }
          } else if (result.length > 0) {
            result = "";
            lastSegmentLength = 0;
            lastSlash = index2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          result = result.length > 0 ? result + "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (result.length > 0) {
          result += "/" + path3.slice(lastSlash + 1, index2);
        } else {
          result = path3.slice(lastSlash + 1, index2);
        }
        lastSegmentLength = index2 - lastSlash - 1;
      }
      lastSlash = index2;
      dots = 0;
    } else if (code2 === 46 && dots > -1) {
      dots++;
    } else {
      dots = -1;
    }
  }
  return result;
}
function assertPath(path3) {
  if (typeof path3 !== "string") {
    throw new TypeError("Path must be a string. Received " + JSON.stringify(path3));
  }
}

// node_modules/.pnpm/vfile@5.3.7/node_modules/vfile/lib/minproc.browser.js
var proc = { cwd };
function cwd() {
  return "/";
}

// node_modules/.pnpm/vfile@5.3.7/node_modules/vfile/lib/minurl.shared.js
function isUrl(fileUrlOrPath) {
  return fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && fileUrlOrPath.href && fileUrlOrPath.origin;
}

// node_modules/.pnpm/vfile@5.3.7/node_modules/vfile/lib/minurl.browser.js
function urlToPath(path3) {
  if (typeof path3 === "string") {
    path3 = new URL(path3);
  } else if (!isUrl(path3)) {
    const error = new TypeError('The "path" argument must be of type string or an instance of URL. Received `' + path3 + "`");
    error.code = "ERR_INVALID_ARG_TYPE";
    throw error;
  }
  if (path3.protocol !== "file:") {
    const error = new TypeError("The URL must be of scheme file");
    error.code = "ERR_INVALID_URL_SCHEME";
    throw error;
  }
  return getPathFromURLPosix(path3);
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    const error = new TypeError('File URL host must be "localhost" or empty on darwin');
    error.code = "ERR_INVALID_FILE_URL_HOST";
    throw error;
  }
  const pathname = url.pathname;
  let index2 = -1;
  while (++index2 < pathname.length) {
    if (pathname.charCodeAt(index2) === 37 && pathname.charCodeAt(index2 + 1) === 50) {
      const third = pathname.charCodeAt(index2 + 2);
      if (third === 70 || third === 102) {
        const error = new TypeError("File URL path must not include encoded / characters");
        error.code = "ERR_INVALID_FILE_URL_PATH";
        throw error;
      }
    }
  }
  return decodeURIComponent(pathname);
}

// node_modules/.pnpm/vfile@5.3.7/node_modules/vfile/lib/index.js
var order = ["history", "path", "basename", "stem", "extname", "dirname"];
var VFile = class {
  constructor(value2) {
    let options;
    if (!value2) {
      options = {};
    } else if (typeof value2 === "string" || buffer(value2)) {
      options = { value: value2 };
    } else if (isUrl(value2)) {
      options = { path: value2 };
    } else {
      options = value2;
    }
    this.data = {};
    this.messages = [];
    this.history = [];
    this.cwd = proc.cwd();
    this.value;
    this.stored;
    this.result;
    this.map;
    let index2 = -1;
    while (++index2 < order.length) {
      const prop2 = order[index2];
      if (prop2 in options && options[prop2] !== void 0 && options[prop2] !== null) {
        this[prop2] = prop2 === "history" ? [...options[prop2]] : options[prop2];
      }
    }
    let prop;
    for (prop in options) {
      if (!order.includes(prop)) {
        this[prop] = options[prop];
      }
    }
  }
  get path() {
    return this.history[this.history.length - 1];
  }
  set path(path3) {
    if (isUrl(path3)) {
      path3 = urlToPath(path3);
    }
    assertNonEmpty(path3, "path");
    if (this.path !== path3) {
      this.history.push(path3);
    }
  }
  get dirname() {
    return typeof this.path === "string" ? path.dirname(this.path) : void 0;
  }
  set dirname(dirname2) {
    assertPath2(this.basename, "dirname");
    this.path = path.join(dirname2 || "", this.basename);
  }
  get basename() {
    return typeof this.path === "string" ? path.basename(this.path) : void 0;
  }
  set basename(basename2) {
    assertNonEmpty(basename2, "basename");
    assertPart(basename2, "basename");
    this.path = path.join(this.dirname || "", basename2);
  }
  get extname() {
    return typeof this.path === "string" ? path.extname(this.path) : void 0;
  }
  set extname(extname2) {
    assertPart(extname2, "extname");
    assertPath2(this.dirname, "extname");
    if (extname2) {
      if (extname2.charCodeAt(0) !== 46) {
        throw new Error("`extname` must start with `.`");
      }
      if (extname2.includes(".", 1)) {
        throw new Error("`extname` cannot contain multiple dots");
      }
    }
    this.path = path.join(this.dirname, this.stem + (extname2 || ""));
  }
  get stem() {
    return typeof this.path === "string" ? path.basename(this.path, this.extname) : void 0;
  }
  set stem(stem) {
    assertNonEmpty(stem, "stem");
    assertPart(stem, "stem");
    this.path = path.join(this.dirname || "", stem + (this.extname || ""));
  }
  toString(encoding) {
    return (this.value || "").toString(encoding || void 0);
  }
  message(reason, place, origin) {
    const message = new VFileMessage(reason, place, origin);
    if (this.path) {
      message.name = this.path + ":" + message.name;
      message.file = this.path;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
  }
  info(reason, place, origin) {
    const message = this.message(reason, place, origin);
    message.fatal = null;
    return message;
  }
  fail(reason, place, origin) {
    const message = this.message(reason, place, origin);
    message.fatal = true;
    throw message;
  }
};
function assertPart(part, name) {
  if (part && part.includes(path.sep)) {
    throw new Error("`" + name + "` cannot be a path: did not expect `" + path.sep + "`");
  }
}
function assertNonEmpty(part, name) {
  if (!part) {
    throw new Error("`" + name + "` cannot be empty");
  }
}
function assertPath2(path3, name) {
  if (!path3) {
    throw new Error("Setting `" + name + "` requires `path` to be set too");
  }
}
function buffer(value2) {
  return (0, import_is_buffer.default)(value2);
}

// node_modules/.pnpm/unified@10.1.2/node_modules/unified/lib/index.js
var unified = base().freeze();
var own = {}.hasOwnProperty;
function base() {
  const transformers = trough();
  const attachers = [];
  let namespace = {};
  let frozen;
  let freezeIndex = -1;
  processor.data = data;
  processor.Parser = void 0;
  processor.Compiler = void 0;
  processor.freeze = freeze;
  processor.attachers = attachers;
  processor.use = use;
  processor.parse = parse2;
  processor.stringify = stringify;
  processor.run = run;
  processor.runSync = runSync;
  processor.process = process;
  processor.processSync = processSync;
  return processor;
  function processor() {
    const destination = base();
    let index2 = -1;
    while (++index2 < attachers.length) {
      destination.use(...attachers[index2]);
    }
    destination.data((0, import_extend.default)(true, {}, namespace));
    return destination;
  }
  function data(key, value2) {
    if (typeof key === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", frozen);
        namespace[key] = value2;
        return processor;
      }
      return own.call(namespace, key) && namespace[key] || null;
    }
    if (key) {
      assertUnfrozen("data", frozen);
      namespace = key;
      return processor;
    }
    return namespace;
  }
  function freeze() {
    if (frozen) {
      return processor;
    }
    while (++freezeIndex < attachers.length) {
      const [attacher, ...options] = attachers[freezeIndex];
      if (options[0] === false) {
        continue;
      }
      if (options[0] === true) {
        options[0] = void 0;
      }
      const transformer = attacher.call(processor, ...options);
      if (typeof transformer === "function") {
        transformers.use(transformer);
      }
    }
    frozen = true;
    freezeIndex = Number.POSITIVE_INFINITY;
    return processor;
  }
  function use(value2, ...options) {
    let settings;
    assertUnfrozen("use", frozen);
    if (value2 === null || value2 === void 0) {
    } else if (typeof value2 === "function") {
      addPlugin(value2, ...options);
    } else if (typeof value2 === "object") {
      if (Array.isArray(value2)) {
        addList(value2);
      } else {
        addPreset(value2);
      }
    } else {
      throw new TypeError("Expected usable value, not `" + value2 + "`");
    }
    if (settings) {
      namespace.settings = Object.assign(namespace.settings || {}, settings);
    }
    return processor;
    function add(value3) {
      if (typeof value3 === "function") {
        addPlugin(value3);
      } else if (typeof value3 === "object") {
        if (Array.isArray(value3)) {
          const [plugin, ...options2] = value3;
          addPlugin(plugin, ...options2);
        } else {
          addPreset(value3);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value3 + "`");
      }
    }
    function addPreset(result) {
      addList(result.plugins);
      if (result.settings) {
        settings = Object.assign(settings || {}, result.settings);
      }
    }
    function addList(plugins) {
      let index2 = -1;
      if (plugins === null || plugins === void 0) {
      } else if (Array.isArray(plugins)) {
        while (++index2 < plugins.length) {
          const thing = plugins[index2];
          add(thing);
        }
      } else {
        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, value3) {
      let index2 = -1;
      let entry;
      while (++index2 < attachers.length) {
        if (attachers[index2][0] === plugin) {
          entry = attachers[index2];
          break;
        }
      }
      if (entry) {
        if (isPlainObject(entry[1]) && isPlainObject(value3)) {
          value3 = (0, import_extend.default)(true, entry[1], value3);
        }
        entry[1] = value3;
      } else {
        attachers.push([...arguments]);
      }
    }
  }
  function parse2(doc) {
    processor.freeze();
    const file = vfile(doc);
    const Parser = processor.Parser;
    assertParser("parse", Parser);
    if (newable(Parser, "parse")) {
      return new Parser(String(file), file).parse();
    }
    return Parser(String(file), file);
  }
  function stringify(node2, doc) {
    processor.freeze();
    const file = vfile(doc);
    const Compiler = processor.Compiler;
    assertCompiler("stringify", Compiler);
    assertNode(node2);
    if (newable(Compiler, "compile")) {
      return new Compiler(node2, file).compile();
    }
    return Compiler(node2, file);
  }
  function run(node2, doc, callback) {
    assertNode(node2);
    processor.freeze();
    if (!callback && typeof doc === "function") {
      callback = doc;
      doc = void 0;
    }
    if (!callback) {
      return new Promise(executor);
    }
    executor(null, callback);
    function executor(resolve, reject) {
      transformers.run(node2, vfile(doc), done);
      function done(error, tree, file) {
        tree = tree || node2;
        if (error) {
          reject(error);
        } else if (resolve) {
          resolve(tree);
        } else {
          callback(null, tree, file);
        }
      }
    }
  }
  function runSync(node2, file) {
    let result;
    let complete;
    processor.run(node2, file, done);
    assertDone("runSync", "run", complete);
    return result;
    function done(error, tree) {
      bail(error);
      result = tree;
      complete = true;
    }
  }
  function process(doc, callback) {
    processor.freeze();
    assertParser("process", processor.Parser);
    assertCompiler("process", processor.Compiler);
    if (!callback) {
      return new Promise(executor);
    }
    executor(null, callback);
    function executor(resolve, reject) {
      const file = vfile(doc);
      processor.run(processor.parse(file), file, (error, tree, file2) => {
        if (error || !tree || !file2) {
          done(error);
        } else {
          const result = processor.stringify(tree, file2);
          if (result === void 0 || result === null) {
          } else if (looksLikeAVFileValue(result)) {
            file2.value = result;
          } else {
            file2.result = result;
          }
          done(error, file2);
        }
      });
      function done(error, file2) {
        if (error || !file2) {
          reject(error);
        } else if (resolve) {
          resolve(file2);
        } else {
          callback(null, file2);
        }
      }
    }
  }
  function processSync(doc) {
    let complete;
    processor.freeze();
    assertParser("processSync", processor.Parser);
    assertCompiler("processSync", processor.Compiler);
    const file = vfile(doc);
    processor.process(file, done);
    assertDone("processSync", "process", complete);
    return file;
    function done(error) {
      complete = true;
      bail(error);
    }
  }
}
function newable(value2, name) {
  return typeof value2 === "function" && value2.prototype && (keys(value2.prototype) || name in value2.prototype);
}
function keys(value2) {
  let key;
  for (key in value2) {
    if (own.call(value2, key)) {
      return true;
    }
  }
  return false;
}
function assertParser(name, value2) {
  if (typeof value2 !== "function") {
    throw new TypeError("Cannot `" + name + "` without `Parser`");
  }
}
function assertCompiler(name, value2) {
  if (typeof value2 !== "function") {
    throw new TypeError("Cannot `" + name + "` without `Compiler`");
  }
}
function assertUnfrozen(name, frozen) {
  if (frozen) {
    throw new Error("Cannot call `" + name + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.");
  }
}
function assertNode(node2) {
  if (!isPlainObject(node2) || typeof node2.type !== "string") {
    throw new TypeError("Expected node, got `" + node2 + "`");
  }
}
function assertDone(name, asyncName, complete) {
  if (!complete) {
    throw new Error("`" + name + "` finished async. Use `" + asyncName + "` instead");
  }
}
function vfile(value2) {
  return looksLikeAVFile(value2) ? value2 : new VFile(value2);
}
function looksLikeAVFile(value2) {
  return Boolean(value2 && typeof value2 === "object" && "message" in value2 && "messages" in value2);
}
function looksLikeAVFileValue(value2) {
  return typeof value2 === "string" || (0, import_is_buffer2.default)(value2);
}

// node_modules/.pnpm/mdast-util-to-string@3.2.0/node_modules/mdast-util-to-string/lib/index.js
var emptyOptions = {};
function toString(value2, options) {
  const settings = options || emptyOptions;
  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
  return one(value2, includeImageAlt, includeHtml);
}
function one(value2, includeImageAlt, includeHtml) {
  if (node(value2)) {
    if ("value" in value2) {
      return value2.type === "html" && !includeHtml ? "" : value2.value;
    }
    if (includeImageAlt && "alt" in value2 && value2.alt) {
      return value2.alt;
    }
    if ("children" in value2) {
      return all(value2.children, includeImageAlt, includeHtml);
    }
  }
  if (Array.isArray(value2)) {
    return all(value2, includeImageAlt, includeHtml);
  }
  return "";
}
function all(values, includeImageAlt, includeHtml) {
  const result = [];
  let index2 = -1;
  while (++index2 < values.length) {
    result[index2] = one(values[index2], includeImageAlt, includeHtml);
  }
  return result.join("");
}
function node(value2) {
  return Boolean(value2 && typeof value2 === "object");
}

// node_modules/.pnpm/micromark-util-chunked@1.1.0/node_modules/micromark-util-chunked/index.js
function splice(list2, start, remove, items) {
  const end = list2.length;
  let chunkStart = 0;
  let parameters;
  if (start < 0) {
    start = -start > end ? 0 : end + start;
  } else {
    start = start > end ? end : start;
  }
  remove = remove > 0 ? remove : 0;
  if (items.length < 1e4) {
    parameters = Array.from(items);
    parameters.unshift(start, remove);
    list2.splice(...parameters);
  } else {
    if (remove)
      list2.splice(start, remove);
    while (chunkStart < items.length) {
      parameters = items.slice(chunkStart, chunkStart + 1e4);
      parameters.unshift(start, 0);
      list2.splice(...parameters);
      chunkStart += 1e4;
      start += 1e4;
    }
  }
}
function push(list2, items) {
  if (list2.length > 0) {
    splice(list2, list2.length, 0, items);
    return list2;
  }
  return items;
}

// node_modules/.pnpm/micromark-util-combine-extensions@1.1.0/node_modules/micromark-util-combine-extensions/index.js
var hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all2 = {};
  let index2 = -1;
  while (++index2 < extensions.length) {
    syntaxExtension(all2, extensions[index2]);
  }
  return all2;
}
function syntaxExtension(all2, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty.call(all2, hook) ? all2[hook] : void 0;
    const left = maybe || (all2[hook] = {});
    const right = extension2[hook];
    let code2;
    if (right) {
      for (code2 in right) {
        if (!hasOwnProperty.call(left, code2))
          left[code2] = [];
        const value2 = right[code2];
        constructs(left[code2], Array.isArray(value2) ? value2 : value2 ? [value2] : []);
      }
    }
  }
}
function constructs(existing, list2) {
  let index2 = -1;
  const before = [];
  while (++index2 < list2.length) {
    ;
    (list2[index2].add === "after" ? existing : before).push(list2[index2]);
  }
  splice(existing, 0, 0, before);
}

// node_modules/.pnpm/micromark-util-character@1.2.0/node_modules/micromark-util-character/lib/unicode-punctuation-regex.js
var unicodePunctuationRegex = /[!-\/:-@\[-`\{-~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;

// node_modules/.pnpm/micromark-util-character@1.2.0/node_modules/micromark-util-character/index.js
var asciiAlpha = regexCheck(/[A-Za-z]/);
var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code2) {
  return code2 !== null && (code2 < 32 || code2 === 127);
}
var asciiDigit = regexCheck(/\d/);
var asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
function markdownLineEnding(code2) {
  return code2 !== null && code2 < -2;
}
function markdownLineEndingOrSpace(code2) {
  return code2 !== null && (code2 < 0 || code2 === 32);
}
function markdownSpace(code2) {
  return code2 === -2 || code2 === -1 || code2 === 32;
}
var unicodePunctuation = regexCheck(unicodePunctuationRegex);
var unicodeWhitespace = regexCheck(/\s/);
function regexCheck(regex2) {
  return check2;
  function check2(code2) {
    return code2 !== null && regex2.test(String.fromCharCode(code2));
  }
}

// node_modules/.pnpm/micromark-factory-space@1.1.0/node_modules/micromark-factory-space/index.js
function factorySpace(effects, ok2, type, max) {
  const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
  let size2 = 0;
  return start;
  function start(code2) {
    if (markdownSpace(code2)) {
      effects.enter(type);
      return prefix(code2);
    }
    return ok2(code2);
  }
  function prefix(code2) {
    if (markdownSpace(code2) && size2++ < limit) {
      effects.consume(code2);
      return prefix;
    }
    effects.exit(type);
    return ok2(code2);
  }
}

// node_modules/.pnpm/micromark@3.2.0/node_modules/micromark/lib/initialize/content.js
var content = {
  tokenize: initializeContent
};
function initializeContent(effects) {
  const contentStart = effects.attempt(this.parser.constructs.contentInitial, afterContentStartConstruct, paragraphInitial);
  let previous5;
  return contentStart;
  function afterContentStartConstruct(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, contentStart, "linePrefix");
  }
  function paragraphInitial(code2) {
    effects.enter("paragraph");
    return lineStart(code2);
  }
  function lineStart(code2) {
    const token = effects.enter("chunkText", {
      contentType: "text",
      previous: previous5
    });
    if (previous5) {
      previous5.next = token;
    }
    previous5 = token;
    return data(code2);
  }
  function data(code2) {
    if (code2 === null) {
      effects.exit("chunkText");
      effects.exit("paragraph");
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      effects.exit("chunkText");
      return lineStart;
    }
    effects.consume(code2);
    return data;
  }
}

// node_modules/.pnpm/micromark@3.2.0/node_modules/micromark/lib/initialize/document.js
var document2 = {
  tokenize: initializeDocument
};
var containerConstruct = {
  tokenize: tokenizeContainer
};
function initializeDocument(effects) {
  const self = this;
  const stack = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start;
  function start(code2) {
    if (continued < stack.length) {
      const item = stack[continued];
      self.containerState = item[1];
      return effects.attempt(item[0].continuation, documentContinue, checkNewContainers)(code2);
    }
    return checkNewContainers(code2);
  }
  function documentContinue(code2) {
    continued++;
    if (self.containerState._closeFlow) {
      self.containerState._closeFlow = void 0;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point3;
      while (indexBeforeFlow--) {
        if (self.events[indexBeforeFlow][0] === "exit" && self.events[indexBeforeFlow][1].type === "chunkFlow") {
          point3 = self.events[indexBeforeFlow][1].end;
          break;
        }
      }
      exitContainers(continued);
      let index2 = indexBeforeExits;
      while (index2 < self.events.length) {
        self.events[index2][1].end = Object.assign({}, point3);
        index2++;
      }
      splice(self.events, indexBeforeFlow + 1, 0, self.events.slice(indexBeforeExits));
      self.events.length = index2;
      return checkNewContainers(code2);
    }
    return start(code2);
  }
  function checkNewContainers(code2) {
    if (continued === stack.length) {
      if (!childFlow) {
        return documentContinued(code2);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code2);
      }
      self.interrupt = Boolean(childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack);
    }
    self.containerState = {};
    return effects.check(containerConstruct, thereIsANewContainer, thereIsNoNewContainer)(code2);
  }
  function thereIsANewContainer(code2) {
    if (childFlow)
      closeFlow();
    exitContainers(continued);
    return documentContinued(code2);
  }
  function thereIsNoNewContainer(code2) {
    self.parser.lazy[self.now().line] = continued !== stack.length;
    lineStartOffset = self.now().offset;
    return flowStart(code2);
  }
  function documentContinued(code2) {
    self.containerState = {};
    return effects.attempt(containerConstruct, containerContinue, flowStart)(code2);
  }
  function containerContinue(code2) {
    continued++;
    stack.push([self.currentConstruct, self.containerState]);
    return documentContinued(code2);
  }
  function flowStart(code2) {
    if (code2 === null) {
      if (childFlow)
        closeFlow();
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    childFlow = childFlow || self.parser.flow(self.now());
    effects.enter("chunkFlow", {
      contentType: "flow",
      previous: childToken,
      _tokenizer: childFlow
    });
    return flowContinue(code2);
  }
  function flowContinue(code2) {
    if (code2 === null) {
      writeToChild(effects.exit("chunkFlow"), true);
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      writeToChild(effects.exit("chunkFlow"));
      continued = 0;
      self.interrupt = void 0;
      return start;
    }
    effects.consume(code2);
    return flowContinue;
  }
  function writeToChild(token, eof) {
    const stream = self.sliceStream(token);
    if (eof)
      stream.push(null);
    token.previous = childToken;
    if (childToken)
      childToken.next = token;
    childToken = token;
    childFlow.defineSkip(token.start);
    childFlow.write(stream);
    if (self.parser.lazy[token.start.line]) {
      let index2 = childFlow.events.length;
      while (index2--) {
        if (childFlow.events[index2][1].start.offset < lineStartOffset && (!childFlow.events[index2][1].end || childFlow.events[index2][1].end.offset > lineStartOffset)) {
          return;
        }
      }
      const indexBeforeExits = self.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen;
      let point3;
      while (indexBeforeFlow--) {
        if (self.events[indexBeforeFlow][0] === "exit" && self.events[indexBeforeFlow][1].type === "chunkFlow") {
          if (seen) {
            point3 = self.events[indexBeforeFlow][1].end;
            break;
          }
          seen = true;
        }
      }
      exitContainers(continued);
      index2 = indexBeforeExits;
      while (index2 < self.events.length) {
        self.events[index2][1].end = Object.assign({}, point3);
        index2++;
      }
      splice(self.events, indexBeforeFlow + 1, 0, self.events.slice(indexBeforeExits));
      self.events.length = index2;
    }
  }
  function exitContainers(size2) {
    let index2 = stack.length;
    while (index2-- > size2) {
      const entry = stack[index2];
      self.containerState = entry[1];
      entry[0].exit.call(self, effects);
    }
    stack.length = size2;
  }
  function closeFlow() {
    childFlow.write([null]);
    childToken = void 0;
    childFlow = void 0;
    self.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok2, nok) {
  return factorySpace(effects, effects.attempt(this.parser.constructs.document, ok2, nok), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}

// node_modules/.pnpm/micromark-util-classify-character@1.1.0/node_modules/micromark-util-classify-character/index.js
function classifyCharacter(code2) {
  if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
    return 1;
  }
  if (unicodePunctuation(code2)) {
    return 2;
  }
}

// node_modules/.pnpm/micromark-util-resolve-all@1.1.0/node_modules/micromark-util-resolve-all/index.js
function resolveAll(constructs2, events, context) {
  const called = [];
  let index2 = -1;
  while (++index2 < constructs2.length) {
    const resolve = constructs2[index2].resolveAll;
    if (resolve && !called.includes(resolve)) {
      events = resolve(events, context);
      called.push(resolve);
    }
  }
  return events;
}

// node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/attention.js
var attention = {
  name: "attention",
  tokenize: tokenizeAttention,
  resolveAll: resolveAllAttention
};
function resolveAllAttention(events, context) {
  let index2 = -1;
  let open;
  let group;
  let text4;
  let openingSequence;
  let closingSequence;
  let use;
  let nextEvents;
  let offset;
  while (++index2 < events.length) {
    if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
      open = index2;
      while (open--) {
        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
          if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
            continue;
          }
          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
          const start = Object.assign({}, events[open][1].end);
          const end = Object.assign({}, events[index2][1].start);
          movePoint(start, -use);
          movePoint(end, use);
          openingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start,
            end: Object.assign({}, events[open][1].end)
          };
          closingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, events[index2][1].start),
            end
          };
          text4 = {
            type: use > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, events[open][1].end),
            end: Object.assign({}, events[index2][1].start)
          };
          group = {
            type: use > 1 ? "strong" : "emphasis",
            start: Object.assign({}, openingSequence.start),
            end: Object.assign({}, closingSequence.end)
          };
          events[open][1].end = Object.assign({}, openingSequence.start);
          events[index2][1].start = Object.assign({}, closingSequence.end);
          nextEvents = [];
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = push(nextEvents, [
              ["enter", events[open][1], context],
              ["exit", events[open][1], context]
            ]);
          }
          nextEvents = push(nextEvents, [
            ["enter", group, context],
            ["enter", openingSequence, context],
            ["exit", openingSequence, context],
            ["enter", text4, context]
          ]);
          nextEvents = push(nextEvents, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index2), context));
          nextEvents = push(nextEvents, [
            ["exit", text4, context],
            ["enter", closingSequence, context],
            ["exit", closingSequence, context],
            ["exit", group, context]
          ]);
          if (events[index2][1].end.offset - events[index2][1].start.offset) {
            offset = 2;
            nextEvents = push(nextEvents, [
              ["enter", events[index2][1], context],
              ["exit", events[index2][1], context]
            ]);
          } else {
            offset = 0;
          }
          splice(events, open - 1, index2 - open + 3, nextEvents);
          index2 = open + nextEvents.length - offset - 2;
          break;
        }
      }
    }
  }
  index2 = -1;
  while (++index2 < events.length) {
    if (events[index2][1].type === "attentionSequence") {
      events[index2][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok2) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
  const previous5 = this.previous;
  const before = classifyCharacter(previous5);
  let marker;
  return start;
  function start(code2) {
    marker = code2;
    effects.enter("attentionSequence");
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return inside;
    }
    const token = effects.exit("attentionSequence");
    const after = classifyCharacter(code2);
    const open = !after || after === 2 && before || attentionMarkers2.includes(code2);
    const close2 = !before || before === 2 && after || attentionMarkers2.includes(previous5);
    token._open = Boolean(marker === 42 ? open : open && (before || !close2));
    token._close = Boolean(marker === 42 ? close2 : close2 && (after || !open));
    return ok2(code2);
  }
}
function movePoint(point3, offset) {
  point3.column += offset;
  point3.offset += offset;
  point3._bufferIndex += offset;
}

// node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/autolink.js
var autolink = {
  name: "autolink",
  tokenize: tokenizeAutolink
};
function tokenizeAutolink(effects, ok2, nok) {
  let size2 = 0;
  return start;
  function start(code2) {
    effects.enter("autolink");
    effects.enter("autolinkMarker");
    effects.consume(code2);
    effects.exit("autolinkMarker");
    effects.enter("autolinkProtocol");
    return open;
  }
  function open(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return schemeOrEmailAtext;
    }
    return emailAtext(code2);
  }
  function schemeOrEmailAtext(code2) {
    if (code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) {
      size2 = 1;
      return schemeInsideOrEmailAtext(code2);
    }
    return emailAtext(code2);
  }
  function schemeInsideOrEmailAtext(code2) {
    if (code2 === 58) {
      effects.consume(code2);
      size2 = 0;
      return urlInside;
    }
    if ((code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) && size2++ < 32) {
      effects.consume(code2);
      return schemeInsideOrEmailAtext;
    }
    size2 = 0;
    return emailAtext(code2);
  }
  function urlInside(code2) {
    if (code2 === 62) {
      effects.exit("autolinkProtocol");
      effects.enter("autolinkMarker");
      effects.consume(code2);
      effects.exit("autolinkMarker");
      effects.exit("autolink");
      return ok2;
    }
    if (code2 === null || code2 === 32 || code2 === 60 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return urlInside;
  }
  function emailAtext(code2) {
    if (code2 === 64) {
      effects.consume(code2);
      return emailAtSignOrDot;
    }
    if (asciiAtext(code2)) {
      effects.consume(code2);
      return emailAtext;
    }
    return nok(code2);
  }
  function emailAtSignOrDot(code2) {
    return asciiAlphanumeric(code2) ? emailLabel(code2) : nok(code2);
  }
  function emailLabel(code2) {
    if (code2 === 46) {
      effects.consume(code2);
      size2 = 0;
      return emailAtSignOrDot;
    }
    if (code2 === 62) {
      effects.exit("autolinkProtocol").type = "autolinkEmail";
      effects.enter("autolinkMarker");
      effects.consume(code2);
      effects.exit("autolinkMarker");
      effects.exit("autolink");
      return ok2;
    }
    return emailValue(code2);
  }
  function emailValue(code2) {
    if ((code2 === 45 || asciiAlphanumeric(code2)) && size2++ < 63) {
      const next = code2 === 45 ? emailValue : emailLabel;
      effects.consume(code2);
      return next;
    }
    return nok(code2);
  }
}

// node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/blank-line.js
var blankLine = {
  tokenize: tokenizeBlankLine,
  partial: true
};
function tokenizeBlankLine(effects, ok2, nok) {
  return start;
  function start(code2) {
    return markdownSpace(code2) ? factorySpace(effects, after, "linePrefix")(code2) : after(code2);
  }
  function after(code2) {
    return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
  }
}

// node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/block-quote.js
var blockQuote = {
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart,
  continuation: {
    tokenize: tokenizeBlockQuoteContinuation
  },
  exit
};
function tokenizeBlockQuoteStart(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    if (code2 === 62) {
      const state = self.containerState;
      if (!state.open) {
        effects.enter("blockQuote", {
          _container: true
        });
        state.open = true;
      }
      effects.enter("blockQuotePrefix");
      effects.enter("blockQuoteMarker");
      effects.consume(code2);
      effects.exit("blockQuoteMarker");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    if (markdownSpace(code2)) {
      effects.enter("blockQuotePrefixWhitespace");
      effects.consume(code2);
      effects.exit("blockQuotePrefixWhitespace");
      effects.exit("blockQuotePrefix");
      return ok2;
    }
    effects.exit("blockQuotePrefix");
    return ok2(code2);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok2, nok) {
  const self = this;
  return contStart;
  function contStart(code2) {
    if (markdownSpace(code2)) {
      return factorySpace(effects, contBefore, "linePrefix", self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2);
    }
    return contBefore(code2);
  }
  function contBefore(code2) {
    return effects.attempt(blockQuote, ok2, nok)(code2);
  }
}
function exit(effects) {
  effects.exit("blockQuote");
}

// node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/character-escape.js
var characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("characterEscape");
    effects.enter("escapeMarker");
    effects.consume(code2);
    effects.exit("escapeMarker");
    return inside;
  }
  function inside(code2) {
    if (asciiPunctuation(code2)) {
      effects.enter("characterEscapeValue");
      effects.consume(code2);
      effects.exit("characterEscapeValue");
      effects.exit("characterEscape");
      return ok2;
    }
    return nok(code2);
  }
}

// node_modules/.pnpm/decode-named-character-reference@1.2.0/node_modules/decode-named-character-reference/index.dom.js
var element = document.createElement("i");
function decodeNamedCharacterReference(value2) {
  const characterReference2 = "&" + value2 + ";";
  element.innerHTML = characterReference2;
  const character = element.textContent;
  if (character.charCodeAt(character.length - 1) === 59 && value2 !== "semi") {
    return false;
  }
  return character === characterReference2 ? false : character;
}

// node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/character-reference.js
var characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok2, nok) {
  const self = this;
  let size2 = 0;
  let max;
  let test;
  return start;
  function start(code2) {
    effects.enter("characterReference");
    effects.enter("characterReferenceMarker");
    effects.consume(code2);
    effects.exit("characterReferenceMarker");
    return open;
  }
  function open(code2) {
    if (code2 === 35) {
      effects.enter("characterReferenceMarkerNumeric");
      effects.consume(code2);
      effects.exit("characterReferenceMarkerNumeric");
      return numeric;
    }
    effects.enter("characterReferenceValue");
    max = 31;
    test = asciiAlphanumeric;
    return value2(code2);
  }
  function numeric(code2) {
    if (code2 === 88 || code2 === 120) {
      effects.enter("characterReferenceMarkerHexadecimal");
      effects.consume(code2);
      effects.exit("characterReferenceMarkerHexadecimal");
      effects.enter("characterReferenceValue");
      max = 6;
      test = asciiHexDigit;
      return value2;
    }
    effects.enter("characterReferenceValue");
    max = 7;
    test = asciiDigit;
    return value2(code2);
  }
  function value2(code2) {
    if (code2 === 59 && size2) {
      const token = effects.exit("characterReferenceValue");
      if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self.sliceSerialize(token))) {
        return nok(code2);
      }
      effects.enter("characterReferenceMarker");
      effects.consume(code2);
      effects.exit("characterReferenceMarker");
      effects.exit("characterReference");
      return ok2;
    }
    if (test(code2) && size2++ < max) {
      effects.consume(code2);
      return value2;
    }
    return nok(code2);
  }
}

// node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/code-fenced.js
var nonLazyContinuation = {
  tokenize: tokenizeNonLazyContinuation,
  partial: true
};
var codeFenced = {
  name: "codeFenced",
  tokenize: tokenizeCodeFenced,
  concrete: true
};
function tokenizeCodeFenced(effects, ok2, nok) {
  const self = this;
  const closeStart = {
    tokenize: tokenizeCloseStart,
    partial: true
  };
  let initialPrefix = 0;
  let sizeOpen = 0;
  let marker;
  return start;
  function start(code2) {
    return beforeSequenceOpen(code2);
  }
  function beforeSequenceOpen(code2) {
    const tail = self.events[self.events.length - 1];
    initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
    marker = code2;
    effects.enter("codeFenced");
    effects.enter("codeFencedFence");
    effects.enter("codeFencedFenceSequence");
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === marker) {
      sizeOpen++;
      effects.consume(code2);
      return sequenceOpen;
    }
    if (sizeOpen < 3) {
      return nok(code2);
    }
    effects.exit("codeFencedFenceSequence");
    return markdownSpace(code2) ? factorySpace(effects, infoBefore, "whitespace")(code2) : infoBefore(code2);
  }
  function infoBefore(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFencedFence");
      return self.interrupt ? ok2(code2) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
    }
    effects.enter("codeFencedFenceInfo");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return info(code2);
  }
  function info(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return infoBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return factorySpace(effects, metaBefore, "whitespace")(code2);
    }
    if (code2 === 96 && code2 === marker) {
      return nok(code2);
    }
    effects.consume(code2);
    return info;
  }
  function metaBefore(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return infoBefore(code2);
    }
    effects.enter("codeFencedFenceMeta");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return meta(code2);
  }
  function meta(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceMeta");
      return infoBefore(code2);
    }
    if (code2 === 96 && code2 === marker) {
      return nok(code2);
    }
    effects.consume(code2);
    return meta;
  }
  function atNonLazyBreak(code2) {
    return effects.attempt(closeStart, after, contentBefore)(code2);
  }
  function contentBefore(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return contentStart;
  }
  function contentStart(code2) {
    return initialPrefix > 0 && markdownSpace(code2) ? factorySpace(effects, beforeContentChunk, "linePrefix", initialPrefix + 1)(code2) : beforeContentChunk(code2);
  }
  function beforeContentChunk(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
    }
    effects.enter("codeFlowValue");
    return contentChunk(code2);
  }
  function contentChunk(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFlowValue");
      return beforeContentChunk(code2);
    }
    effects.consume(code2);
    return contentChunk;
  }
  function after(code2) {
    effects.exit("codeFenced");
    return ok2(code2);
  }
  function tokenizeCloseStart(effects2, ok3, nok2) {
    let size2 = 0;
    return startBefore;
    function startBefore(code2) {
      effects2.enter("lineEnding");
      effects2.consume(code2);
      effects2.exit("lineEnding");
      return start2;
    }
    function start2(code2) {
      effects2.enter("codeFencedFence");
      return markdownSpace(code2) ? factorySpace(effects2, beforeSequenceClose, "linePrefix", self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2) : beforeSequenceClose(code2);
    }
    function beforeSequenceClose(code2) {
      if (code2 === marker) {
        effects2.enter("codeFencedFenceSequence");
        return sequenceClose(code2);
      }
      return nok2(code2);
    }
    function sequenceClose(code2) {
      if (code2 === marker) {
        size2++;
        effects2.consume(code2);
        return sequenceClose;
      }
      if (size2 >= sizeOpen) {
        effects2.exit("codeFencedFenceSequence");
        return markdownSpace(code2) ? factorySpace(effects2, sequenceCloseAfter, "whitespace")(code2) : sequenceCloseAfter(code2);
      }
      return nok2(code2);
    }
    function sequenceCloseAfter(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects2.exit("codeFencedFence");
        return ok3(code2);
      }
      return nok2(code2);
    }
  }
}
function tokenizeNonLazyContinuation(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return lineStart;
  }
  function lineStart(code2) {
    return self.parser.lazy[self.now().line] ? nok(code2) : ok2(code2);
  }
}

// node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/code-indented.js
var codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
};
var furtherStart = {
  tokenize: tokenizeFurtherStart,
  partial: true
};
function tokenizeCodeIndented(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    effects.enter("codeIndented");
    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
  }
  function afterPrefix(code2) {
    const tail = self.events[self.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? atBreak(code2) : nok(code2);
  }
  function atBreak(code2) {
    if (code2 === null) {
      return after(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.attempt(furtherStart, atBreak, after)(code2);
    }
    effects.enter("codeFlowValue");
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFlowValue");
      return atBreak(code2);
    }
    effects.consume(code2);
    return inside;
  }
  function after(code2) {
    effects.exit("codeIndented");
    return ok2(code2);
  }
}
function tokenizeFurtherStart(effects, ok2, nok) {
  const self = this;
  return furtherStart2;
  function furtherStart2(code2) {
    if (self.parser.lazy[self.now().line]) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return furtherStart2;
    }
    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
  }
  function afterPrefix(code2) {
    const tail = self.events[self.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok2(code2) : markdownLineEnding(code2) ? furtherStart2(code2) : nok(code2);
  }
}

// node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/code-text.js
var codeText = {
  name: "codeText",
  tokenize: tokenizeCodeText,
  resolve: resolveCodeText,
  previous
};
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index2;
  let enter2;
  if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
    index2 = headEnterIndex;
    while (++index2 < tailExitIndex) {
      if (events[index2][1].type === "codeTextData") {
        events[headEnterIndex][1].type = "codeTextPadding";
        events[tailExitIndex][1].type = "codeTextPadding";
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index2 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index2 <= tailExitIndex) {
    if (enter2 === void 0) {
      if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
        enter2 = index2;
      }
    } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
      events[enter2][1].type = "codeTextData";
      if (index2 !== enter2 + 2) {
        events[enter2][1].end = events[index2 - 1][1].end;
        events.splice(enter2 + 2, index2 - enter2 - 2);
        tailExitIndex -= index2 - enter2 - 2;
        index2 = enter2 + 2;
      }
      enter2 = void 0;
    }
  }
  return events;
}
function previous(code2) {
  return code2 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function tokenizeCodeText(effects, ok2, nok) {
  const self = this;
  let sizeOpen = 0;
  let size2;
  let token;
  return start;
  function start(code2) {
    effects.enter("codeText");
    effects.enter("codeTextSequence");
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === 96) {
      effects.consume(code2);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit("codeTextSequence");
    return between2(code2);
  }
  function between2(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 32) {
      effects.enter("space");
      effects.consume(code2);
      effects.exit("space");
      return between2;
    }
    if (code2 === 96) {
      token = effects.enter("codeTextSequence");
      size2 = 0;
      return sequenceClose(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return between2;
    }
    effects.enter("codeTextData");
    return data(code2);
  }
  function data(code2) {
    if (code2 === null || code2 === 32 || code2 === 96 || markdownLineEnding(code2)) {
      effects.exit("codeTextData");
      return between2(code2);
    }
    effects.consume(code2);
    return data;
  }
  function sequenceClose(code2) {
    if (code2 === 96) {
      effects.consume(code2);
      size2++;
      return sequenceClose;
    }
    if (size2 === sizeOpen) {
      effects.exit("codeTextSequence");
      effects.exit("codeText");
      return ok2(code2);
    }
    token.type = "codeTextData";
    return data(code2);
  }
}

// node_modules/.pnpm/micromark-util-subtokenize@1.1.0/node_modules/micromark-util-subtokenize/index.js
function subtokenize(events) {
  const jumps = {};
  let index2 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  while (++index2 < events.length) {
    while (index2 in jumps) {
      index2 = jumps[index2];
    }
    event = events[index2];
    if (index2 && event[1].type === "chunkFlow" && events[index2 - 1][1].type === "listItemPrefix") {
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === "content") {
            break;
          }
          if (subevents[otherIndex][1].type === "chunkText") {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index2));
        index2 = jumps[index2];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index2;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events[otherIndex];
        if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events[lineIndex][1].type = "lineEndingBlank";
            }
            otherEvent[1].type = "lineEnding";
            lineIndex = otherIndex;
          }
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = Object.assign({}, events[lineIndex][1].start);
        parameters = events.slice(lineIndex, index2);
        parameters.unshift(event);
        splice(events, lineIndex, index2 - lineIndex + 1, parameters);
      }
    }
  }
  return !more;
}
function subcontent(events, eventIndex) {
  const token = events[eventIndex][1];
  const context = events[eventIndex][2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  const tokenizer = token._tokenizer || context.parser[token.contentType](token.start);
  const childEvents = tokenizer.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous5;
  let index2 = -1;
  let current = token;
  let adjust = 0;
  let start = 0;
  const breaks = [start];
  while (current) {
    while (events[++startPosition][1] !== current) {
    }
    startPositions.push(startPosition);
    if (!current._tokenizer) {
      stream = context.sliceStream(current);
      if (!current.next) {
        stream.push(null);
      }
      if (previous5) {
        tokenizer.defineSkip(current.start);
      }
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer.write(stream);
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous5 = current;
    current = current.next;
  }
  current = token;
  while (++index2 < childEvents.length) {
    if (childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line) {
      start = index2 + 1;
      breaks.push(start);
      current._tokenizer = void 0;
      current.previous = void 0;
      current = current.next;
    }
  }
  tokenizer.events = [];
  if (current) {
    current._tokenizer = void 0;
    current.previous = void 0;
  } else {
    breaks.pop();
  }
  index2 = breaks.length;
  while (index2--) {
    const slice = childEvents.slice(breaks[index2], breaks[index2 + 1]);
    const start2 = startPositions.pop();
    jumps.unshift([start2, start2 + slice.length - 1]);
    splice(events, start2, 2, slice);
  }
  index2 = -1;
  while (++index2 < jumps.length) {
    gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
    adjust += jumps[index2][1] - jumps[index2][0] - 1;
  }
  return gaps;
}

// node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/content.js
var content2 = {
  tokenize: tokenizeContent,
  resolve: resolveContent
};
var continuationConstruct = {
  tokenize: tokenizeContinuation,
  partial: true
};
function resolveContent(events) {
  subtokenize(events);
  return events;
}
function tokenizeContent(effects, ok2) {
  let previous5;
  return chunkStart;
  function chunkStart(code2) {
    effects.enter("content");
    previous5 = effects.enter("chunkContent", {
      contentType: "content"
    });
    return chunkInside(code2);
  }
  function chunkInside(code2) {
    if (code2 === null) {
      return contentEnd(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.check(continuationConstruct, contentContinue, contentEnd)(code2);
    }
    effects.consume(code2);
    return chunkInside;
  }
  function contentEnd(code2) {
    effects.exit("chunkContent");
    effects.exit("content");
    return ok2(code2);
  }
  function contentContinue(code2) {
    effects.consume(code2);
    effects.exit("chunkContent");
    previous5.next = effects.enter("chunkContent", {
      contentType: "content",
      previous: previous5
    });
    previous5 = previous5.next;
    return chunkInside;
  }
}
function tokenizeContinuation(effects, ok2, nok) {
  const self = this;
  return startLookahead;
  function startLookahead(code2) {
    effects.exit("chunkContent");
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, prefixed, "linePrefix");
  }
  function prefixed(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return nok(code2);
    }
    const tail = self.events[self.events.length - 1];
    if (!self.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
      return ok2(code2);
    }
    return effects.interrupt(self.parser.constructs.flow, nok, ok2)(code2);
  }
}

// node_modules/.pnpm/micromark-factory-destination@1.1.0/node_modules/micromark-factory-destination/index.js
function factoryDestination(effects, ok2, nok, type, literalType, literalMarkerType, rawType, stringType, max) {
  const limit = max || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start;
  function start(code2) {
    if (code2 === 60) {
      effects.enter(type);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      return enclosedBefore;
    }
    if (code2 === null || code2 === 32 || code2 === 41 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.enter(type);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return raw(code2);
  }
  function enclosedBefore(code2) {
    if (code2 === 62) {
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type);
      return ok2;
    }
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return enclosed(code2);
  }
  function enclosed(code2) {
    if (code2 === 62) {
      effects.exit("chunkString");
      effects.exit(stringType);
      return enclosedBefore(code2);
    }
    if (code2 === null || code2 === 60 || markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? enclosedEscape : enclosed;
  }
  function enclosedEscape(code2) {
    if (code2 === 60 || code2 === 62 || code2 === 92) {
      effects.consume(code2);
      return enclosed;
    }
    return enclosed(code2);
  }
  function raw(code2) {
    if (!balance && (code2 === null || code2 === 41 || markdownLineEndingOrSpace(code2))) {
      effects.exit("chunkString");
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type);
      return ok2(code2);
    }
    if (balance < limit && code2 === 40) {
      effects.consume(code2);
      balance++;
      return raw;
    }
    if (code2 === 41) {
      effects.consume(code2);
      balance--;
      return raw;
    }
    if (code2 === null || code2 === 32 || code2 === 40 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? rawEscape : raw;
  }
  function rawEscape(code2) {
    if (code2 === 40 || code2 === 41 || code2 === 92) {
      effects.consume(code2);
      return raw;
    }
    return raw(code2);
  }
}

// node_modules/.pnpm/micromark-factory-label@1.1.0/node_modules/micromark-factory-label/index.js
function factoryLabel(effects, ok2, nok, type, markerType, stringType) {
  const self = this;
  let size2 = 0;
  let seen;
  return start;
  function start(code2) {
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code2);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code2) {
    if (size2 > 999 || code2 === null || code2 === 91 || code2 === 93 && !seen || code2 === 94 && !size2 && "_hiddenFootnoteSupport" in self.parser.constructs) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type);
      return ok2;
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return atBreak;
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return labelInside(code2);
  }
  function labelInside(code2) {
    if (code2 === null || code2 === 91 || code2 === 93 || markdownLineEnding(code2) || size2++ > 999) {
      effects.exit("chunkString");
      return atBreak(code2);
    }
    effects.consume(code2);
    if (!seen)
      seen = !markdownSpace(code2);
    return code2 === 92 ? labelEscape : labelInside;
  }
  function labelEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size2++;
      return labelInside;
    }
    return labelInside(code2);
  }
}

// node_modules/.pnpm/micromark-factory-title@1.1.0/node_modules/micromark-factory-title/index.js
function factoryTitle(effects, ok2, nok, type, markerType, stringType) {
  let marker;
  return start;
  function start(code2) {
    if (code2 === 34 || code2 === 39 || code2 === 40) {
      effects.enter(type);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      marker = code2 === 40 ? 41 : code2;
      return begin;
    }
    return nok(code2);
  }
  function begin(code2) {
    if (code2 === marker) {
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type);
      return ok2;
    }
    effects.enter(stringType);
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.exit(stringType);
      return begin(marker);
    }
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return factorySpace(effects, atBreak, "linePrefix");
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker || code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      return atBreak(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? escape : inside;
  }
  function escape(code2) {
    if (code2 === marker || code2 === 92) {
      effects.consume(code2);
      return inside;
    }
    return inside(code2);
  }
}

// node_modules/.pnpm/micromark-factory-whitespace@1.1.0/node_modules/micromark-factory-whitespace/index.js
function factoryWhitespace(effects, ok2) {
  let seen;
  return start;
  function start(code2) {
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      seen = true;
      return start;
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, start, seen ? "linePrefix" : "lineSuffix")(code2);
    }
    return ok2(code2);
  }
}

// node_modules/.pnpm/micromark-util-normalize-identifier@1.1.0/node_modules/micromark-util-normalize-identifier/index.js
function normalizeIdentifier(value2) {
  return value2.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}

// node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/definition.js
var definition = {
  name: "definition",
  tokenize: tokenizeDefinition
};
var titleBefore = {
  tokenize: tokenizeTitleBefore,
  partial: true
};
function tokenizeDefinition(effects, ok2, nok) {
  const self = this;
  let identifier;
  return start;
  function start(code2) {
    effects.enter("definition");
    return before(code2);
  }
  function before(code2) {
    return factoryLabel.call(self, effects, labelAfter, nok, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(code2);
  }
  function labelAfter(code2) {
    identifier = normalizeIdentifier(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1));
    if (code2 === 58) {
      effects.enter("definitionMarker");
      effects.consume(code2);
      effects.exit("definitionMarker");
      return markerAfter;
    }
    return nok(code2);
  }
  function markerAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, destinationBefore)(code2) : destinationBefore(code2);
  }
  function destinationBefore(code2) {
    return factoryDestination(effects, destinationAfter, nok, "definitionDestination", "definitionDestinationLiteral", "definitionDestinationLiteralMarker", "definitionDestinationRaw", "definitionDestinationString")(code2);
  }
  function destinationAfter(code2) {
    return effects.attempt(titleBefore, after, after)(code2);
  }
  function after(code2) {
    return markdownSpace(code2) ? factorySpace(effects, afterWhitespace, "whitespace")(code2) : afterWhitespace(code2);
  }
  function afterWhitespace(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("definition");
      self.parser.defined.push(identifier);
      return ok2(code2);
    }
    return nok(code2);
  }
}
function tokenizeTitleBefore(effects, ok2, nok) {
  return titleBefore2;
  function titleBefore2(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, beforeMarker)(code2) : nok(code2);
  }
  function beforeMarker(code2) {
    return factoryTitle(effects, titleAfter, nok, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(code2);
  }
  function titleAfter(code2) {
    return markdownSpace(code2) ? factorySpace(effects, titleAfterOptionalWhitespace, "whitespace")(code2) : titleAfterOptionalWhitespace(code2);
  }
  function titleAfterOptionalWhitespace(code2) {
    return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
  }
}

// node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/hard-break-escape.js
var hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("hardBreakEscape");
    effects.consume(code2);
    return after;
  }
  function after(code2) {
    if (markdownLineEnding(code2)) {
      effects.exit("hardBreakEscape");
      return ok2(code2);
    }
    return nok(code2);
  }
}

// node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/heading-atx.js
var headingAtx = {
  name: "headingAtx",
  tokenize: tokenizeHeadingAtx,
  resolve: resolveHeadingAtx
};
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  let content3;
  let text4;
  if (events[contentStart][1].type === "whitespace") {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content3 = {
      type: "atxHeadingText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text4 = {
      type: "chunkText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: "text"
    };
    splice(events, contentStart, contentEnd - contentStart + 1, [
      ["enter", content3, context],
      ["enter", text4, context],
      ["exit", text4, context],
      ["exit", content3, context]
    ]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok2, nok) {
  let size2 = 0;
  return start;
  function start(code2) {
    effects.enter("atxHeading");
    return before(code2);
  }
  function before(code2) {
    effects.enter("atxHeadingSequence");
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === 35 && size2++ < 6) {
      effects.consume(code2);
      return sequenceOpen;
    }
    if (code2 === null || markdownLineEndingOrSpace(code2)) {
      effects.exit("atxHeadingSequence");
      return atBreak(code2);
    }
    return nok(code2);
  }
  function atBreak(code2) {
    if (code2 === 35) {
      effects.enter("atxHeadingSequence");
      return sequenceFurther(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("atxHeading");
      return ok2(code2);
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, atBreak, "whitespace")(code2);
    }
    effects.enter("atxHeadingText");
    return data(code2);
  }
  function sequenceFurther(code2) {
    if (code2 === 35) {
      effects.consume(code2);
      return sequenceFurther;
    }
    effects.exit("atxHeadingSequence");
    return atBreak(code2);
  }
  function data(code2) {
    if (code2 === null || code2 === 35 || markdownLineEndingOrSpace(code2)) {
      effects.exit("atxHeadingText");
      return atBreak(code2);
    }
    effects.consume(code2);
    return data;
  }
}

// node_modules/.pnpm/micromark-util-html-tag-name@1.2.0/node_modules/micromark-util-html-tag-name/index.js
var htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var htmlRawNames = ["pre", "script", "style", "textarea"];

// node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/html-flow.js
var htmlFlow = {
  name: "htmlFlow",
  tokenize: tokenizeHtmlFlow,
  resolveTo: resolveToHtmlFlow,
  concrete: true
};
var blankLineBefore = {
  tokenize: tokenizeBlankLineBefore,
  partial: true
};
var nonLazyContinuationStart = {
  tokenize: tokenizeNonLazyContinuationStart,
  partial: true
};
function resolveToHtmlFlow(events) {
  let index2 = events.length;
  while (index2--) {
    if (events[index2][0] === "enter" && events[index2][1].type === "htmlFlow") {
      break;
    }
  }
  if (index2 > 1 && events[index2 - 2][1].type === "linePrefix") {
    events[index2][1].start = events[index2 - 2][1].start;
    events[index2 + 1][1].start = events[index2 - 2][1].start;
    events.splice(index2 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok2, nok) {
  const self = this;
  let marker;
  let closingTag;
  let buffer2;
  let index2;
  let markerB;
  return start;
  function start(code2) {
    return before(code2);
  }
  function before(code2) {
    effects.enter("htmlFlow");
    effects.enter("htmlFlowData");
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === 33) {
      effects.consume(code2);
      return declarationOpen;
    }
    if (code2 === 47) {
      effects.consume(code2);
      closingTag = true;
      return tagCloseStart;
    }
    if (code2 === 63) {
      effects.consume(code2);
      marker = 3;
      return self.interrupt ? ok2 : continuationDeclarationInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      buffer2 = String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function declarationOpen(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      marker = 2;
      return commentOpenInside;
    }
    if (code2 === 91) {
      effects.consume(code2);
      marker = 5;
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      marker = 4;
      return self.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function commentOpenInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return self.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function cdataOpenInside(code2) {
    const value2 = "CDATA[";
    if (code2 === value2.charCodeAt(index2++)) {
      effects.consume(code2);
      if (index2 === value2.length) {
        return self.interrupt ? ok2 : continuation;
      }
      return cdataOpenInside;
    }
    return nok(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      buffer2 = String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function tagName(code2) {
    if (code2 === null || code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      const slash = code2 === 47;
      const name = buffer2.toLowerCase();
      if (!slash && !closingTag && htmlRawNames.includes(name)) {
        marker = 1;
        return self.interrupt ? ok2(code2) : continuation(code2);
      }
      if (htmlBlockNames.includes(buffer2.toLowerCase())) {
        marker = 6;
        if (slash) {
          effects.consume(code2);
          return basicSelfClosing;
        }
        return self.interrupt ? ok2(code2) : continuation(code2);
      }
      marker = 7;
      return self.interrupt && !self.parser.lazy[self.now().line] ? nok(code2) : closingTag ? completeClosingTagAfter(code2) : completeAttributeNameBefore(code2);
    }
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      buffer2 += String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function basicSelfClosing(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return self.interrupt ? ok2 : continuation;
    }
    return nok(code2);
  }
  function completeClosingTagAfter(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeClosingTagAfter;
    }
    return completeEnd(code2);
  }
  function completeAttributeNameBefore(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return completeEnd;
    }
    if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameBefore;
    }
    return completeEnd(code2);
  }
  function completeAttributeName(code2) {
    if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code2);
  }
  function completeAttributeNameAfter(code2) {
    if (code2 === 61) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code2);
  }
  function completeAttributeValueBefore(code2) {
    if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 34 || code2 === 39) {
      effects.consume(code2);
      markerB = code2;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    return completeAttributeValueUnquoted(code2);
  }
  function completeAttributeValueQuoted(code2) {
    if (code2 === markerB) {
      effects.consume(code2);
      markerB = null;
      return completeAttributeValueQuotedAfter;
    }
    if (code2 === null || markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code2) {
    if (code2 === null || code2 === 34 || code2 === 39 || code2 === 47 || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96 || markdownLineEndingOrSpace(code2)) {
      return completeAttributeNameAfter(code2);
    }
    effects.consume(code2);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code2) {
    if (code2 === 47 || code2 === 62 || markdownSpace(code2)) {
      return completeAttributeNameBefore(code2);
    }
    return nok(code2);
  }
  function completeEnd(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return completeAfter;
    }
    return nok(code2);
  }
  function completeAfter(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return continuation(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAfter;
    }
    return nok(code2);
  }
  function continuation(code2) {
    if (code2 === 45 && marker === 2) {
      effects.consume(code2);
      return continuationCommentInside;
    }
    if (code2 === 60 && marker === 1) {
      effects.consume(code2);
      return continuationRawTagOpen;
    }
    if (code2 === 62 && marker === 4) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === 63 && marker === 3) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    if (code2 === 93 && marker === 5) {
      effects.consume(code2);
      return continuationCdataInside;
    }
    if (markdownLineEnding(code2) && (marker === 6 || marker === 7)) {
      effects.exit("htmlFlowData");
      return effects.check(blankLineBefore, continuationAfter, continuationStart)(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("htmlFlowData");
      return continuationStart(code2);
    }
    effects.consume(code2);
    return continuation;
  }
  function continuationStart(code2) {
    return effects.check(nonLazyContinuationStart, continuationStartNonLazy, continuationAfter)(code2);
  }
  function continuationStartNonLazy(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return continuationBefore;
  }
  function continuationBefore(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return continuationStart(code2);
    }
    effects.enter("htmlFlowData");
    return continuation(code2);
  }
  function continuationCommentInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationRawTagOpen(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      buffer2 = "";
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationRawEndTag(code2) {
    if (code2 === 62) {
      const name = buffer2.toLowerCase();
      if (htmlRawNames.includes(name)) {
        effects.consume(code2);
        return continuationClose;
      }
      return continuation(code2);
    }
    if (asciiAlpha(code2) && buffer2.length < 8) {
      effects.consume(code2);
      buffer2 += String.fromCharCode(code2);
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationCdataInside(code2) {
    if (code2 === 93) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationDeclarationInside(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === 45 && marker === 2) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationClose(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("htmlFlowData");
      return continuationAfter(code2);
    }
    effects.consume(code2);
    return continuationClose;
  }
  function continuationAfter(code2) {
    effects.exit("htmlFlow");
    return ok2(code2);
  }
}
function tokenizeNonLazyContinuationStart(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return self.parser.lazy[self.now().line] ? nok(code2) : ok2(code2);
  }
}
function tokenizeBlankLineBefore(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return effects.attempt(blankLine, ok2, nok);
  }
}

// node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/html-text.js
var htmlText = {
  name: "htmlText",
  tokenize: tokenizeHtmlText
};
function tokenizeHtmlText(effects, ok2, nok) {
  const self = this;
  let marker;
  let index2;
  let returnState;
  return start;
  function start(code2) {
    effects.enter("htmlText");
    effects.enter("htmlTextData");
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === 33) {
      effects.consume(code2);
      return declarationOpen;
    }
    if (code2 === 47) {
      effects.consume(code2);
      return tagCloseStart;
    }
    if (code2 === 63) {
      effects.consume(code2);
      return instruction;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    return nok(code2);
  }
  function declarationOpen(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentOpenInside;
    }
    if (code2 === 91) {
      effects.consume(code2);
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return declaration;
    }
    return nok(code2);
  }
  function commentOpenInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentEnd;
    }
    return nok(code2);
  }
  function comment(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 45) {
      effects.consume(code2);
      return commentClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = comment;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return comment;
  }
  function commentClose(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentEnd;
    }
    return comment(code2);
  }
  function commentEnd(code2) {
    return code2 === 62 ? end(code2) : code2 === 45 ? commentClose(code2) : comment(code2);
  }
  function cdataOpenInside(code2) {
    const value2 = "CDATA[";
    if (code2 === value2.charCodeAt(index2++)) {
      effects.consume(code2);
      return index2 === value2.length ? cdata : cdataOpenInside;
    }
    return nok(code2);
  }
  function cdata(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.consume(code2);
      return cdataClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = cdata;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return cdata;
  }
  function cdataClose(code2) {
    if (code2 === 93) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function cdataEnd(code2) {
    if (code2 === 62) {
      return end(code2);
    }
    if (code2 === 93) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function declaration(code2) {
    if (code2 === null || code2 === 62) {
      return end(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = declaration;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return declaration;
  }
  function instruction(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 63) {
      effects.consume(code2);
      return instructionClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = instruction;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return instruction;
  }
  function instructionClose(code2) {
    return code2 === 62 ? end(code2) : instruction(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return nok(code2);
  }
  function tagClose(code2) {
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return tagCloseBetween(code2);
  }
  function tagCloseBetween(code2) {
    if (markdownLineEnding(code2)) {
      returnState = tagCloseBetween;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagCloseBetween;
    }
    return end(code2);
  }
  function tagOpen(code2) {
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function tagOpenBetween(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return end;
    }
    if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenBetween;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenBetween;
    }
    return end(code2);
  }
  function tagOpenAttributeName(code2) {
    if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code2);
  }
  function tagOpenAttributeNameAfter(code2) {
    if (code2 === 61) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeNameAfter;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code2);
  }
  function tagOpenAttributeValueBefore(code2) {
    if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 34 || code2 === 39) {
      effects.consume(code2);
      marker = code2;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueBefore;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code2);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      marker = void 0;
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueQuoted;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueUnquoted(code2) {
    if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuotedAfter(code2) {
    if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function end(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      effects.exit("htmlTextData");
      effects.exit("htmlText");
      return ok2;
    }
    return nok(code2);
  }
  function lineEndingBefore(code2) {
    effects.exit("htmlTextData");
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return lineEndingAfter;
  }
  function lineEndingAfter(code2) {
    return markdownSpace(code2) ? factorySpace(effects, lineEndingAfterPrefix, "linePrefix", self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2) : lineEndingAfterPrefix(code2);
  }
  function lineEndingAfterPrefix(code2) {
    effects.enter("htmlTextData");
    return returnState(code2);
  }
}

// node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/label-end.js
var labelEnd = {
  name: "labelEnd",
  tokenize: tokenizeLabelEnd,
  resolveTo: resolveToLabelEnd,
  resolveAll: resolveAllLabelEnd
};
var resourceConstruct = {
  tokenize: tokenizeResource
};
var referenceFullConstruct = {
  tokenize: tokenizeReferenceFull
};
var referenceCollapsedConstruct = {
  tokenize: tokenizeReferenceCollapsed
};
function resolveAllLabelEnd(events) {
  let index2 = -1;
  while (++index2 < events.length) {
    const token = events[index2][1];
    if (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd") {
      events.splice(index2 + 1, token.type === "labelImage" ? 4 : 2);
      token.type = "data";
      index2++;
    }
  }
  return events;
}
function resolveToLabelEnd(events, context) {
  let index2 = events.length;
  let offset = 0;
  let token;
  let open;
  let close2;
  let media;
  while (index2--) {
    token = events[index2][1];
    if (open) {
      if (token.type === "link" || token.type === "labelLink" && token._inactive) {
        break;
      }
      if (events[index2][0] === "enter" && token.type === "labelLink") {
        token._inactive = true;
      }
    } else if (close2) {
      if (events[index2][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {
        open = index2;
        if (token.type !== "labelLink") {
          offset = 2;
          break;
        }
      }
    } else if (token.type === "labelEnd") {
      close2 = index2;
    }
  }
  const group = {
    type: events[open][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const label4 = {
    type: "label",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[close2][1].end)
  };
  const text4 = {
    type: "labelText",
    start: Object.assign({}, events[open + offset + 2][1].end),
    end: Object.assign({}, events[close2 - 2][1].start)
  };
  media = [
    ["enter", group, context],
    ["enter", label4, context]
  ];
  media = push(media, events.slice(open + 1, open + offset + 3));
  media = push(media, [["enter", text4, context]]);
  media = push(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close2 - 3), context));
  media = push(media, [
    ["exit", text4, context],
    events[close2 - 2],
    events[close2 - 1],
    ["exit", label4, context]
  ]);
  media = push(media, events.slice(close2 + 1));
  media = push(media, [["exit", group, context]]);
  splice(events, open, events.length, media);
  return events;
}
function tokenizeLabelEnd(effects, ok2, nok) {
  const self = this;
  let index2 = self.events.length;
  let labelStart;
  let defined;
  while (index2--) {
    if ((self.events[index2][1].type === "labelImage" || self.events[index2][1].type === "labelLink") && !self.events[index2][1]._balanced) {
      labelStart = self.events[index2][1];
      break;
    }
  }
  return start;
  function start(code2) {
    if (!labelStart) {
      return nok(code2);
    }
    if (labelStart._inactive) {
      return labelEndNok(code2);
    }
    defined = self.parser.defined.includes(normalizeIdentifier(self.sliceSerialize({
      start: labelStart.end,
      end: self.now()
    })));
    effects.enter("labelEnd");
    effects.enter("labelMarker");
    effects.consume(code2);
    effects.exit("labelMarker");
    effects.exit("labelEnd");
    return after;
  }
  function after(code2) {
    if (code2 === 40) {
      return effects.attempt(resourceConstruct, labelEndOk, defined ? labelEndOk : labelEndNok)(code2);
    }
    if (code2 === 91) {
      return effects.attempt(referenceFullConstruct, labelEndOk, defined ? referenceNotFull : labelEndNok)(code2);
    }
    return defined ? labelEndOk(code2) : labelEndNok(code2);
  }
  function referenceNotFull(code2) {
    return effects.attempt(referenceCollapsedConstruct, labelEndOk, labelEndNok)(code2);
  }
  function labelEndOk(code2) {
    return ok2(code2);
  }
  function labelEndNok(code2) {
    labelStart._balanced = true;
    return nok(code2);
  }
}
function tokenizeResource(effects, ok2, nok) {
  return resourceStart;
  function resourceStart(code2) {
    effects.enter("resource");
    effects.enter("resourceMarker");
    effects.consume(code2);
    effects.exit("resourceMarker");
    return resourceBefore;
  }
  function resourceBefore(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceOpen)(code2) : resourceOpen(code2);
  }
  function resourceOpen(code2) {
    if (code2 === 41) {
      return resourceEnd(code2);
    }
    return factoryDestination(effects, resourceDestinationAfter, resourceDestinationMissing, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(code2);
  }
  function resourceDestinationAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceBetween)(code2) : resourceEnd(code2);
  }
  function resourceDestinationMissing(code2) {
    return nok(code2);
  }
  function resourceBetween(code2) {
    if (code2 === 34 || code2 === 39 || code2 === 40) {
      return factoryTitle(effects, resourceTitleAfter, nok, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(code2);
    }
    return resourceEnd(code2);
  }
  function resourceTitleAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceEnd)(code2) : resourceEnd(code2);
  }
  function resourceEnd(code2) {
    if (code2 === 41) {
      effects.enter("resourceMarker");
      effects.consume(code2);
      effects.exit("resourceMarker");
      effects.exit("resource");
      return ok2;
    }
    return nok(code2);
  }
}
function tokenizeReferenceFull(effects, ok2, nok) {
  const self = this;
  return referenceFull;
  function referenceFull(code2) {
    return factoryLabel.call(self, effects, referenceFullAfter, referenceFullMissing, "reference", "referenceMarker", "referenceString")(code2);
  }
  function referenceFullAfter(code2) {
    return self.parser.defined.includes(normalizeIdentifier(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1))) ? ok2(code2) : nok(code2);
  }
  function referenceFullMissing(code2) {
    return nok(code2);
  }
}
function tokenizeReferenceCollapsed(effects, ok2, nok) {
  return referenceCollapsedStart;
  function referenceCollapsedStart(code2) {
    effects.enter("reference");
    effects.enter("referenceMarker");
    effects.consume(code2);
    effects.exit("referenceMarker");
    return referenceCollapsedOpen;
  }
  function referenceCollapsedOpen(code2) {
    if (code2 === 93) {
      effects.enter("referenceMarker");
      effects.consume(code2);
      effects.exit("referenceMarker");
      effects.exit("reference");
      return ok2;
    }
    return nok(code2);
  }
}

// node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/label-start-image.js
var labelStartImage = {
  name: "labelStartImage",
  tokenize: tokenizeLabelStartImage,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartImage(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    effects.enter("labelImage");
    effects.enter("labelImageMarker");
    effects.consume(code2);
    effects.exit("labelImageMarker");
    return open;
  }
  function open(code2) {
    if (code2 === 91) {
      effects.enter("labelMarker");
      effects.consume(code2);
      effects.exit("labelMarker");
      effects.exit("labelImage");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === 94 && "_hiddenFootnoteSupport" in self.parser.constructs ? nok(code2) : ok2(code2);
  }
}

// node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/label-start-link.js
var labelStartLink = {
  name: "labelStartLink",
  tokenize: tokenizeLabelStartLink,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartLink(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    effects.enter("labelLink");
    effects.enter("labelMarker");
    effects.consume(code2);
    effects.exit("labelMarker");
    effects.exit("labelLink");
    return after;
  }
  function after(code2) {
    return code2 === 94 && "_hiddenFootnoteSupport" in self.parser.constructs ? nok(code2) : ok2(code2);
  }
}

// node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/line-ending.js
var lineEnding = {
  name: "lineEnding",
  tokenize: tokenizeLineEnding
};
function tokenizeLineEnding(effects, ok2) {
  return start;
  function start(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, ok2, "linePrefix");
  }
}

// node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/thematic-break.js
var thematicBreak = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok2, nok) {
  let size2 = 0;
  let marker;
  return start;
  function start(code2) {
    effects.enter("thematicBreak");
    return before(code2);
  }
  function before(code2) {
    marker = code2;
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.enter("thematicBreakSequence");
      return sequence(code2);
    }
    if (size2 >= 3 && (code2 === null || markdownLineEnding(code2))) {
      effects.exit("thematicBreak");
      return ok2(code2);
    }
    return nok(code2);
  }
  function sequence(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      size2++;
      return sequence;
    }
    effects.exit("thematicBreakSequence");
    return markdownSpace(code2) ? factorySpace(effects, atBreak, "whitespace")(code2) : atBreak(code2);
  }
}

// node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/list.js
var list = {
  name: "list",
  tokenize: tokenizeListStart,
  continuation: {
    tokenize: tokenizeListContinuation
  },
  exit: tokenizeListEnd
};
var listItemPrefixWhitespaceConstruct = {
  tokenize: tokenizeListItemPrefixWhitespace,
  partial: true
};
var indentConstruct = {
  tokenize: tokenizeIndent,
  partial: true
};
function tokenizeListStart(effects, ok2, nok) {
  const self = this;
  const tail = self.events[self.events.length - 1];
  let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let size2 = 0;
  return start;
  function start(code2) {
    const kind = self.containerState.type || (code2 === 42 || code2 === 43 || code2 === 45 ? "listUnordered" : "listOrdered");
    if (kind === "listUnordered" ? !self.containerState.marker || code2 === self.containerState.marker : asciiDigit(code2)) {
      if (!self.containerState.type) {
        self.containerState.type = kind;
        effects.enter(kind, {
          _container: true
        });
      }
      if (kind === "listUnordered") {
        effects.enter("listItemPrefix");
        return code2 === 42 || code2 === 45 ? effects.check(thematicBreak, nok, atMarker)(code2) : atMarker(code2);
      }
      if (!self.interrupt || code2 === 49) {
        effects.enter("listItemPrefix");
        effects.enter("listItemValue");
        return inside(code2);
      }
    }
    return nok(code2);
  }
  function inside(code2) {
    if (asciiDigit(code2) && ++size2 < 10) {
      effects.consume(code2);
      return inside;
    }
    if ((!self.interrupt || size2 < 2) && (self.containerState.marker ? code2 === self.containerState.marker : code2 === 41 || code2 === 46)) {
      effects.exit("listItemValue");
      return atMarker(code2);
    }
    return nok(code2);
  }
  function atMarker(code2) {
    effects.enter("listItemMarker");
    effects.consume(code2);
    effects.exit("listItemMarker");
    self.containerState.marker = self.containerState.marker || code2;
    return effects.check(blankLine, self.interrupt ? nok : onBlank, effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix));
  }
  function onBlank(code2) {
    self.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code2);
  }
  function otherPrefix(code2) {
    if (markdownSpace(code2)) {
      effects.enter("listItemPrefixWhitespace");
      effects.consume(code2);
      effects.exit("listItemPrefixWhitespace");
      return endOfPrefix;
    }
    return nok(code2);
  }
  function endOfPrefix(code2) {
    self.containerState.size = initialSize + self.sliceSerialize(effects.exit("listItemPrefix"), true).length;
    return ok2(code2);
  }
}
function tokenizeListContinuation(effects, ok2, nok) {
  const self = this;
  self.containerState._closeFlow = void 0;
  return effects.check(blankLine, onBlank, notBlank);
  function onBlank(code2) {
    self.containerState.furtherBlankLines = self.containerState.furtherBlankLines || self.containerState.initialBlankLine;
    return factorySpace(effects, ok2, "listItemIndent", self.containerState.size + 1)(code2);
  }
  function notBlank(code2) {
    if (self.containerState.furtherBlankLines || !markdownSpace(code2)) {
      self.containerState.furtherBlankLines = void 0;
      self.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code2);
    }
    self.containerState.furtherBlankLines = void 0;
    self.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok2, notInCurrentItem)(code2);
  }
  function notInCurrentItem(code2) {
    self.containerState._closeFlow = true;
    self.interrupt = void 0;
    return factorySpace(effects, effects.attempt(list, ok2, nok), "linePrefix", self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2);
  }
}
function tokenizeIndent(effects, ok2, nok) {
  const self = this;
  return factorySpace(effects, afterPrefix, "listItemIndent", self.containerState.size + 1);
  function afterPrefix(code2) {
    const tail = self.events[self.events.length - 1];
    return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self.containerState.size ? ok2(code2) : nok(code2);
  }
}
function tokenizeListEnd(effects) {
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok2, nok) {
  const self = this;
  return factorySpace(effects, afterPrefix, "listItemPrefixWhitespace", self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1);
  function afterPrefix(code2) {
    const tail = self.events[self.events.length - 1];
    return !markdownSpace(code2) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok2(code2) : nok(code2);
  }
}

// node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/setext-underline.js
var setextUnderline = {
  name: "setextUnderline",
  tokenize: tokenizeSetextUnderline,
  resolveTo: resolveToSetextUnderline
};
function resolveToSetextUnderline(events, context) {
  let index2 = events.length;
  let content3;
  let text4;
  let definition2;
  while (index2--) {
    if (events[index2][0] === "enter") {
      if (events[index2][1].type === "content") {
        content3 = index2;
        break;
      }
      if (events[index2][1].type === "paragraph") {
        text4 = index2;
      }
    } else {
      if (events[index2][1].type === "content") {
        events.splice(index2, 1);
      }
      if (!definition2 && events[index2][1].type === "definition") {
        definition2 = index2;
      }
    }
  }
  const heading = {
    type: "setextHeading",
    start: Object.assign({}, events[text4][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  events[text4][1].type = "setextHeadingText";
  if (definition2) {
    events.splice(text4, 0, ["enter", heading, context]);
    events.splice(definition2 + 1, 0, ["exit", events[content3][1], context]);
    events[content3][1].end = Object.assign({}, events[definition2][1].end);
  } else {
    events[content3][1] = heading;
  }
  events.push(["exit", heading, context]);
  return events;
}
function tokenizeSetextUnderline(effects, ok2, nok) {
  const self = this;
  let marker;
  return start;
  function start(code2) {
    let index2 = self.events.length;
    let paragraph;
    while (index2--) {
      if (self.events[index2][1].type !== "lineEnding" && self.events[index2][1].type !== "linePrefix" && self.events[index2][1].type !== "content") {
        paragraph = self.events[index2][1].type === "paragraph";
        break;
      }
    }
    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {
      effects.enter("setextHeadingLine");
      marker = code2;
      return before(code2);
    }
    return nok(code2);
  }
  function before(code2) {
    effects.enter("setextHeadingLineSequence");
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return inside;
    }
    effects.exit("setextHeadingLineSequence");
    return markdownSpace(code2) ? factorySpace(effects, after, "lineSuffix")(code2) : after(code2);
  }
  function after(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("setextHeadingLine");
      return ok2(code2);
    }
    return nok(code2);
  }
}

// node_modules/.pnpm/micromark@3.2.0/node_modules/micromark/lib/initialize/flow.js
var flow = {
  tokenize: initializeFlow
};
function initializeFlow(effects) {
  const self = this;
  const initial = effects.attempt(blankLine, atBlankEnding, effects.attempt(this.parser.constructs.flowInitial, afterConstruct, factorySpace(effects, effects.attempt(this.parser.constructs.flow, afterConstruct, effects.attempt(content2, afterConstruct)), "linePrefix")));
  return initial;
  function atBlankEnding(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEndingBlank");
    effects.consume(code2);
    effects.exit("lineEndingBlank");
    self.currentConstruct = void 0;
    return initial;
  }
  function afterConstruct(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    self.currentConstruct = void 0;
    return initial;
  }
}

// node_modules/.pnpm/micromark@3.2.0/node_modules/micromark/lib/initialize/text.js
var resolver = {
  resolveAll: createResolver()
};
var string = initializeFactory("string");
var text = initializeFactory("text");
function initializeFactory(field) {
  return {
    tokenize: initializeText,
    resolveAll: createResolver(field === "text" ? resolveAllLineSuffixes : void 0)
  };
  function initializeText(effects) {
    const self = this;
    const constructs2 = this.parser.constructs[field];
    const text4 = effects.attempt(constructs2, start, notText);
    return start;
    function start(code2) {
      return atBreak(code2) ? text4(code2) : notText(code2);
    }
    function notText(code2) {
      if (code2 === null) {
        effects.consume(code2);
        return;
      }
      effects.enter("data");
      effects.consume(code2);
      return data;
    }
    function data(code2) {
      if (atBreak(code2)) {
        effects.exit("data");
        return text4(code2);
      }
      effects.consume(code2);
      return data;
    }
    function atBreak(code2) {
      if (code2 === null) {
        return true;
      }
      const list2 = constructs2[code2];
      let index2 = -1;
      if (list2) {
        while (++index2 < list2.length) {
          const item = list2[index2];
          if (!item.previous || item.previous.call(self, self.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    let index2 = -1;
    let enter2;
    while (++index2 <= events.length) {
      if (enter2 === void 0) {
        if (events[index2] && events[index2][1].type === "data") {
          enter2 = index2;
          index2++;
        }
      } else if (!events[index2] || events[index2][1].type !== "data") {
        if (index2 !== enter2 + 2) {
          events[enter2][1].end = events[index2 - 1][1].end;
          events.splice(enter2 + 2, index2 - enter2 - 2);
          index2 = enter2 + 2;
        }
        enter2 = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
      const data = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data);
      let index2 = chunks.length;
      let bufferIndex = -1;
      let size2 = 0;
      let tabs;
      while (index2--) {
        const chunk = chunks[index2];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === 32) {
            size2++;
            bufferIndex--;
          }
          if (bufferIndex)
            break;
          bufferIndex = -1;
        } else if (chunk === -2) {
          tabs = true;
          size2++;
        } else if (chunk === -1) {
        } else {
          index2++;
          break;
        }
      }
      if (size2) {
        const token = {
          type: eventIndex === events.length || tabs || size2 < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: data.end.line,
            column: data.end.column - size2,
            offset: data.end.offset - size2,
            _index: data.start._index + index2,
            _bufferIndex: index2 ? bufferIndex : data.start._bufferIndex + bufferIndex
          },
          end: Object.assign({}, data.end)
        };
        data.end = Object.assign({}, token.start);
        if (data.start.offset === data.end.offset) {
          Object.assign(data, token);
        } else {
          events.splice(eventIndex, 0, ["enter", token, context], ["exit", token, context]);
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}

// node_modules/.pnpm/micromark@3.2.0/node_modules/micromark/lib/create-tokenizer.js
function createTokenizer(parser, initialize, from) {
  let point3 = Object.assign(from ? Object.assign({}, from) : {
    line: 1,
    column: 1,
    offset: 0
  }, {
    _index: 0,
    _bufferIndex: -1
  });
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack = [];
  let consumed = true;
  const effects = {
    consume,
    enter: enter2,
    exit: exit4,
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    interrupt: constructFactory(onsuccessfulcheck, {
      interrupt: true
    })
  };
  const context = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser,
    sliceStream,
    sliceSerialize,
    now,
    defineSkip,
    write
  };
  let state = initialize.tokenize.call(context, effects);
  let expectedCode;
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context;
  function write(slice) {
    chunks = push(chunks, slice);
    main();
    if (chunks[chunks.length - 1] !== null) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token, expandTabs) {
    return serializeChunks(sliceStream(token), expandTabs);
  }
  function sliceStream(token) {
    return sliceChunks(chunks, token);
  }
  function now() {
    const { line, column, offset, _index, _bufferIndex } = point3;
    return {
      line,
      column,
      offset,
      _index,
      _bufferIndex
    };
  }
  function defineSkip(value2) {
    columnStart[value2.line] = value2.column;
    accountForPotentialSkip();
  }
  function main() {
    let chunkIndex;
    while (point3._index < chunks.length) {
      const chunk = chunks[point3._index];
      if (typeof chunk === "string") {
        chunkIndex = point3._index;
        if (point3._bufferIndex < 0) {
          point3._bufferIndex = 0;
        }
        while (point3._index === chunkIndex && point3._bufferIndex < chunk.length) {
          go(chunk.charCodeAt(point3._bufferIndex));
        }
      } else {
        go(chunk);
      }
    }
  }
  function go(code2) {
    consumed = void 0;
    expectedCode = code2;
    state = state(code2);
  }
  function consume(code2) {
    if (markdownLineEnding(code2)) {
      point3.line++;
      point3.column = 1;
      point3.offset += code2 === -3 ? 2 : 1;
      accountForPotentialSkip();
    } else if (code2 !== -1) {
      point3.column++;
      point3.offset++;
    }
    if (point3._bufferIndex < 0) {
      point3._index++;
    } else {
      point3._bufferIndex++;
      if (point3._bufferIndex === chunks[point3._index].length) {
        point3._bufferIndex = -1;
        point3._index++;
      }
    }
    context.previous = code2;
    consumed = true;
  }
  function enter2(type, fields) {
    const token = fields || {};
    token.type = type;
    token.start = now();
    context.events.push(["enter", token, context]);
    stack.push(token);
    return token;
  }
  function exit4(type) {
    const token = stack.pop();
    token.end = now();
    context.events.push(["exit", token, context]);
    return token;
  }
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from);
  }
  function onsuccessfulcheck(_, info) {
    info.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info;
      return Array.isArray(constructs2) ? handleListOfConstructs(constructs2) : "tokenize" in constructs2 ? handleListOfConstructs([constructs2]) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map2) {
        return start;
        function start(code2) {
          const def = code2 !== null && map2[code2];
          const all2 = code2 !== null && map2.null;
          const list2 = [
            ...Array.isArray(def) ? def : def ? [def] : [],
            ...Array.isArray(all2) ? all2 : all2 ? [all2] : []
          ];
          return handleListOfConstructs(list2)(code2);
        }
      }
      function handleListOfConstructs(list2) {
        listOfConstructs = list2;
        constructIndex = 0;
        if (list2.length === 0) {
          return bogusState;
        }
        return handleConstruct(list2[constructIndex]);
      }
      function handleConstruct(construct) {
        return start;
        function start(code2) {
          info = store();
          currentConstruct = construct;
          if (!construct.partial) {
            context.currentConstruct = construct;
          }
          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
            return nok(code2);
          }
          return construct.tokenize.call(fields ? Object.assign(Object.create(context), fields) : context, effects, ok2, nok)(code2);
        }
      }
      function ok2(code2) {
        consumed = true;
        onreturn(currentConstruct, info);
        return returnState;
      }
      function nok(code2) {
        consumed = true;
        info.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from2) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      splice(context.events, from2, context.events.length - from2, construct.resolve(context.events.slice(from2), context));
    }
    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
  }
  function store() {
    const startPoint = now();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return {
      restore,
      from: startEventsIndex
    };
    function restore() {
      point3 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
    }
  }
  function accountForPotentialSkip() {
    if (point3.line in columnStart && point3.column < 2) {
      point3.column = columnStart[point3.line];
      point3.offset += columnStart[point3.line] - 1;
    }
  }
}
function sliceChunks(chunks, token) {
  const startIndex = token.start._index;
  const startBufferIndex = token.start._bufferIndex;
  const endIndex = token.end._index;
  const endBufferIndex = token.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      const head = view[0];
      if (typeof head === "string") {
        view[0] = head.slice(startBufferIndex);
      } else {
        view.shift();
      }
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks(chunks, expandTabs) {
  let index2 = -1;
  const result = [];
  let atTab;
  while (++index2 < chunks.length) {
    const chunk = chunks[index2];
    let value2;
    if (typeof chunk === "string") {
      value2 = chunk;
    } else
      switch (chunk) {
        case -5: {
          value2 = "\r";
          break;
        }
        case -4: {
          value2 = "\n";
          break;
        }
        case -3: {
          value2 = "\r\n";
          break;
        }
        case -2: {
          value2 = expandTabs ? " " : "	";
          break;
        }
        case -1: {
          if (!expandTabs && atTab)
            continue;
          value2 = " ";
          break;
        }
        default: {
          value2 = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === -2;
    result.push(value2);
  }
  return result.join("");
}

// node_modules/.pnpm/micromark@3.2.0/node_modules/micromark/lib/constructs.js
var constructs_exports = {};
__export(constructs_exports, {
  attentionMarkers: () => attentionMarkers,
  contentInitial: () => contentInitial,
  disable: () => disable,
  document: () => document3,
  flow: () => flow2,
  flowInitial: () => flowInitial,
  insideSpan: () => insideSpan,
  string: () => string2,
  text: () => text2
});
var document3 = {
  [42]: list,
  [43]: list,
  [45]: list,
  [48]: list,
  [49]: list,
  [50]: list,
  [51]: list,
  [52]: list,
  [53]: list,
  [54]: list,
  [55]: list,
  [56]: list,
  [57]: list,
  [62]: blockQuote
};
var contentInitial = {
  [91]: definition
};
var flowInitial = {
  [-2]: codeIndented,
  [-1]: codeIndented,
  [32]: codeIndented
};
var flow2 = {
  [35]: headingAtx,
  [42]: thematicBreak,
  [45]: [setextUnderline, thematicBreak],
  [60]: htmlFlow,
  [61]: setextUnderline,
  [95]: thematicBreak,
  [96]: codeFenced,
  [126]: codeFenced
};
var string2 = {
  [38]: characterReference,
  [92]: characterEscape
};
var text2 = {
  [-5]: lineEnding,
  [-4]: lineEnding,
  [-3]: lineEnding,
  [33]: labelStartImage,
  [38]: characterReference,
  [42]: attention,
  [60]: [autolink, htmlText],
  [91]: labelStartLink,
  [92]: [hardBreakEscape, characterEscape],
  [93]: labelEnd,
  [95]: attention,
  [96]: codeText
};
var insideSpan = {
  null: [attention, resolver]
};
var attentionMarkers = {
  null: [42, 95]
};
var disable = {
  null: []
};

// node_modules/.pnpm/micromark@3.2.0/node_modules/micromark/lib/parse.js
function parse(options) {
  const settings = options || {};
  const constructs2 = combineExtensions([constructs_exports, ...settings.extensions || []]);
  const parser = {
    defined: [],
    lazy: {},
    constructs: constructs2,
    content: create2(content),
    document: create2(document2),
    flow: create2(flow),
    string: create2(string),
    text: create2(text)
  };
  return parser;
  function create2(initial) {
    return creator;
    function creator(from) {
      return createTokenizer(parser, initial, from);
    }
  }
}

// node_modules/.pnpm/micromark@3.2.0/node_modules/micromark/lib/preprocess.js
var search = /[\0\t\n\r]/g;
function preprocess() {
  let column = 1;
  let buffer2 = "";
  let start = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value2, encoding, end) {
    const chunks = [];
    let match;
    let next;
    let startPosition;
    let endPosition;
    let code2;
    value2 = buffer2 + value2.toString(encoding);
    startPosition = 0;
    buffer2 = "";
    if (start) {
      if (value2.charCodeAt(0) === 65279) {
        startPosition++;
      }
      start = void 0;
    }
    while (startPosition < value2.length) {
      search.lastIndex = startPosition;
      match = search.exec(value2);
      endPosition = match && match.index !== void 0 ? match.index : value2.length;
      code2 = value2.charCodeAt(endPosition);
      if (!match) {
        buffer2 = value2.slice(startPosition);
        break;
      }
      if (code2 === 10 && startPosition === endPosition && atCarriageReturn) {
        chunks.push(-3);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(-5);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value2.slice(startPosition, endPosition));
          column += endPosition - startPosition;
        }
        switch (code2) {
          case 0: {
            chunks.push(65533);
            column++;
            break;
          }
          case 9: {
            next = Math.ceil(column / 4) * 4;
            chunks.push(-2);
            while (column++ < next)
              chunks.push(-1);
            break;
          }
          case 10: {
            chunks.push(-4);
            column = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end) {
      if (atCarriageReturn)
        chunks.push(-5);
      if (buffer2)
        chunks.push(buffer2);
      chunks.push(null);
    }
    return chunks;
  }
}

// node_modules/.pnpm/micromark@3.2.0/node_modules/micromark/lib/postprocess.js
function postprocess(events) {
  while (!subtokenize(events)) {
  }
  return events;
}

// node_modules/.pnpm/micromark-util-decode-numeric-character-reference@1.1.0/node_modules/micromark-util-decode-numeric-character-reference/index.js
function decodeNumericCharacterReference(value2, base2) {
  const code2 = Number.parseInt(value2, base2);
  if (code2 < 9 || code2 === 11 || code2 > 13 && code2 < 32 || code2 > 126 && code2 < 160 || code2 > 55295 && code2 < 57344 || code2 > 64975 && code2 < 65008 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || code2 > 1114111) {
    return "\uFFFD";
  }
  return String.fromCharCode(code2);
}

// node_modules/.pnpm/micromark-util-decode-string@1.1.0/node_modules/micromark-util-decode-string/index.js
var characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value2) {
  return value2.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $2) {
  if ($1) {
    return $1;
  }
  const head = $2.charCodeAt(0);
  if (head === 35) {
    const head2 = $2.charCodeAt(1);
    const hex = head2 === 120 || head2 === 88;
    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);
  }
  return decodeNamedCharacterReference($2) || $0;
}

// node_modules/.pnpm/mdast-util-from-markdown@1.3.1/node_modules/mdast-util-from-markdown/lib/index.js
var own2 = {}.hasOwnProperty;
var fromMarkdown = function(value2, encoding, options) {
  if (typeof encoding !== "string") {
    options = encoding;
    encoding = void 0;
  }
  return compiler(options)(postprocess(parse(options).document().write(preprocess()(value2, encoding, true))));
};
function compiler(options) {
  const config = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: opener2(link),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener2(heading),
      blockQuote: opener2(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener2(codeFlow),
      codeFencedFenceInfo: buffer2,
      codeFencedFenceMeta: buffer2,
      codeIndented: opener2(codeFlow, buffer2),
      codeText: opener2(codeText2, buffer2),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener2(definition2),
      definitionDestinationString: buffer2,
      definitionLabelString: buffer2,
      definitionTitleString: buffer2,
      emphasis: opener2(emphasis),
      hardBreakEscape: opener2(hardBreak),
      hardBreakTrailing: opener2(hardBreak),
      htmlFlow: opener2(html, buffer2),
      htmlFlowData: onenterdata,
      htmlText: opener2(html, buffer2),
      htmlTextData: onenterdata,
      image: opener2(image),
      label: buffer2,
      link: opener2(link),
      listItem: opener2(listItem2),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener2(list2, onenterlistordered),
      listUnordered: opener2(list2),
      paragraph: opener2(paragraph),
      reference: onenterreference,
      referenceString: buffer2,
      resourceDestinationString: buffer2,
      resourceTitleString: buffer2,
      setextHeading: opener2(heading),
      strong: opener2(strong),
      thematicBreak: opener2(thematicBreak2)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  };
  configure(config, (options || {}).mdastExtensions || []);
  const data = {};
  return compile;
  function compile(events) {
    let tree = {
      type: "root",
      children: []
    };
    const context = {
      stack: [tree],
      tokenStack: [],
      config,
      enter: enter2,
      exit: exit4,
      buffer: buffer2,
      resume,
      setData,
      getData
    };
    const listStack = [];
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "listOrdered" || events[index2][1].type === "listUnordered") {
        if (events[index2][0] === "enter") {
          listStack.push(index2);
        } else {
          const tail = listStack.pop();
          index2 = prepareList(events, tail, index2);
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      const handler2 = config[events[index2][0]];
      if (own2.call(handler2, events[index2][1].type)) {
        handler2[events[index2][1].type].call(Object.assign({
          sliceSerialize: events[index2][2].sliceSerialize
        }, context), events[index2][1]);
      }
    }
    if (context.tokenStack.length > 0) {
      const tail = context.tokenStack[context.tokenStack.length - 1];
      const handler2 = tail[1] || defaultOnError;
      handler2.call(context, void 0, tail[0]);
    }
    tree.position = {
      start: point2(events.length > 0 ? events[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: point2(events.length > 0 ? events[events.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    };
    index2 = -1;
    while (++index2 < config.transforms.length) {
      tree = config.transforms[index2](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start, length) {
    let index2 = start - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem3;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index2 <= length) {
      const event = events[index2];
      if (event[1].type === "listUnordered" || event[1].type === "listOrdered" || event[1].type === "blockQuote") {
        if (event[0] === "enter") {
          containerBalance++;
        } else {
          containerBalance--;
        }
        atMarker = void 0;
      } else if (event[1].type === "lineEndingBlank") {
        if (event[0] === "enter") {
          if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
            firstBlankLineIndex = index2;
          }
          atMarker = void 0;
        }
      } else if (event[1].type === "linePrefix" || event[1].type === "listItemValue" || event[1].type === "listItemMarker" || event[1].type === "listItemPrefix" || event[1].type === "listItemPrefixWhitespace") {
      } else {
        atMarker = void 0;
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
        if (listItem3) {
          let tailIndex = index2;
          lineIndex = void 0;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
              if (tailEvent[0] === "exit")
                continue;
              if (lineIndex) {
                events[lineIndex][1].type = "lineEndingBlank";
                listSpread = true;
              }
              tailEvent[1].type = "lineEnding";
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent") {
            } else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem3._spread = true;
          }
          listItem3.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);
          events.splice(lineIndex || index2, 0, ["exit", listItem3, event[2]]);
          index2++;
          length++;
        }
        if (event[1].type === "listItemPrefix") {
          listItem3 = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, event[1].start),
            end: void 0
          };
          events.splice(index2, 0, ["enter", listItem3, event[2]]);
          index2++;
          length++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start][1]._spread = listSpread;
    return length;
  }
  function setData(key, value2) {
    data[key] = value2;
  }
  function getData(key) {
    return data[key];
  }
  function opener2(create2, and) {
    return open;
    function open(token) {
      enter2.call(this, create2(token), token);
      if (and)
        and.call(this, token);
    }
  }
  function buffer2() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function enter2(node2, token, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    parent.children.push(node2);
    this.stack.push(node2);
    this.tokenStack.push([token, errorHandler]);
    node2.position = {
      start: point2(token.start)
    };
    return node2;
  }
  function closer(and) {
    return close2;
    function close2(token) {
      if (and)
        and.call(this, token);
      exit4.call(this, token);
    }
  }
  function exit4(token, onExitError) {
    const node2 = this.stack.pop();
    const open = this.tokenStack.pop();
    if (!open) {
      throw new Error("Cannot close `" + token.type + "` (" + stringifyPosition({
        start: token.start,
        end: token.end
      }) + "): it\u2019s not open");
    } else if (open[0].type !== token.type) {
      if (onExitError) {
        onExitError.call(this, token, open[0]);
      } else {
        const handler2 = open[1] || defaultOnError;
        handler2.call(this, token, open[0]);
      }
    }
    node2.position.end = point2(token.end);
    return node2;
  }
  function resume() {
    return toString(this.stack.pop());
  }
  function onenterlistordered() {
    setData("expectingFirstListItemValue", true);
  }
  function onenterlistitemvalue(token) {
    if (getData("expectingFirstListItemValue")) {
      const ancestor = this.stack[this.stack.length - 2];
      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);
      setData("expectingFirstListItemValue");
    }
  }
  function onexitcodefencedfenceinfo() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.lang = data2;
  }
  function onexitcodefencedfencemeta() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.meta = data2;
  }
  function onexitcodefencedfence() {
    if (getData("flowCodeInside"))
      return;
    this.buffer();
    setData("flowCodeInside", true);
  }
  function onexitcodefenced() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    setData("flowCodeInside");
  }
  function onexitcodeindented() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token) {
    const label4 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.label = label4;
    node2.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.title = data2;
  }
  function onexitdefinitiondestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.url = data2;
  }
  function onexitatxheadingsequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    if (!node2.depth) {
      const depth = this.sliceSerialize(token).length;
      node2.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    setData("setextHeadingSlurpLineEnding", true);
  }
  function onexitsetextheadinglinesequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    node2.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2;
  }
  function onexitsetextheading() {
    setData("setextHeadingSlurpLineEnding");
  }
  function onenterdata(token) {
    const node2 = this.stack[this.stack.length - 1];
    let tail = node2.children[node2.children.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text4();
      tail.position = {
        start: point2(token.start)
      };
      node2.children.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token) {
    const tail = this.stack.pop();
    tail.value += this.sliceSerialize(token);
    tail.position.end = point2(token.end);
  }
  function onexitlineending(token) {
    const context = this.stack[this.stack.length - 1];
    if (getData("atHardBreak")) {
      const tail = context.children[context.children.length - 1];
      tail.position.end = point2(token.end);
      setData("atHardBreak");
      return;
    }
    if (!getData("setextHeadingSlurpLineEnding") && config.canContainEols.includes(context.type)) {
      onenterdata.call(this, token);
      onexitdata.call(this, token);
    }
  }
  function onexithardbreak() {
    setData("atHardBreak", true);
  }
  function onexithtmlflow() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2;
  }
  function onexithtmltext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2;
  }
  function onexitcodetext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2;
  }
  function onexitlink() {
    const node2 = this.stack[this.stack.length - 1];
    if (getData("inReference")) {
      const referenceType = getData("referenceType") || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    setData("referenceType");
  }
  function onexitimage() {
    const node2 = this.stack[this.stack.length - 1];
    if (getData("inReference")) {
      const referenceType = getData("referenceType") || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    setData("referenceType");
  }
  function onexitlabeltext(token) {
    const string3 = this.sliceSerialize(token);
    const ancestor = this.stack[this.stack.length - 2];
    ancestor.label = decodeString(string3);
    ancestor.identifier = normalizeIdentifier(string3).toLowerCase();
  }
  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1];
    const value2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    setData("inReference", true);
    if (node2.type === "link") {
      const children = fragment.children;
      node2.children = children;
    } else {
      node2.alt = value2;
    }
  }
  function onexitresourcedestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.url = data2;
  }
  function onexitresourcetitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.title = data2;
  }
  function onexitresource() {
    setData("inReference");
  }
  function onenterreference() {
    setData("referenceType", "collapsed");
  }
  function onexitreferencestring(token) {
    const label4 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.label = label4;
    node2.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
    setData("referenceType", "full");
  }
  function onexitcharacterreferencemarker(token) {
    setData("characterReferenceType", token.type);
  }
  function onexitcharacterreferencevalue(token) {
    const data2 = this.sliceSerialize(token);
    const type = getData("characterReferenceType");
    let value2;
    if (type) {
      value2 = decodeNumericCharacterReference(data2, type === "characterReferenceMarkerNumeric" ? 10 : 16);
      setData("characterReferenceType");
    } else {
      const result = decodeNamedCharacterReference(data2);
      value2 = result;
    }
    const tail = this.stack.pop();
    tail.value += value2;
    tail.position.end = point2(token.end);
  }
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    node2.url = this.sliceSerialize(token);
  }
  function onexitautolinkemail(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    node2.url = "mailto:" + this.sliceSerialize(token);
  }
  function blockQuote2() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function codeFlow() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function codeText2() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function definition2() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function heading() {
    return {
      type: "heading",
      depth: void 0,
      children: []
    };
  }
  function hardBreak() {
    return {
      type: "break"
    };
  }
  function html() {
    return {
      type: "html",
      value: ""
    };
  }
  function image() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function link() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function list2(token) {
    return {
      type: "list",
      ordered: token.type === "listOrdered",
      start: null,
      spread: token._spread,
      children: []
    };
  }
  function listItem2(token) {
    return {
      type: "listItem",
      spread: token._spread,
      checked: null,
      children: []
    };
  }
  function paragraph() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function strong() {
    return {
      type: "strong",
      children: []
    };
  }
  function text4() {
    return {
      type: "text",
      value: ""
    };
  }
  function thematicBreak2() {
    return {
      type: "thematicBreak"
    };
  }
}
function point2(d) {
  return {
    line: d.line,
    column: d.column,
    offset: d.offset
  };
}
function configure(combined, extensions) {
  let index2 = -1;
  while (++index2 < extensions.length) {
    const value2 = extensions[index2];
    if (Array.isArray(value2)) {
      configure(combined, value2);
    } else {
      extension(combined, value2);
    }
  }
}
function extension(combined, extension2) {
  let key;
  for (key in extension2) {
    if (own2.call(extension2, key)) {
      if (key === "canContainEols") {
        const right = extension2[key];
        if (right) {
          combined[key].push(...right);
        }
      } else if (key === "transforms") {
        const right = extension2[key];
        if (right) {
          combined[key].push(...right);
        }
      } else if (key === "enter" || key === "exit") {
        const right = extension2[key];
        if (right) {
          Object.assign(combined[key], right);
        }
      }
    }
  }
}
function defaultOnError(left, right) {
  if (left) {
    throw new Error("Cannot close `" + left.type + "` (" + stringifyPosition({
      start: left.start,
      end: left.end
    }) + "): a different token (`" + right.type + "`, " + stringifyPosition({
      start: right.start,
      end: right.end
    }) + ") is open");
  } else {
    throw new Error("Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({
      start: right.start,
      end: right.end
    }) + ") is still open");
  }
}

// node_modules/.pnpm/remark-parse@10.0.2/node_modules/remark-parse/lib/index.js
function remarkParse(options) {
  const parser = (doc) => {
    const settings = this.data("settings");
    return fromMarkdown(doc, Object.assign({}, settings, options, {
      extensions: this.data("micromarkExtensions") || [],
      mdastExtensions: this.data("fromMarkdownExtensions") || []
    }));
  };
  Object.assign(this, { Parser: parser });
}

// node_modules/.pnpm/micromark-extension-math@2.1.2/node_modules/micromark-extension-math/lib/math-flow.js
var mathFlow = {
  tokenize: tokenizeMathFenced,
  concrete: true
};
var nonLazyContinuation2 = {
  tokenize: tokenizeNonLazyContinuation2,
  partial: true
};
function tokenizeMathFenced(effects, ok2, nok) {
  const self = this;
  const tail = self.events[self.events.length - 1];
  const initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let sizeOpen = 0;
  return start;
  function start(code2) {
    effects.enter("mathFlow");
    effects.enter("mathFlowFence");
    effects.enter("mathFlowFenceSequence");
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === 36) {
      effects.consume(code2);
      sizeOpen++;
      return sequenceOpen;
    }
    if (sizeOpen < 2) {
      return nok(code2);
    }
    effects.exit("mathFlowFenceSequence");
    return factorySpace(effects, metaBefore, "whitespace")(code2);
  }
  function metaBefore(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return metaAfter(code2);
    }
    effects.enter("mathFlowFenceMeta");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return meta(code2);
  }
  function meta(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      effects.exit("mathFlowFenceMeta");
      return metaAfter(code2);
    }
    if (code2 === 36) {
      return nok(code2);
    }
    effects.consume(code2);
    return meta;
  }
  function metaAfter(code2) {
    effects.exit("mathFlowFence");
    if (self.interrupt) {
      return ok2(code2);
    }
    return effects.attempt(nonLazyContinuation2, beforeNonLazyContinuation, after)(code2);
  }
  function beforeNonLazyContinuation(code2) {
    return effects.attempt({
      tokenize: tokenizeClosingFence,
      partial: true
    }, after, contentStart)(code2);
  }
  function contentStart(code2) {
    return (initialSize ? factorySpace(effects, beforeContentChunk, "linePrefix", initialSize + 1) : beforeContentChunk)(code2);
  }
  function beforeContentChunk(code2) {
    if (code2 === null) {
      return after(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.attempt(nonLazyContinuation2, beforeNonLazyContinuation, after)(code2);
    }
    effects.enter("mathFlowValue");
    return contentChunk(code2);
  }
  function contentChunk(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("mathFlowValue");
      return beforeContentChunk(code2);
    }
    effects.consume(code2);
    return contentChunk;
  }
  function after(code2) {
    effects.exit("mathFlow");
    return ok2(code2);
  }
  function tokenizeClosingFence(effects2, ok3, nok2) {
    let size2 = 0;
    return factorySpace(effects2, beforeSequenceClose, "linePrefix", self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
    function beforeSequenceClose(code2) {
      effects2.enter("mathFlowFence");
      effects2.enter("mathFlowFenceSequence");
      return sequenceClose(code2);
    }
    function sequenceClose(code2) {
      if (code2 === 36) {
        size2++;
        effects2.consume(code2);
        return sequenceClose;
      }
      if (size2 < sizeOpen) {
        return nok2(code2);
      }
      effects2.exit("mathFlowFenceSequence");
      return factorySpace(effects2, afterSequenceClose, "whitespace")(code2);
    }
    function afterSequenceClose(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects2.exit("mathFlowFence");
        return ok3(code2);
      }
      return nok2(code2);
    }
  }
}
function tokenizeNonLazyContinuation2(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    if (code2 === null) {
      return ok2(code2);
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return lineStart;
  }
  function lineStart(code2) {
    return self.parser.lazy[self.now().line] ? nok(code2) : ok2(code2);
  }
}

// node_modules/.pnpm/micromark-extension-math@2.1.2/node_modules/micromark-extension-math/lib/math-text.js
function mathText(options) {
  const options_ = options || {};
  let single = options_.singleDollarTextMath;
  if (single === null || single === void 0) {
    single = true;
  }
  return {
    tokenize: tokenizeMathText,
    resolve: resolveMathText,
    previous: previous2
  };
  function tokenizeMathText(effects, ok2, nok) {
    const self = this;
    let sizeOpen = 0;
    let size2;
    let token;
    return start;
    function start(code2) {
      effects.enter("mathText");
      effects.enter("mathTextSequence");
      return sequenceOpen(code2);
    }
    function sequenceOpen(code2) {
      if (code2 === 36) {
        effects.consume(code2);
        sizeOpen++;
        return sequenceOpen;
      }
      if (sizeOpen < 2 && !single) {
        return nok(code2);
      }
      effects.exit("mathTextSequence");
      return between2(code2);
    }
    function between2(code2) {
      if (code2 === null) {
        return nok(code2);
      }
      if (code2 === 36) {
        token = effects.enter("mathTextSequence");
        size2 = 0;
        return sequenceClose(code2);
      }
      if (code2 === 32) {
        effects.enter("space");
        effects.consume(code2);
        effects.exit("space");
        return between2;
      }
      if (markdownLineEnding(code2)) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return between2;
      }
      effects.enter("mathTextData");
      return data(code2);
    }
    function data(code2) {
      if (code2 === null || code2 === 32 || code2 === 36 || markdownLineEnding(code2)) {
        effects.exit("mathTextData");
        return between2(code2);
      }
      effects.consume(code2);
      return data;
    }
    function sequenceClose(code2) {
      if (code2 === 36) {
        effects.consume(code2);
        size2++;
        return sequenceClose;
      }
      if (size2 === sizeOpen) {
        effects.exit("mathTextSequence");
        effects.exit("mathText");
        return ok2(code2);
      }
      token.type = "mathTextData";
      return data(code2);
    }
  }
}
function resolveMathText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index2;
  let enter2;
  if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
    index2 = headEnterIndex;
    while (++index2 < tailExitIndex) {
      if (events[index2][1].type === "mathTextData") {
        events[tailExitIndex][1].type = "mathTextPadding";
        events[headEnterIndex][1].type = "mathTextPadding";
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index2 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index2 <= tailExitIndex) {
    if (enter2 === void 0) {
      if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
        enter2 = index2;
      }
    } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
      events[enter2][1].type = "mathTextData";
      if (index2 !== enter2 + 2) {
        events[enter2][1].end = events[index2 - 1][1].end;
        events.splice(enter2 + 2, index2 - enter2 - 2);
        tailExitIndex -= index2 - enter2 - 2;
        index2 = enter2 + 2;
      }
      enter2 = void 0;
    }
  }
  return events;
}
function previous2(code2) {
  return code2 !== 36 || this.events[this.events.length - 1][1].type === "characterEscape";
}

// node_modules/.pnpm/micromark-extension-math@2.1.2/node_modules/micromark-extension-math/lib/syntax.js
function math(options) {
  return {
    flow: {
      [36]: mathFlow
    },
    text: {
      [36]: mathText(options)
    }
  };
}

// node_modules/.pnpm/longest-streak@3.1.0/node_modules/longest-streak/index.js
function longestStreak(value2, substring) {
  const source = String(value2);
  let index2 = source.indexOf(substring);
  let expected = index2;
  let count = 0;
  let max = 0;
  if (typeof substring !== "string") {
    throw new TypeError("Expected substring");
  }
  while (index2 !== -1) {
    if (index2 === expected) {
      if (++count > max) {
        max = count;
      }
    } else {
      count = 1;
    }
    expected = index2 + substring.length;
    index2 = source.indexOf(substring, expected);
  }
  return max;
}

// node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js
function patternCompile(pattern) {
  if (!pattern._compiled) {
    const before = (pattern.atBreak ? "[\\r\\n][\\t ]*" : "") + (pattern.before ? "(?:" + pattern.before + ")" : "");
    pattern._compiled = new RegExp((before ? "(" + before + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(pattern.character) ? "\\" : "") + pattern.character + (pattern.after ? "(?:" + pattern.after + ")" : ""), "g");
  }
  return pattern._compiled;
}

// node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js
function patternInScope(stack, pattern) {
  return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
}
function listInScope(stack, list2, none) {
  if (typeof list2 === "string") {
    list2 = [list2];
  }
  if (!list2 || list2.length === 0) {
    return none;
  }
  let index2 = -1;
  while (++index2 < list2.length) {
    if (stack.includes(list2[index2])) {
      return true;
    }
  }
  return false;
}

// node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/safe.js
function safe(state, input, config) {
  const value2 = (config.before || "") + (input || "") + (config.after || "");
  const positions = [];
  const result = [];
  const infos = {};
  let index2 = -1;
  while (++index2 < state.unsafe.length) {
    const pattern = state.unsafe[index2];
    if (!patternInScope(state.stack, pattern)) {
      continue;
    }
    const expression = patternCompile(pattern);
    let match;
    while (match = expression.exec(value2)) {
      const before = "before" in pattern || Boolean(pattern.atBreak);
      const after = "after" in pattern;
      const position2 = match.index + (before ? match[1].length : 0);
      if (positions.includes(position2)) {
        if (infos[position2].before && !before) {
          infos[position2].before = false;
        }
        if (infos[position2].after && !after) {
          infos[position2].after = false;
        }
      } else {
        positions.push(position2);
        infos[position2] = { before, after };
      }
    }
  }
  positions.sort(numerical);
  let start = config.before ? config.before.length : 0;
  const end = value2.length - (config.after ? config.after.length : 0);
  index2 = -1;
  while (++index2 < positions.length) {
    const position2 = positions[index2];
    if (position2 < start || position2 >= end) {
      continue;
    }
    if (position2 + 1 < end && positions[index2 + 1] === position2 + 1 && infos[position2].after && !infos[position2 + 1].before && !infos[position2 + 1].after || positions[index2 - 1] === position2 - 1 && infos[position2].before && !infos[position2 - 1].before && !infos[position2 - 1].after) {
      continue;
    }
    if (start !== position2) {
      result.push(escapeBackslashes(value2.slice(start, position2), "\\"));
    }
    start = position2;
    if (/[!-/:-@[-`{-~]/.test(value2.charAt(position2)) && (!config.encode || !config.encode.includes(value2.charAt(position2)))) {
      result.push("\\");
    } else {
      result.push("&#x" + value2.charCodeAt(position2).toString(16).toUpperCase() + ";");
      start++;
    }
  }
  result.push(escapeBackslashes(value2.slice(start, end), config.after));
  return result.join("");
}
function numerical(a, b) {
  return a - b;
}
function escapeBackslashes(value2, after) {
  const expression = /\\(?=[!-/:-@[-`{-~])/g;
  const positions = [];
  const results = [];
  const whole = value2 + after;
  let index2 = -1;
  let start = 0;
  let match;
  while (match = expression.exec(whole)) {
    positions.push(match.index);
  }
  while (++index2 < positions.length) {
    if (start !== positions[index2]) {
      results.push(value2.slice(start, positions[index2]));
    }
    results.push("\\");
    start = positions[index2];
  }
  results.push(value2.slice(start));
  return results.join("");
}

// node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/track.js
function track(config) {
  const options = config || {};
  const now = options.now || {};
  let lineShift = options.lineShift || 0;
  let line = now.line || 1;
  let column = now.column || 1;
  return { move, current, shift };
  function current() {
    return { now: { line, column }, lineShift };
  }
  function shift(value2) {
    lineShift += value2;
  }
  function move(input) {
    const value2 = input || "";
    const chunks = value2.split(/\r?\n|\r/g);
    const tail = chunks[chunks.length - 1];
    line += chunks.length - 1;
    column = chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift;
    return value2;
  }
}

// node_modules/.pnpm/mdast-util-math@2.0.2/node_modules/mdast-util-math/lib/index.js
function mathFromMarkdown() {
  return {
    enter: {
      mathFlow: enterMathFlow,
      mathFlowFenceMeta: enterMathFlowMeta,
      mathText: enterMathText
    },
    exit: {
      mathFlow: exitMathFlow,
      mathFlowFence: exitMathFlowFence,
      mathFlowFenceMeta: exitMathFlowMeta,
      mathFlowValue: exitMathData,
      mathText: exitMathText,
      mathTextData: exitMathData
    }
  };
  function enterMathFlow(token) {
    this.enter({
      type: "math",
      meta: null,
      value: "",
      data: {
        hName: "div",
        hProperties: { className: ["math", "math-display"] },
        hChildren: [{ type: "text", value: "" }]
      }
    }, token);
  }
  function enterMathFlowMeta() {
    this.buffer();
  }
  function exitMathFlowMeta() {
    const data = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.meta = data;
  }
  function exitMathFlowFence() {
    if (this.getData("mathFlowInside"))
      return;
    this.buffer();
    this.setData("mathFlowInside", true);
  }
  function exitMathFlow(token) {
    const data = this.resume().replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    const node2 = this.exit(token);
    node2.value = data;
    node2.data.hChildren[0].value = data;
    this.setData("mathFlowInside");
  }
  function enterMathText(token) {
    this.enter({
      type: "inlineMath",
      value: "",
      data: {
        hName: "span",
        hProperties: { className: ["math", "math-inline"] },
        hChildren: [{ type: "text", value: "" }]
      }
    }, token);
    this.buffer();
  }
  function exitMathText(token) {
    const data = this.resume();
    const node2 = this.exit(token);
    node2.value = data;
    node2.data.hChildren[0].value = data;
  }
  function exitMathData(token) {
    this.config.enter.data.call(this, token);
    this.config.exit.data.call(this, token);
  }
}
function mathToMarkdown(options) {
  let single = (options || {}).singleDollarTextMath;
  if (single === null || single === void 0) {
    single = true;
  }
  inlineMath.peek = inlineMathPeek;
  return {
    unsafe: [
      { character: "\r", inConstruct: "mathFlowMeta" },
      { character: "\n", inConstruct: "mathFlowMeta" },
      {
        character: "$",
        after: single ? void 0 : "\\$",
        inConstruct: "phrasing"
      },
      { character: "$", inConstruct: "mathFlowMeta" },
      { atBreak: true, character: "$", after: "\\$" }
    ],
    handlers: { math: math2, inlineMath }
  };
  function math2(node2, _, context, safeOptions) {
    const raw = node2.value || "";
    const tracker = track(safeOptions);
    const sequence = "$".repeat(Math.max(longestStreak(raw, "$") + 1, 2));
    const exit4 = context.enter("mathFlow");
    let value2 = tracker.move(sequence);
    if (node2.meta) {
      const subexit = context.enter("mathFlowMeta");
      value2 += tracker.move(safe(context, node2.meta, __spreadValues({
        before: value2,
        after: "\n",
        encode: ["$"]
      }, tracker.current())));
      subexit();
    }
    value2 += tracker.move("\n");
    if (raw) {
      value2 += tracker.move(raw + "\n");
    }
    value2 += tracker.move(sequence);
    exit4();
    return value2;
  }
  function inlineMath(node2, _, context) {
    let value2 = node2.value || "";
    let size2 = 1;
    if (!single)
      size2++;
    while (new RegExp("(^|[^$])" + "\\$".repeat(size2) + "([^$]|$)").test(value2)) {
      size2++;
    }
    const sequence = "$".repeat(size2);
    if (/[^ \r\n]/.test(value2) && (/^[ \r\n]/.test(value2) && /[ \r\n]$/.test(value2) || /^\$|\$$/.test(value2))) {
      value2 = " " + value2 + " ";
    }
    let index2 = -1;
    while (++index2 < context.unsafe.length) {
      const pattern = context.unsafe[index2];
      const expression = patternCompile(pattern);
      let match;
      if (!pattern.atBreak)
        continue;
      while (match = expression.exec(value2)) {
        let position2 = match.index;
        if (value2.codePointAt(position2) === 10 && value2.codePointAt(position2 - 1) === 13) {
          position2--;
        }
        value2 = value2.slice(0, position2) + " " + value2.slice(match.index + 1);
      }
    }
    return sequence + value2 + sequence;
  }
  function inlineMathPeek() {
    return "$";
  }
}

// node_modules/.pnpm/remark-math@5.1.1/node_modules/remark-math/index.js
function remarkMath(options = {}) {
  const data = this.data();
  add("micromarkExtensions", math(options));
  add("fromMarkdownExtensions", mathFromMarkdown());
  add("toMarkdownExtensions", mathToMarkdown(options));
  function add(field, value2) {
    const list2 = data[field] ? data[field] : data[field] = [];
    list2.push(value2);
  }
}

// node_modules/.pnpm/micromark-extension-gfm-autolink-literal@1.0.5/node_modules/micromark-extension-gfm-autolink-literal/lib/syntax.js
var wwwPrefix = {
  tokenize: tokenizeWwwPrefix,
  partial: true
};
var domain = {
  tokenize: tokenizeDomain,
  partial: true
};
var path2 = {
  tokenize: tokenizePath,
  partial: true
};
var trail = {
  tokenize: tokenizeTrail,
  partial: true
};
var emailDomainDotTrail = {
  tokenize: tokenizeEmailDomainDotTrail,
  partial: true
};
var wwwAutolink = {
  tokenize: tokenizeWwwAutolink,
  previous: previousWww
};
var protocolAutolink = {
  tokenize: tokenizeProtocolAutolink,
  previous: previousProtocol
};
var emailAutolink = {
  tokenize: tokenizeEmailAutolink,
  previous: previousEmail
};
var text3 = {};
var gfmAutolinkLiteral = {
  text: text3
};
var code = 48;
while (code < 123) {
  text3[code] = emailAutolink;
  code++;
  if (code === 58)
    code = 65;
  else if (code === 91)
    code = 97;
}
text3[43] = emailAutolink;
text3[45] = emailAutolink;
text3[46] = emailAutolink;
text3[95] = emailAutolink;
text3[72] = [emailAutolink, protocolAutolink];
text3[104] = [emailAutolink, protocolAutolink];
text3[87] = [emailAutolink, wwwAutolink];
text3[119] = [emailAutolink, wwwAutolink];
function tokenizeEmailAutolink(effects, ok2, nok) {
  const self = this;
  let dot;
  let data;
  return start;
  function start(code2) {
    if (!gfmAtext(code2) || !previousEmail.call(self, self.previous) || previousUnbalanced(self.events)) {
      return nok(code2);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkEmail");
    return atext(code2);
  }
  function atext(code2) {
    if (gfmAtext(code2)) {
      effects.consume(code2);
      return atext;
    }
    if (code2 === 64) {
      effects.consume(code2);
      return emailDomain;
    }
    return nok(code2);
  }
  function emailDomain(code2) {
    if (code2 === 46) {
      return effects.check(emailDomainDotTrail, emailDomainAfter, emailDomainDot)(code2);
    }
    if (code2 === 45 || code2 === 95 || asciiAlphanumeric(code2)) {
      data = true;
      effects.consume(code2);
      return emailDomain;
    }
    return emailDomainAfter(code2);
  }
  function emailDomainDot(code2) {
    effects.consume(code2);
    dot = true;
    return emailDomain;
  }
  function emailDomainAfter(code2) {
    if (data && dot && asciiAlpha(self.previous)) {
      effects.exit("literalAutolinkEmail");
      effects.exit("literalAutolink");
      return ok2(code2);
    }
    return nok(code2);
  }
}
function tokenizeWwwAutolink(effects, ok2, nok) {
  const self = this;
  return wwwStart;
  function wwwStart(code2) {
    if (code2 !== 87 && code2 !== 119 || !previousWww.call(self, self.previous) || previousUnbalanced(self.events)) {
      return nok(code2);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkWww");
    return effects.check(wwwPrefix, effects.attempt(domain, effects.attempt(path2, wwwAfter), nok), nok)(code2);
  }
  function wwwAfter(code2) {
    effects.exit("literalAutolinkWww");
    effects.exit("literalAutolink");
    return ok2(code2);
  }
}
function tokenizeProtocolAutolink(effects, ok2, nok) {
  const self = this;
  let buffer2 = "";
  let seen = false;
  return protocolStart;
  function protocolStart(code2) {
    if ((code2 === 72 || code2 === 104) && previousProtocol.call(self, self.previous) && !previousUnbalanced(self.events)) {
      effects.enter("literalAutolink");
      effects.enter("literalAutolinkHttp");
      buffer2 += String.fromCodePoint(code2);
      effects.consume(code2);
      return protocolPrefixInside;
    }
    return nok(code2);
  }
  function protocolPrefixInside(code2) {
    if (asciiAlpha(code2) && buffer2.length < 5) {
      buffer2 += String.fromCodePoint(code2);
      effects.consume(code2);
      return protocolPrefixInside;
    }
    if (code2 === 58) {
      const protocol = buffer2.toLowerCase();
      if (protocol === "http" || protocol === "https") {
        effects.consume(code2);
        return protocolSlashesInside;
      }
    }
    return nok(code2);
  }
  function protocolSlashesInside(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      if (seen) {
        return afterProtocol;
      }
      seen = true;
      return protocolSlashesInside;
    }
    return nok(code2);
  }
  function afterProtocol(code2) {
    return code2 === null || asciiControl(code2) || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2) || unicodePunctuation(code2) ? nok(code2) : effects.attempt(domain, effects.attempt(path2, protocolAfter), nok)(code2);
  }
  function protocolAfter(code2) {
    effects.exit("literalAutolinkHttp");
    effects.exit("literalAutolink");
    return ok2(code2);
  }
}
function tokenizeWwwPrefix(effects, ok2, nok) {
  let size2 = 0;
  return wwwPrefixInside;
  function wwwPrefixInside(code2) {
    if ((code2 === 87 || code2 === 119) && size2 < 3) {
      size2++;
      effects.consume(code2);
      return wwwPrefixInside;
    }
    if (code2 === 46 && size2 === 3) {
      effects.consume(code2);
      return wwwPrefixAfter;
    }
    return nok(code2);
  }
  function wwwPrefixAfter(code2) {
    return code2 === null ? nok(code2) : ok2(code2);
  }
}
function tokenizeDomain(effects, ok2, nok) {
  let underscoreInLastSegment;
  let underscoreInLastLastSegment;
  let seen;
  return domainInside;
  function domainInside(code2) {
    if (code2 === 46 || code2 === 95) {
      return effects.check(trail, domainAfter, domainAtPunctuation)(code2);
    }
    if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2) || code2 !== 45 && unicodePunctuation(code2)) {
      return domainAfter(code2);
    }
    seen = true;
    effects.consume(code2);
    return domainInside;
  }
  function domainAtPunctuation(code2) {
    if (code2 === 95) {
      underscoreInLastSegment = true;
    } else {
      underscoreInLastLastSegment = underscoreInLastSegment;
      underscoreInLastSegment = void 0;
    }
    effects.consume(code2);
    return domainInside;
  }
  function domainAfter(code2) {
    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {
      return nok(code2);
    }
    return ok2(code2);
  }
}
function tokenizePath(effects, ok2) {
  let sizeOpen = 0;
  let sizeClose = 0;
  return pathInside;
  function pathInside(code2) {
    if (code2 === 40) {
      sizeOpen++;
      effects.consume(code2);
      return pathInside;
    }
    if (code2 === 41 && sizeClose < sizeOpen) {
      return pathAtPunctuation(code2);
    }
    if (code2 === 33 || code2 === 34 || code2 === 38 || code2 === 39 || code2 === 41 || code2 === 42 || code2 === 44 || code2 === 46 || code2 === 58 || code2 === 59 || code2 === 60 || code2 === 63 || code2 === 93 || code2 === 95 || code2 === 126) {
      return effects.check(trail, ok2, pathAtPunctuation)(code2);
    }
    if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
      return ok2(code2);
    }
    effects.consume(code2);
    return pathInside;
  }
  function pathAtPunctuation(code2) {
    if (code2 === 41) {
      sizeClose++;
    }
    effects.consume(code2);
    return pathInside;
  }
}
function tokenizeTrail(effects, ok2, nok) {
  return trail2;
  function trail2(code2) {
    if (code2 === 33 || code2 === 34 || code2 === 39 || code2 === 41 || code2 === 42 || code2 === 44 || code2 === 46 || code2 === 58 || code2 === 59 || code2 === 63 || code2 === 95 || code2 === 126) {
      effects.consume(code2);
      return trail2;
    }
    if (code2 === 38) {
      effects.consume(code2);
      return trailCharRefStart;
    }
    if (code2 === 93) {
      effects.consume(code2);
      return trailBracketAfter;
    }
    if (code2 === 60 || code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
      return ok2(code2);
    }
    return nok(code2);
  }
  function trailBracketAfter(code2) {
    if (code2 === null || code2 === 40 || code2 === 91 || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
      return ok2(code2);
    }
    return trail2(code2);
  }
  function trailCharRefStart(code2) {
    return asciiAlpha(code2) ? trailCharRefInside(code2) : nok(code2);
  }
  function trailCharRefInside(code2) {
    if (code2 === 59) {
      effects.consume(code2);
      return trail2;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return trailCharRefInside;
    }
    return nok(code2);
  }
}
function tokenizeEmailDomainDotTrail(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.consume(code2);
    return after;
  }
  function after(code2) {
    return asciiAlphanumeric(code2) ? nok(code2) : ok2(code2);
  }
}
function previousWww(code2) {
  return code2 === null || code2 === 40 || code2 === 42 || code2 === 95 || code2 === 91 || code2 === 93 || code2 === 126 || markdownLineEndingOrSpace(code2);
}
function previousProtocol(code2) {
  return !asciiAlpha(code2);
}
function previousEmail(code2) {
  return !(code2 === 47 || gfmAtext(code2));
}
function gfmAtext(code2) {
  return code2 === 43 || code2 === 45 || code2 === 46 || code2 === 95 || asciiAlphanumeric(code2);
}
function previousUnbalanced(events) {
  let index2 = events.length;
  let result = false;
  while (index2--) {
    const token = events[index2][1];
    if ((token.type === "labelLink" || token.type === "labelImage") && !token._balanced) {
      result = true;
      break;
    }
    if (token._gfmAutolinkLiteralWalkedInto) {
      result = false;
      break;
    }
  }
  if (events.length > 0 && !result) {
    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
  }
  return result;
}

// node_modules/.pnpm/micromark-extension-gfm-footnote@1.1.2/node_modules/micromark-extension-gfm-footnote/lib/syntax.js
var indent = {
  tokenize: tokenizeIndent2,
  partial: true
};
function gfmFootnote() {
  return {
    document: {
      [91]: {
        tokenize: tokenizeDefinitionStart,
        continuation: {
          tokenize: tokenizeDefinitionContinuation
        },
        exit: gfmFootnoteDefinitionEnd
      }
    },
    text: {
      [91]: {
        tokenize: tokenizeGfmFootnoteCall
      },
      [93]: {
        add: "after",
        tokenize: tokenizePotentialGfmFootnoteCall,
        resolveTo: resolveToPotentialGfmFootnoteCall
      }
    }
  };
}
function tokenizePotentialGfmFootnoteCall(effects, ok2, nok) {
  const self = this;
  let index2 = self.events.length;
  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);
  let labelStart;
  while (index2--) {
    const token = self.events[index2][1];
    if (token.type === "labelImage") {
      labelStart = token;
      break;
    }
    if (token.type === "gfmFootnoteCall" || token.type === "labelLink" || token.type === "label" || token.type === "image" || token.type === "link") {
      break;
    }
  }
  return start;
  function start(code2) {
    if (!labelStart || !labelStart._balanced) {
      return nok(code2);
    }
    const id = normalizeIdentifier(self.sliceSerialize({
      start: labelStart.end,
      end: self.now()
    }));
    if (id.codePointAt(0) !== 94 || !defined.includes(id.slice(1))) {
      return nok(code2);
    }
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteCallLabelMarker");
    return ok2(code2);
  }
}
function resolveToPotentialGfmFootnoteCall(events, context) {
  let index2 = events.length;
  let labelStart;
  while (index2--) {
    if (events[index2][1].type === "labelImage" && events[index2][0] === "enter") {
      labelStart = events[index2][1];
      break;
    }
  }
  events[index2 + 1][1].type = "data";
  events[index2 + 3][1].type = "gfmFootnoteCallLabelMarker";
  const call = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, events[index2 + 3][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const marker = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, events[index2 + 3][1].end),
    end: Object.assign({}, events[index2 + 3][1].end)
  };
  marker.end.column++;
  marker.end.offset++;
  marker.end._bufferIndex++;
  const string3 = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, marker.end),
    end: Object.assign({}, events[events.length - 1][1].start)
  };
  const chunk = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, string3.start),
    end: Object.assign({}, string3.end)
  };
  const replacement = [
    events[index2 + 1],
    events[index2 + 2],
    ["enter", call, context],
    events[index2 + 3],
    events[index2 + 4],
    ["enter", marker, context],
    ["exit", marker, context],
    ["enter", string3, context],
    ["enter", chunk, context],
    ["exit", chunk, context],
    ["exit", string3, context],
    events[events.length - 2],
    events[events.length - 1],
    ["exit", call, context]
  ];
  events.splice(index2, events.length - index2 + 1, ...replacement);
  return events;
}
function tokenizeGfmFootnoteCall(effects, ok2, nok) {
  const self = this;
  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);
  let size2 = 0;
  let data;
  return start;
  function start(code2) {
    effects.enter("gfmFootnoteCall");
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteCallLabelMarker");
    return callStart;
  }
  function callStart(code2) {
    if (code2 !== 94)
      return nok(code2);
    effects.enter("gfmFootnoteCallMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteCallMarker");
    effects.enter("gfmFootnoteCallString");
    effects.enter("chunkString").contentType = "string";
    return callData;
  }
  function callData(code2) {
    if (size2 > 999 || code2 === 93 && !data || code2 === null || code2 === 91 || markdownLineEndingOrSpace(code2)) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.exit("chunkString");
      const token = effects.exit("gfmFootnoteCallString");
      if (!defined.includes(normalizeIdentifier(self.sliceSerialize(token)))) {
        return nok(code2);
      }
      effects.enter("gfmFootnoteCallLabelMarker");
      effects.consume(code2);
      effects.exit("gfmFootnoteCallLabelMarker");
      effects.exit("gfmFootnoteCall");
      return ok2;
    }
    if (!markdownLineEndingOrSpace(code2)) {
      data = true;
    }
    size2++;
    effects.consume(code2);
    return code2 === 92 ? callEscape : callData;
  }
  function callEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size2++;
      return callData;
    }
    return callData(code2);
  }
}
function tokenizeDefinitionStart(effects, ok2, nok) {
  const self = this;
  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);
  let identifier;
  let size2 = 0;
  let data;
  return start;
  function start(code2) {
    effects.enter("gfmFootnoteDefinition")._container = true;
    effects.enter("gfmFootnoteDefinitionLabel");
    effects.enter("gfmFootnoteDefinitionLabelMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteDefinitionLabelMarker");
    return labelAtMarker;
  }
  function labelAtMarker(code2) {
    if (code2 === 94) {
      effects.enter("gfmFootnoteDefinitionMarker");
      effects.consume(code2);
      effects.exit("gfmFootnoteDefinitionMarker");
      effects.enter("gfmFootnoteDefinitionLabelString");
      effects.enter("chunkString").contentType = "string";
      return labelInside;
    }
    return nok(code2);
  }
  function labelInside(code2) {
    if (size2 > 999 || code2 === 93 && !data || code2 === null || code2 === 91 || markdownLineEndingOrSpace(code2)) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.exit("chunkString");
      const token = effects.exit("gfmFootnoteDefinitionLabelString");
      identifier = normalizeIdentifier(self.sliceSerialize(token));
      effects.enter("gfmFootnoteDefinitionLabelMarker");
      effects.consume(code2);
      effects.exit("gfmFootnoteDefinitionLabelMarker");
      effects.exit("gfmFootnoteDefinitionLabel");
      return labelAfter;
    }
    if (!markdownLineEndingOrSpace(code2)) {
      data = true;
    }
    size2++;
    effects.consume(code2);
    return code2 === 92 ? labelEscape : labelInside;
  }
  function labelEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size2++;
      return labelInside;
    }
    return labelInside(code2);
  }
  function labelAfter(code2) {
    if (code2 === 58) {
      effects.enter("definitionMarker");
      effects.consume(code2);
      effects.exit("definitionMarker");
      if (!defined.includes(identifier)) {
        defined.push(identifier);
      }
      return factorySpace(effects, whitespaceAfter, "gfmFootnoteDefinitionWhitespace");
    }
    return nok(code2);
  }
  function whitespaceAfter(code2) {
    return ok2(code2);
  }
}
function tokenizeDefinitionContinuation(effects, ok2, nok) {
  return effects.check(blankLine, ok2, effects.attempt(indent, ok2, nok));
}
function gfmFootnoteDefinitionEnd(effects) {
  effects.exit("gfmFootnoteDefinition");
}
function tokenizeIndent2(effects, ok2, nok) {
  const self = this;
  return factorySpace(effects, afterPrefix, "gfmFootnoteDefinitionIndent", 4 + 1);
  function afterPrefix(code2) {
    const tail = self.events[self.events.length - 1];
    return tail && tail[1].type === "gfmFootnoteDefinitionIndent" && tail[2].sliceSerialize(tail[1], true).length === 4 ? ok2(code2) : nok(code2);
  }
}

// node_modules/.pnpm/micromark-extension-gfm-strikethrough@1.0.7/node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js
function gfmStrikethrough(options) {
  const options_ = options || {};
  let single = options_.singleTilde;
  const tokenizer = {
    tokenize: tokenizeStrikethrough,
    resolveAll: resolveAllStrikethrough
  };
  if (single === null || single === void 0) {
    single = true;
  }
  return {
    text: {
      [126]: tokenizer
    },
    insideSpan: {
      null: [tokenizer]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function resolveAllStrikethrough(events, context) {
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][0] === "enter" && events[index2][1].type === "strikethroughSequenceTemporary" && events[index2][1]._close) {
        let open = index2;
        while (open--) {
          if (events[open][0] === "exit" && events[open][1].type === "strikethroughSequenceTemporary" && events[open][1]._open && events[index2][1].end.offset - events[index2][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {
            events[index2][1].type = "strikethroughSequence";
            events[open][1].type = "strikethroughSequence";
            const strikethrough = {
              type: "strikethrough",
              start: Object.assign({}, events[open][1].start),
              end: Object.assign({}, events[index2][1].end)
            };
            const text4 = {
              type: "strikethroughText",
              start: Object.assign({}, events[open][1].end),
              end: Object.assign({}, events[index2][1].start)
            };
            const nextEvents = [
              ["enter", strikethrough, context],
              ["enter", events[open][1], context],
              ["exit", events[open][1], context],
              ["enter", text4, context]
            ];
            const insideSpan2 = context.parser.constructs.insideSpan.null;
            if (insideSpan2) {
              splice(nextEvents, nextEvents.length, 0, resolveAll(insideSpan2, events.slice(open + 1, index2), context));
            }
            splice(nextEvents, nextEvents.length, 0, [
              ["exit", text4, context],
              ["enter", events[index2][1], context],
              ["exit", events[index2][1], context],
              ["exit", strikethrough, context]
            ]);
            splice(events, open - 1, index2 - open + 3, nextEvents);
            index2 = open + nextEvents.length - 2;
            break;
          }
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "strikethroughSequenceTemporary") {
        events[index2][1].type = "data";
      }
    }
    return events;
  }
  function tokenizeStrikethrough(effects, ok2, nok) {
    const previous5 = this.previous;
    const events = this.events;
    let size2 = 0;
    return start;
    function start(code2) {
      if (previous5 === 126 && events[events.length - 1][1].type !== "characterEscape") {
        return nok(code2);
      }
      effects.enter("strikethroughSequenceTemporary");
      return more(code2);
    }
    function more(code2) {
      const before = classifyCharacter(previous5);
      if (code2 === 126) {
        if (size2 > 1)
          return nok(code2);
        effects.consume(code2);
        size2++;
        return more;
      }
      if (size2 < 2 && !single)
        return nok(code2);
      const token = effects.exit("strikethroughSequenceTemporary");
      const after = classifyCharacter(code2);
      token._open = !after || after === 2 && Boolean(before);
      token._close = !before || before === 2 && Boolean(after);
      return ok2(code2);
    }
  }
}

// node_modules/.pnpm/micromark-extension-gfm-table@1.0.7/node_modules/micromark-extension-gfm-table/lib/edit-map.js
var EditMap = class {
  constructor() {
    this.map = [];
  }
  add(index2, remove, add) {
    addImpl(this, index2, remove, add);
  }
  consume(events) {
    this.map.sort((a, b) => a[0] - b[0]);
    if (this.map.length === 0) {
      return;
    }
    let index2 = this.map.length;
    const vecs = [];
    while (index2 > 0) {
      index2 -= 1;
      vecs.push(events.slice(this.map[index2][0] + this.map[index2][1]));
      vecs.push(this.map[index2][2]);
      events.length = this.map[index2][0];
    }
    vecs.push([...events]);
    events.length = 0;
    let slice = vecs.pop();
    while (slice) {
      events.push(...slice);
      slice = vecs.pop();
    }
    this.map.length = 0;
  }
};
function addImpl(editMap, at, remove, add) {
  let index2 = 0;
  if (remove === 0 && add.length === 0) {
    return;
  }
  while (index2 < editMap.map.length) {
    if (editMap.map[index2][0] === at) {
      editMap.map[index2][1] += remove;
      editMap.map[index2][2].push(...add);
      return;
    }
    index2 += 1;
  }
  editMap.map.push([at, remove, add]);
}

// node_modules/.pnpm/micromark-extension-gfm-table@1.0.7/node_modules/micromark-extension-gfm-table/lib/infer.js
function gfmTableAlign(events, index2) {
  let inDelimiterRow = false;
  const align = [];
  while (index2 < events.length) {
    const event = events[index2];
    if (inDelimiterRow) {
      if (event[0] === "enter") {
        if (event[1].type === "tableContent") {
          align.push(events[index2 + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
        }
      } else if (event[1].type === "tableContent") {
        if (events[index2 - 1][1].type === "tableDelimiterMarker") {
          const alignIndex = align.length - 1;
          align[alignIndex] = align[alignIndex] === "left" ? "center" : "right";
        }
      } else if (event[1].type === "tableDelimiterRow") {
        break;
      }
    } else if (event[0] === "enter" && event[1].type === "tableDelimiterRow") {
      inDelimiterRow = true;
    }
    index2 += 1;
  }
  return align;
}

// node_modules/.pnpm/micromark-extension-gfm-table@1.0.7/node_modules/micromark-extension-gfm-table/lib/syntax.js
var gfmTable = {
  flow: {
    null: {
      tokenize: tokenizeTable,
      resolveAll: resolveTable
    }
  }
};
function tokenizeTable(effects, ok2, nok) {
  const self = this;
  let size2 = 0;
  let sizeB = 0;
  let seen;
  return start;
  function start(code2) {
    let index2 = self.events.length - 1;
    while (index2 > -1) {
      const type = self.events[index2][1].type;
      if (type === "lineEnding" || type === "linePrefix")
        index2--;
      else
        break;
    }
    const tail = index2 > -1 ? self.events[index2][1].type : null;
    const next = tail === "tableHead" || tail === "tableRow" ? bodyRowStart : headRowBefore;
    if (next === bodyRowStart && self.parser.lazy[self.now().line]) {
      return nok(code2);
    }
    return next(code2);
  }
  function headRowBefore(code2) {
    effects.enter("tableHead");
    effects.enter("tableRow");
    return headRowStart(code2);
  }
  function headRowStart(code2) {
    if (code2 === 124) {
      return headRowBreak(code2);
    }
    seen = true;
    sizeB += 1;
    return headRowBreak(code2);
  }
  function headRowBreak(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      if (sizeB > 1) {
        sizeB = 0;
        self.interrupt = true;
        effects.exit("tableRow");
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return headDelimiterStart;
      }
      return nok(code2);
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, headRowBreak, "whitespace")(code2);
    }
    sizeB += 1;
    if (seen) {
      seen = false;
      size2 += 1;
    }
    if (code2 === 124) {
      effects.enter("tableCellDivider");
      effects.consume(code2);
      effects.exit("tableCellDivider");
      seen = true;
      return headRowBreak;
    }
    effects.enter("data");
    return headRowData(code2);
  }
  function headRowData(code2) {
    if (code2 === null || code2 === 124 || markdownLineEndingOrSpace(code2)) {
      effects.exit("data");
      return headRowBreak(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? headRowEscape : headRowData;
  }
  function headRowEscape(code2) {
    if (code2 === 92 || code2 === 124) {
      effects.consume(code2);
      return headRowData;
    }
    return headRowData(code2);
  }
  function headDelimiterStart(code2) {
    self.interrupt = false;
    if (self.parser.lazy[self.now().line]) {
      return nok(code2);
    }
    effects.enter("tableDelimiterRow");
    seen = false;
    if (markdownSpace(code2)) {
      return factorySpace(effects, headDelimiterBefore, "linePrefix", self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2);
    }
    return headDelimiterBefore(code2);
  }
  function headDelimiterBefore(code2) {
    if (code2 === 45 || code2 === 58) {
      return headDelimiterValueBefore(code2);
    }
    if (code2 === 124) {
      seen = true;
      effects.enter("tableCellDivider");
      effects.consume(code2);
      effects.exit("tableCellDivider");
      return headDelimiterCellBefore;
    }
    return headDelimiterNok(code2);
  }
  function headDelimiterCellBefore(code2) {
    if (markdownSpace(code2)) {
      return factorySpace(effects, headDelimiterValueBefore, "whitespace")(code2);
    }
    return headDelimiterValueBefore(code2);
  }
  function headDelimiterValueBefore(code2) {
    if (code2 === 58) {
      sizeB += 1;
      seen = true;
      effects.enter("tableDelimiterMarker");
      effects.consume(code2);
      effects.exit("tableDelimiterMarker");
      return headDelimiterLeftAlignmentAfter;
    }
    if (code2 === 45) {
      sizeB += 1;
      return headDelimiterLeftAlignmentAfter(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      return headDelimiterCellAfter(code2);
    }
    return headDelimiterNok(code2);
  }
  function headDelimiterLeftAlignmentAfter(code2) {
    if (code2 === 45) {
      effects.enter("tableDelimiterFiller");
      return headDelimiterFiller(code2);
    }
    return headDelimiterNok(code2);
  }
  function headDelimiterFiller(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return headDelimiterFiller;
    }
    if (code2 === 58) {
      seen = true;
      effects.exit("tableDelimiterFiller");
      effects.enter("tableDelimiterMarker");
      effects.consume(code2);
      effects.exit("tableDelimiterMarker");
      return headDelimiterRightAlignmentAfter;
    }
    effects.exit("tableDelimiterFiller");
    return headDelimiterRightAlignmentAfter(code2);
  }
  function headDelimiterRightAlignmentAfter(code2) {
    if (markdownSpace(code2)) {
      return factorySpace(effects, headDelimiterCellAfter, "whitespace")(code2);
    }
    return headDelimiterCellAfter(code2);
  }
  function headDelimiterCellAfter(code2) {
    if (code2 === 124) {
      return headDelimiterBefore(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      if (!seen || size2 !== sizeB) {
        return headDelimiterNok(code2);
      }
      effects.exit("tableDelimiterRow");
      effects.exit("tableHead");
      return ok2(code2);
    }
    return headDelimiterNok(code2);
  }
  function headDelimiterNok(code2) {
    return nok(code2);
  }
  function bodyRowStart(code2) {
    effects.enter("tableRow");
    return bodyRowBreak(code2);
  }
  function bodyRowBreak(code2) {
    if (code2 === 124) {
      effects.enter("tableCellDivider");
      effects.consume(code2);
      effects.exit("tableCellDivider");
      return bodyRowBreak;
    }
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("tableRow");
      return ok2(code2);
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, bodyRowBreak, "whitespace")(code2);
    }
    effects.enter("data");
    return bodyRowData(code2);
  }
  function bodyRowData(code2) {
    if (code2 === null || code2 === 124 || markdownLineEndingOrSpace(code2)) {
      effects.exit("data");
      return bodyRowBreak(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? bodyRowEscape : bodyRowData;
  }
  function bodyRowEscape(code2) {
    if (code2 === 92 || code2 === 124) {
      effects.consume(code2);
      return bodyRowData;
    }
    return bodyRowData(code2);
  }
}
function resolveTable(events, context) {
  let index2 = -1;
  let inFirstCellAwaitingPipe = true;
  let rowKind = 0;
  let lastCell = [0, 0, 0, 0];
  let cell = [0, 0, 0, 0];
  let afterHeadAwaitingFirstBodyRow = false;
  let lastTableEnd = 0;
  let currentTable;
  let currentBody;
  let currentCell;
  const map2 = new EditMap();
  while (++index2 < events.length) {
    const event = events[index2];
    const token = event[1];
    if (event[0] === "enter") {
      if (token.type === "tableHead") {
        afterHeadAwaitingFirstBodyRow = false;
        if (lastTableEnd !== 0) {
          flushTableEnd(map2, context, lastTableEnd, currentTable, currentBody);
          currentBody = void 0;
          lastTableEnd = 0;
        }
        currentTable = {
          type: "table",
          start: Object.assign({}, token.start),
          end: Object.assign({}, token.end)
        };
        map2.add(index2, 0, [["enter", currentTable, context]]);
      } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
        inFirstCellAwaitingPipe = true;
        currentCell = void 0;
        lastCell = [0, 0, 0, 0];
        cell = [0, index2 + 1, 0, 0];
        if (afterHeadAwaitingFirstBodyRow) {
          afterHeadAwaitingFirstBodyRow = false;
          currentBody = {
            type: "tableBody",
            start: Object.assign({}, token.start),
            end: Object.assign({}, token.end)
          };
          map2.add(index2, 0, [["enter", currentBody, context]]);
        }
        rowKind = token.type === "tableDelimiterRow" ? 2 : currentBody ? 3 : 1;
      } else if (rowKind && (token.type === "data" || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
        inFirstCellAwaitingPipe = false;
        if (cell[2] === 0) {
          if (lastCell[1] !== 0) {
            cell[0] = cell[1];
            currentCell = flushCell(map2, context, lastCell, rowKind, void 0, currentCell);
            lastCell = [0, 0, 0, 0];
          }
          cell[2] = index2;
        }
      } else if (token.type === "tableCellDivider") {
        if (inFirstCellAwaitingPipe) {
          inFirstCellAwaitingPipe = false;
        } else {
          if (lastCell[1] !== 0) {
            cell[0] = cell[1];
            currentCell = flushCell(map2, context, lastCell, rowKind, void 0, currentCell);
          }
          lastCell = cell;
          cell = [lastCell[1], index2, 0, 0];
        }
      }
    } else if (token.type === "tableHead") {
      afterHeadAwaitingFirstBodyRow = true;
      lastTableEnd = index2;
    } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
      lastTableEnd = index2;
      if (lastCell[1] !== 0) {
        cell[0] = cell[1];
        currentCell = flushCell(map2, context, lastCell, rowKind, index2, currentCell);
      } else if (cell[1] !== 0) {
        currentCell = flushCell(map2, context, cell, rowKind, index2, currentCell);
      }
      rowKind = 0;
    } else if (rowKind && (token.type === "data" || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
      cell[3] = index2;
    }
  }
  if (lastTableEnd !== 0) {
    flushTableEnd(map2, context, lastTableEnd, currentTable, currentBody);
  }
  map2.consume(context.events);
  index2 = -1;
  while (++index2 < context.events.length) {
    const event = context.events[index2];
    if (event[0] === "enter" && event[1].type === "table") {
      event[1]._align = gfmTableAlign(context.events, index2);
    }
  }
  return events;
}
function flushCell(map2, context, range, rowKind, rowEnd, previousCell) {
  const groupName = rowKind === 1 ? "tableHeader" : rowKind === 2 ? "tableDelimiter" : "tableData";
  const valueName = "tableContent";
  if (range[0] !== 0) {
    previousCell.end = Object.assign({}, getPoint(context.events, range[0]));
    map2.add(range[0], 0, [["exit", previousCell, context]]);
  }
  const now = getPoint(context.events, range[1]);
  previousCell = {
    type: groupName,
    start: Object.assign({}, now),
    end: Object.assign({}, now)
  };
  map2.add(range[1], 0, [["enter", previousCell, context]]);
  if (range[2] !== 0) {
    const relatedStart = getPoint(context.events, range[2]);
    const relatedEnd = getPoint(context.events, range[3]);
    const valueToken = {
      type: valueName,
      start: Object.assign({}, relatedStart),
      end: Object.assign({}, relatedEnd)
    };
    map2.add(range[2], 0, [["enter", valueToken, context]]);
    if (rowKind !== 2) {
      const start = context.events[range[2]];
      const end = context.events[range[3]];
      start[1].end = Object.assign({}, end[1].end);
      start[1].type = "chunkText";
      start[1].contentType = "text";
      if (range[3] > range[2] + 1) {
        const a = range[2] + 1;
        const b = range[3] - range[2] - 1;
        map2.add(a, b, []);
      }
    }
    map2.add(range[3] + 1, 0, [["exit", valueToken, context]]);
  }
  if (rowEnd !== void 0) {
    previousCell.end = Object.assign({}, getPoint(context.events, rowEnd));
    map2.add(rowEnd, 0, [["exit", previousCell, context]]);
    previousCell = void 0;
  }
  return previousCell;
}
function flushTableEnd(map2, context, index2, table, tableBody) {
  const exits = [];
  const related = getPoint(context.events, index2);
  if (tableBody) {
    tableBody.end = Object.assign({}, related);
    exits.push(["exit", tableBody, context]);
  }
  table.end = Object.assign({}, related);
  exits.push(["exit", table, context]);
  map2.add(index2 + 1, 0, exits);
}
function getPoint(events, index2) {
  const event = events[index2];
  const side = event[0] === "enter" ? "start" : "end";
  return event[1][side];
}

// node_modules/.pnpm/micromark-extension-gfm-task-list-item@1.0.5/node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js
var tasklistCheck = {
  tokenize: tokenizeTasklistCheck
};
var gfmTaskListItem = {
  text: {
    [91]: tasklistCheck
  }
};
function tokenizeTasklistCheck(effects, ok2, nok) {
  const self = this;
  return open;
  function open(code2) {
    if (self.previous !== null || !self._gfmTasklistFirstContentOfListItem) {
      return nok(code2);
    }
    effects.enter("taskListCheck");
    effects.enter("taskListCheckMarker");
    effects.consume(code2);
    effects.exit("taskListCheckMarker");
    return inside;
  }
  function inside(code2) {
    if (markdownLineEndingOrSpace(code2)) {
      effects.enter("taskListCheckValueUnchecked");
      effects.consume(code2);
      effects.exit("taskListCheckValueUnchecked");
      return close2;
    }
    if (code2 === 88 || code2 === 120) {
      effects.enter("taskListCheckValueChecked");
      effects.consume(code2);
      effects.exit("taskListCheckValueChecked");
      return close2;
    }
    return nok(code2);
  }
  function close2(code2) {
    if (code2 === 93) {
      effects.enter("taskListCheckMarker");
      effects.consume(code2);
      effects.exit("taskListCheckMarker");
      effects.exit("taskListCheck");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    if (markdownLineEnding(code2)) {
      return ok2(code2);
    }
    if (markdownSpace(code2)) {
      return effects.check({
        tokenize: spaceThenNonSpace
      }, ok2, nok)(code2);
    }
    return nok(code2);
  }
}
function spaceThenNonSpace(effects, ok2, nok) {
  return factorySpace(effects, after, "whitespace");
  function after(code2) {
    return code2 === null ? nok(code2) : ok2(code2);
  }
}

// node_modules/.pnpm/micromark-extension-gfm@2.0.3/node_modules/micromark-extension-gfm/index.js
function gfm(options) {
  return combineExtensions([
    gfmAutolinkLiteral,
    gfmFootnote(),
    gfmStrikethrough(options),
    gfmTable,
    gfmTaskListItem
  ]);
}

// node_modules/.pnpm/ccount@2.0.1/node_modules/ccount/index.js
function ccount(value2, character) {
  const source = String(value2);
  if (typeof character !== "string") {
    throw new TypeError("Expected character");
  }
  let count = 0;
  let index2 = source.indexOf(character);
  while (index2 !== -1) {
    count++;
    index2 = source.indexOf(character, index2 + character.length);
  }
  return count;
}

// node_modules/.pnpm/escape-string-regexp@5.0.0/node_modules/escape-string-regexp/index.js
function escapeStringRegexp(string3) {
  if (typeof string3 !== "string") {
    throw new TypeError("Expected a string");
  }
  return string3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}

// node_modules/.pnpm/unist-util-is@5.2.1/node_modules/unist-util-is/lib/index.js
var is = function is2(node2, test, index2, parent, context) {
  const check2 = convert(test);
  if (index2 !== void 0 && index2 !== null && (typeof index2 !== "number" || index2 < 0 || index2 === Number.POSITIVE_INFINITY)) {
    throw new Error("Expected positive finite index");
  }
  if (parent !== void 0 && parent !== null && (!is2(parent) || !parent.children)) {
    throw new Error("Expected parent node");
  }
  if ((parent === void 0 || parent === null) !== (index2 === void 0 || index2 === null)) {
    throw new Error("Expected both parent and index");
  }
  return node2 && node2.type && typeof node2.type === "string" ? Boolean(check2.call(context, node2, index2, parent)) : false;
};
var convert = function(test) {
  if (test === void 0 || test === null) {
    return ok;
  }
  if (typeof test === "string") {
    return typeFactory(test);
  }
  if (typeof test === "object") {
    return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
  }
  if (typeof test === "function") {
    return castFactory(test);
  }
  throw new Error("Expected function, string, or object as test");
};
function anyFactory(tests) {
  const checks = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks[index2] = convert(tests[index2]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks.length) {
      if (checks[index3].call(this, ...parameters))
        return true;
    }
    return false;
  }
}
function propsFactory(check2) {
  return castFactory(all2);
  function all2(node2) {
    let key;
    for (key in check2) {
      if (node2[key] !== check2[key])
        return false;
    }
    return true;
  }
}
function typeFactory(check2) {
  return castFactory(type);
  function type(node2) {
    return node2 && node2.type === check2;
  }
}
function castFactory(check2) {
  return assertion;
  function assertion(node2, ...parameters) {
    return Boolean(node2 && typeof node2 === "object" && "type" in node2 && Boolean(check2.call(this, node2, ...parameters)));
  }
}
function ok() {
  return true;
}

// node_modules/.pnpm/unist-util-visit-parents@5.1.3/node_modules/unist-util-visit-parents/lib/color.browser.js
function color(d) {
  return d;
}

// node_modules/.pnpm/unist-util-visit-parents@5.1.3/node_modules/unist-util-visit-parents/lib/index.js
var CONTINUE = true;
var EXIT = false;
var SKIP = "skip";
var visitParents = function(tree, test, visitor, reverse) {
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
    test = null;
  }
  const is3 = convert(test);
  const step = reverse ? -1 : 1;
  factory(tree, void 0, [])();
  function factory(node2, index2, parents) {
    const value2 = node2 && typeof node2 === "object" ? node2 : {};
    if (typeof value2.type === "string") {
      const name = typeof value2.tagName === "string" ? value2.tagName : typeof value2.name === "string" ? value2.name : void 0;
      Object.defineProperty(visit2, "name", {
        value: "node (" + color(node2.type + (name ? "<" + name + ">" : "")) + ")"
      });
    }
    return visit2;
    function visit2() {
      let result = [];
      let subresult;
      let offset;
      let grandparents;
      if (!test || is3(node2, index2, parents[parents.length - 1] || null)) {
        result = toResult(visitor(node2, parents));
        if (result[0] === EXIT) {
          return result;
        }
      }
      if (node2.children && result[0] !== SKIP) {
        offset = (reverse ? node2.children.length : -1) + step;
        grandparents = parents.concat(node2);
        while (offset > -1 && offset < node2.children.length) {
          subresult = factory(node2.children[offset], offset, grandparents)();
          if (subresult[0] === EXIT) {
            return subresult;
          }
          offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
        }
      }
      return result;
    }
  }
};
function toResult(value2) {
  if (Array.isArray(value2)) {
    return value2;
  }
  if (typeof value2 === "number") {
    return [CONTINUE, value2];
  }
  return [value2];
}

// node_modules/.pnpm/mdast-util-find-and-replace@2.2.2/node_modules/mdast-util-find-and-replace/lib/index.js
var own3 = {}.hasOwnProperty;
var findAndReplace = function(tree, find, replace2, options) {
  let settings;
  let schema;
  if (typeof find === "string" || find instanceof RegExp) {
    schema = [[find, replace2]];
    settings = options;
  } else {
    schema = find;
    settings = replace2;
  }
  if (!settings) {
    settings = {};
  }
  const ignored = convert(settings.ignore || []);
  const pairs = toPairs(schema);
  let pairIndex = -1;
  while (++pairIndex < pairs.length) {
    visitParents(tree, "text", visitor);
  }
  return tree;
  function visitor(node2, parents) {
    let index2 = -1;
    let grandparent;
    while (++index2 < parents.length) {
      const parent = parents[index2];
      if (ignored(parent, grandparent ? grandparent.children.indexOf(parent) : void 0, grandparent)) {
        return;
      }
      grandparent = parent;
    }
    if (grandparent) {
      return handler2(node2, parents);
    }
  }
  function handler2(node2, parents) {
    const parent = parents[parents.length - 1];
    const find2 = pairs[pairIndex][0];
    const replace3 = pairs[pairIndex][1];
    let start = 0;
    const index2 = parent.children.indexOf(node2);
    let change = false;
    let nodes = [];
    find2.lastIndex = 0;
    let match = find2.exec(node2.value);
    while (match) {
      const position2 = match.index;
      const matchObject = {
        index: match.index,
        input: match.input,
        stack: [...parents, node2]
      };
      let value2 = replace3(...match, matchObject);
      if (typeof value2 === "string") {
        value2 = value2.length > 0 ? { type: "text", value: value2 } : void 0;
      }
      if (value2 !== false) {
        if (start !== position2) {
          nodes.push({
            type: "text",
            value: node2.value.slice(start, position2)
          });
        }
        if (Array.isArray(value2)) {
          nodes.push(...value2);
        } else if (value2) {
          nodes.push(value2);
        }
        start = position2 + match[0].length;
        change = true;
      }
      if (!find2.global) {
        break;
      }
      match = find2.exec(node2.value);
    }
    if (change) {
      if (start < node2.value.length) {
        nodes.push({ type: "text", value: node2.value.slice(start) });
      }
      parent.children.splice(index2, 1, ...nodes);
    } else {
      nodes = [node2];
    }
    return index2 + nodes.length;
  }
};
function toPairs(schema) {
  const result = [];
  if (typeof schema !== "object") {
    throw new TypeError("Expected array or object as schema");
  }
  if (Array.isArray(schema)) {
    let index2 = -1;
    while (++index2 < schema.length) {
      result.push([
        toExpression(schema[index2][0]),
        toFunction(schema[index2][1])
      ]);
    }
  } else {
    let key;
    for (key in schema) {
      if (own3.call(schema, key)) {
        result.push([toExpression(key), toFunction(schema[key])]);
      }
    }
  }
  return result;
}
function toExpression(find) {
  return typeof find === "string" ? new RegExp(escapeStringRegexp(find), "g") : find;
}
function toFunction(replace2) {
  return typeof replace2 === "function" ? replace2 : () => replace2;
}

// node_modules/.pnpm/mdast-util-gfm-autolink-literal@1.0.3/node_modules/mdast-util-gfm-autolink-literal/lib/index.js
var inConstruct = "phrasing";
var notInConstruct = ["autolink", "link", "image", "label"];
var gfmAutolinkLiteralFromMarkdown = {
  transforms: [transformGfmAutolinkLiterals],
  enter: {
    literalAutolink: enterLiteralAutolink,
    literalAutolinkEmail: enterLiteralAutolinkValue,
    literalAutolinkHttp: enterLiteralAutolinkValue,
    literalAutolinkWww: enterLiteralAutolinkValue
  },
  exit: {
    literalAutolink: exitLiteralAutolink,
    literalAutolinkEmail: exitLiteralAutolinkEmail,
    literalAutolinkHttp: exitLiteralAutolinkHttp,
    literalAutolinkWww: exitLiteralAutolinkWww
  }
};
var gfmAutolinkLiteralToMarkdown = {
  unsafe: [
    {
      character: "@",
      before: "[+\\-.\\w]",
      after: "[\\-.\\w]",
      inConstruct,
      notInConstruct
    },
    {
      character: ".",
      before: "[Ww]",
      after: "[\\-.\\w]",
      inConstruct,
      notInConstruct
    },
    { character: ":", before: "[ps]", after: "\\/", inConstruct, notInConstruct }
  ]
};
function enterLiteralAutolink(token) {
  this.enter({ type: "link", title: null, url: "", children: [] }, token);
}
function enterLiteralAutolinkValue(token) {
  this.config.enter.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkHttp(token) {
  this.config.exit.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkWww(token) {
  this.config.exit.data.call(this, token);
  const node2 = this.stack[this.stack.length - 1];
  node2.url = "http://" + this.sliceSerialize(token);
}
function exitLiteralAutolinkEmail(token) {
  this.config.exit.autolinkEmail.call(this, token);
}
function exitLiteralAutolink(token) {
  this.exit(token);
}
function transformGfmAutolinkLiterals(tree) {
  findAndReplace(tree, [
    [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
    [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, findEmail]
  ], { ignore: ["link", "linkReference"] });
}
function findUrl(_, protocol, domain2, path3, match) {
  let prefix = "";
  if (!previous3(match)) {
    return false;
  }
  if (/^w/i.test(protocol)) {
    domain2 = protocol + domain2;
    protocol = "";
    prefix = "http://";
  }
  if (!isCorrectDomain(domain2)) {
    return false;
  }
  const parts = splitUrl(domain2 + path3);
  if (!parts[0])
    return false;
  const result = {
    type: "link",
    title: null,
    url: prefix + protocol + parts[0],
    children: [{ type: "text", value: protocol + parts[0] }]
  };
  if (parts[1]) {
    return [result, { type: "text", value: parts[1] }];
  }
  return result;
}
function findEmail(_, atext, label4, match) {
  if (!previous3(match, true) || /[-\d_]$/.test(label4)) {
    return false;
  }
  return {
    type: "link",
    title: null,
    url: "mailto:" + atext + "@" + label4,
    children: [{ type: "text", value: atext + "@" + label4 }]
  };
}
function isCorrectDomain(domain2) {
  const parts = domain2.split(".");
  if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
    return false;
  }
  return true;
}
function splitUrl(url) {
  const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);
  if (!trailExec) {
    return [url, void 0];
  }
  url = url.slice(0, trailExec.index);
  let trail2 = trailExec[0];
  let closingParenIndex = trail2.indexOf(")");
  const openingParens = ccount(url, "(");
  let closingParens = ccount(url, ")");
  while (closingParenIndex !== -1 && openingParens > closingParens) {
    url += trail2.slice(0, closingParenIndex + 1);
    trail2 = trail2.slice(closingParenIndex + 1);
    closingParenIndex = trail2.indexOf(")");
    closingParens++;
  }
  return [url, trail2];
}
function previous3(match, email) {
  const code2 = match.input.charCodeAt(match.index - 1);
  return (match.index === 0 || unicodeWhitespace(code2) || unicodePunctuation(code2)) && (!email || code2 !== 47);
}

// node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/association.js
function association(node2) {
  if (node2.label || !node2.identifier) {
    return node2.label || "";
  }
  return decodeString(node2.identifier);
}

// node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/container-flow.js
function containerFlow(parent, state, info) {
  const indexStack = state.indexStack;
  const children = parent.children || [];
  const tracker = state.createTracker(info);
  const results = [];
  let index2 = -1;
  indexStack.push(-1);
  while (++index2 < children.length) {
    const child = children[index2];
    indexStack[indexStack.length - 1] = index2;
    results.push(tracker.move(state.handle(child, parent, state, __spreadValues({
      before: "\n",
      after: "\n"
    }, tracker.current()))));
    if (child.type !== "list") {
      state.bulletLastUsed = void 0;
    }
    if (index2 < children.length - 1) {
      results.push(tracker.move(between(child, children[index2 + 1], parent, state)));
    }
  }
  indexStack.pop();
  return results.join("");
}
function between(left, right, parent, state) {
  let index2 = state.join.length;
  while (index2--) {
    const result = state.join[index2](left, right, parent, state);
    if (result === true || result === 1) {
      break;
    }
    if (typeof result === "number") {
      return "\n".repeat(1 + result);
    }
    if (result === false) {
      return "\n\n<!---->\n\n";
    }
  }
  return "\n\n";
}

// node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/indent-lines.js
var eol = /\r?\n|\r/g;
function indentLines(value2, map2) {
  const result = [];
  let start = 0;
  let line = 0;
  let match;
  while (match = eol.exec(value2)) {
    one2(value2.slice(start, match.index));
    result.push(match[0]);
    start = match.index + match[0].length;
    line++;
  }
  one2(value2.slice(start));
  return result.join("");
  function one2(value3) {
    result.push(map2(value3, line, !value3));
  }
}

// node_modules/.pnpm/mdast-util-gfm-footnote@1.0.2/node_modules/mdast-util-gfm-footnote/lib/index.js
footnoteReference.peek = footnoteReferencePeek;
function gfmFootnoteFromMarkdown() {
  return {
    enter: {
      gfmFootnoteDefinition: enterFootnoteDefinition,
      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
      gfmFootnoteCall: enterFootnoteCall,
      gfmFootnoteCallString: enterFootnoteCallString
    },
    exit: {
      gfmFootnoteDefinition: exitFootnoteDefinition,
      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
      gfmFootnoteCall: exitFootnoteCall,
      gfmFootnoteCallString: exitFootnoteCallString
    }
  };
}
function gfmFootnoteToMarkdown() {
  return {
    unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
    handlers: { footnoteDefinition, footnoteReference }
  };
}
function enterFootnoteDefinition(token) {
  this.enter({ type: "footnoteDefinition", identifier: "", label: "", children: [] }, token);
}
function enterFootnoteDefinitionLabelString() {
  this.buffer();
}
function exitFootnoteDefinitionLabelString(token) {
  const label4 = this.resume();
  const node2 = this.stack[this.stack.length - 1];
  node2.label = label4;
  node2.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
}
function exitFootnoteDefinition(token) {
  this.exit(token);
}
function enterFootnoteCall(token) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, token);
}
function enterFootnoteCallString() {
  this.buffer();
}
function exitFootnoteCallString(token) {
  const label4 = this.resume();
  const node2 = this.stack[this.stack.length - 1];
  node2.label = label4;
  node2.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
}
function exitFootnoteCall(token) {
  this.exit(token);
}
function footnoteReference(node2, _, context, safeOptions) {
  const tracker = track(safeOptions);
  let value2 = tracker.move("[^");
  const exit4 = context.enter("footnoteReference");
  const subexit = context.enter("reference");
  value2 += tracker.move(safe(context, association(node2), __spreadProps(__spreadValues({}, tracker.current()), {
    before: value2,
    after: "]"
  })));
  subexit();
  exit4();
  value2 += tracker.move("]");
  return value2;
}
function footnoteReferencePeek() {
  return "[";
}
function footnoteDefinition(node2, _, context, safeOptions) {
  const tracker = track(safeOptions);
  let value2 = tracker.move("[^");
  const exit4 = context.enter("footnoteDefinition");
  const subexit = context.enter("label");
  value2 += tracker.move(safe(context, association(node2), __spreadProps(__spreadValues({}, tracker.current()), {
    before: value2,
    after: "]"
  })));
  subexit();
  value2 += tracker.move("]:" + (node2.children && node2.children.length > 0 ? " " : ""));
  tracker.shift(4);
  value2 += tracker.move(indentLines(containerFlow(node2, context, tracker.current()), map));
  exit4();
  return value2;
}
function map(line, index2, blank) {
  if (index2 === 0) {
    return line;
  }
  return (blank ? "" : "    ") + line;
}

// node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js
function containerPhrasing(parent, state, info) {
  const indexStack = state.indexStack;
  const children = parent.children || [];
  const results = [];
  let index2 = -1;
  let before = info.before;
  indexStack.push(-1);
  let tracker = state.createTracker(info);
  while (++index2 < children.length) {
    const child = children[index2];
    let after;
    indexStack[indexStack.length - 1] = index2;
    if (index2 + 1 < children.length) {
      let handle = state.handle.handlers[children[index2 + 1].type];
      if (handle && handle.peek)
        handle = handle.peek;
      after = handle ? handle(children[index2 + 1], parent, state, __spreadValues({
        before: "",
        after: ""
      }, tracker.current())).charAt(0) : "";
    } else {
      after = info.after;
    }
    if (results.length > 0 && (before === "\r" || before === "\n") && child.type === "html") {
      results[results.length - 1] = results[results.length - 1].replace(/(\r?\n|\r)$/, " ");
      before = " ";
      tracker = state.createTracker(info);
      tracker.move(results.join(""));
    }
    results.push(tracker.move(state.handle(child, parent, state, __spreadProps(__spreadValues({}, tracker.current()), {
      before,
      after
    }))));
    before = results[results.length - 1].slice(-1);
  }
  indexStack.pop();
  return results.join("");
}

// node_modules/.pnpm/mdast-util-gfm-strikethrough@1.0.3/node_modules/mdast-util-gfm-strikethrough/lib/index.js
var constructsWithoutStrikethrough = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
handleDelete.peek = peekDelete;
var gfmStrikethroughFromMarkdown = {
  canContainEols: ["delete"],
  enter: { strikethrough: enterStrikethrough },
  exit: { strikethrough: exitStrikethrough }
};
var gfmStrikethroughToMarkdown = {
  unsafe: [
    {
      character: "~",
      inConstruct: "phrasing",
      notInConstruct: constructsWithoutStrikethrough
    }
  ],
  handlers: { delete: handleDelete }
};
function enterStrikethrough(token) {
  this.enter({ type: "delete", children: [] }, token);
}
function exitStrikethrough(token) {
  this.exit(token);
}
function handleDelete(node2, _, context, safeOptions) {
  const tracker = track(safeOptions);
  const exit4 = context.enter("strikethrough");
  let value2 = tracker.move("~~");
  value2 += containerPhrasing(node2, context, __spreadProps(__spreadValues({}, tracker.current()), {
    before: value2,
    after: "~"
  }));
  value2 += tracker.move("~~");
  exit4();
  return value2;
}
function peekDelete() {
  return "~";
}

// node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/handle/inline-code.js
inlineCode.peek = inlineCodePeek;
function inlineCode(node2, _, state) {
  let value2 = node2.value || "";
  let sequence = "`";
  let index2 = -1;
  while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value2)) {
    sequence += "`";
  }
  if (/[^ \r\n]/.test(value2) && (/^[ \r\n]/.test(value2) && /[ \r\n]$/.test(value2) || /^`|`$/.test(value2))) {
    value2 = " " + value2 + " ";
  }
  while (++index2 < state.unsafe.length) {
    const pattern = state.unsafe[index2];
    const expression = patternCompile(pattern);
    let match;
    if (!pattern.atBreak)
      continue;
    while (match = expression.exec(value2)) {
      let position2 = match.index;
      if (value2.charCodeAt(position2) === 10 && value2.charCodeAt(position2 - 1) === 13) {
        position2--;
      }
      value2 = value2.slice(0, position2) + " " + value2.slice(match.index + 1);
    }
  }
  return sequence + value2 + sequence;
}
function inlineCodePeek() {
  return "`";
}

// node_modules/.pnpm/markdown-table@3.0.4/node_modules/markdown-table/index.js
function defaultStringLength(value2) {
  return value2.length;
}
function markdownTable(table, options) {
  const settings = options || {};
  const align = (settings.align || []).concat();
  const stringLength = settings.stringLength || defaultStringLength;
  const alignments = [];
  const cellMatrix = [];
  const sizeMatrix = [];
  const longestCellByColumn = [];
  let mostCellsPerRow = 0;
  let rowIndex = -1;
  while (++rowIndex < table.length) {
    const row2 = [];
    const sizes2 = [];
    let columnIndex2 = -1;
    if (table[rowIndex].length > mostCellsPerRow) {
      mostCellsPerRow = table[rowIndex].length;
    }
    while (++columnIndex2 < table[rowIndex].length) {
      const cell = serialize(table[rowIndex][columnIndex2]);
      if (settings.alignDelimiters !== false) {
        const size2 = stringLength(cell);
        sizes2[columnIndex2] = size2;
        if (longestCellByColumn[columnIndex2] === void 0 || size2 > longestCellByColumn[columnIndex2]) {
          longestCellByColumn[columnIndex2] = size2;
        }
      }
      row2.push(cell);
    }
    cellMatrix[rowIndex] = row2;
    sizeMatrix[rowIndex] = sizes2;
  }
  let columnIndex = -1;
  if (typeof align === "object" && "length" in align) {
    while (++columnIndex < mostCellsPerRow) {
      alignments[columnIndex] = toAlignment(align[columnIndex]);
    }
  } else {
    const code2 = toAlignment(align);
    while (++columnIndex < mostCellsPerRow) {
      alignments[columnIndex] = code2;
    }
  }
  columnIndex = -1;
  const row = [];
  const sizes = [];
  while (++columnIndex < mostCellsPerRow) {
    const code2 = alignments[columnIndex];
    let before = "";
    let after = "";
    if (code2 === 99) {
      before = ":";
      after = ":";
    } else if (code2 === 108) {
      before = ":";
    } else if (code2 === 114) {
      after = ":";
    }
    let size2 = settings.alignDelimiters === false ? 1 : Math.max(1, longestCellByColumn[columnIndex] - before.length - after.length);
    const cell = before + "-".repeat(size2) + after;
    if (settings.alignDelimiters !== false) {
      size2 = before.length + size2 + after.length;
      if (size2 > longestCellByColumn[columnIndex]) {
        longestCellByColumn[columnIndex] = size2;
      }
      sizes[columnIndex] = size2;
    }
    row[columnIndex] = cell;
  }
  cellMatrix.splice(1, 0, row);
  sizeMatrix.splice(1, 0, sizes);
  rowIndex = -1;
  const lines = [];
  while (++rowIndex < cellMatrix.length) {
    const row2 = cellMatrix[rowIndex];
    const sizes2 = sizeMatrix[rowIndex];
    columnIndex = -1;
    const line = [];
    while (++columnIndex < mostCellsPerRow) {
      const cell = row2[columnIndex] || "";
      let before = "";
      let after = "";
      if (settings.alignDelimiters !== false) {
        const size2 = longestCellByColumn[columnIndex] - (sizes2[columnIndex] || 0);
        const code2 = alignments[columnIndex];
        if (code2 === 114) {
          before = " ".repeat(size2);
        } else if (code2 === 99) {
          if (size2 % 2) {
            before = " ".repeat(size2 / 2 + 0.5);
            after = " ".repeat(size2 / 2 - 0.5);
          } else {
            before = " ".repeat(size2 / 2);
            after = before;
          }
        } else {
          after = " ".repeat(size2);
        }
      }
      if (settings.delimiterStart !== false && !columnIndex) {
        line.push("|");
      }
      if (settings.padding !== false && !(settings.alignDelimiters === false && cell === "") && (settings.delimiterStart !== false || columnIndex)) {
        line.push(" ");
      }
      if (settings.alignDelimiters !== false) {
        line.push(before);
      }
      line.push(cell);
      if (settings.alignDelimiters !== false) {
        line.push(after);
      }
      if (settings.padding !== false) {
        line.push(" ");
      }
      if (settings.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {
        line.push("|");
      }
    }
    lines.push(settings.delimiterEnd === false ? line.join("").replace(/ +$/, "") : line.join(""));
  }
  return lines.join("\n");
}
function serialize(value2) {
  return value2 === null || value2 === void 0 ? "" : String(value2);
}
function toAlignment(value2) {
  const code2 = typeof value2 === "string" ? value2.codePointAt(0) : 0;
  return code2 === 67 || code2 === 99 ? 99 : code2 === 76 || code2 === 108 ? 108 : code2 === 82 || code2 === 114 ? 114 : 0;
}

// node_modules/.pnpm/mdast-util-gfm-table@1.0.7/node_modules/mdast-util-gfm-table/lib/index.js
var gfmTableFromMarkdown = {
  enter: {
    table: enterTable,
    tableData: enterCell,
    tableHeader: enterCell,
    tableRow: enterRow
  },
  exit: {
    codeText: exitCodeText,
    table: exitTable,
    tableData: exit2,
    tableHeader: exit2,
    tableRow: exit2
  }
};
function enterTable(token) {
  const align = token._align;
  this.enter({
    type: "table",
    align: align.map((d) => d === "none" ? null : d),
    children: []
  }, token);
  this.setData("inTable", true);
}
function exitTable(token) {
  this.exit(token);
  this.setData("inTable");
}
function enterRow(token) {
  this.enter({ type: "tableRow", children: [] }, token);
}
function exit2(token) {
  this.exit(token);
}
function enterCell(token) {
  this.enter({ type: "tableCell", children: [] }, token);
}
function exitCodeText(token) {
  let value2 = this.resume();
  if (this.getData("inTable")) {
    value2 = value2.replace(/\\([\\|])/g, replace);
  }
  const node2 = this.stack[this.stack.length - 1];
  node2.value = value2;
  this.exit(token);
}
function replace($0, $1) {
  return $1 === "|" ? $1 : $0;
}
function gfmTableToMarkdown(options) {
  const settings = options || {};
  const padding = settings.tableCellPadding;
  const alignDelimiters = settings.tablePipeAlign;
  const stringLength = settings.stringLength;
  const around = padding ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: "\n", inConstruct: "tableCell" },
      { atBreak: true, character: "|", after: "[	 :-]" },
      { character: "|", inConstruct: "tableCell" },
      { atBreak: true, character: ":", after: "-" },
      { atBreak: true, character: "-", after: "[:|-]" }
    ],
    handlers: {
      table: handleTable,
      tableRow: handleTableRow,
      tableCell: handleTableCell,
      inlineCode: inlineCodeWithTable
    }
  };
  function handleTable(node2, _, context, safeOptions) {
    return serializeData(handleTableAsData(node2, context, safeOptions), node2.align);
  }
  function handleTableRow(node2, _, context, safeOptions) {
    const row = handleTableRowAsData(node2, context, safeOptions);
    const value2 = serializeData([row]);
    return value2.slice(0, value2.indexOf("\n"));
  }
  function handleTableCell(node2, _, context, safeOptions) {
    const exit4 = context.enter("tableCell");
    const subexit = context.enter("phrasing");
    const value2 = containerPhrasing(node2, context, __spreadProps(__spreadValues({}, safeOptions), {
      before: around,
      after: around
    }));
    subexit();
    exit4();
    return value2;
  }
  function serializeData(matrix, align) {
    return markdownTable(matrix, {
      align,
      alignDelimiters,
      padding,
      stringLength
    });
  }
  function handleTableAsData(node2, context, safeOptions) {
    const children = node2.children;
    let index2 = -1;
    const result = [];
    const subexit = context.enter("table");
    while (++index2 < children.length) {
      result[index2] = handleTableRowAsData(children[index2], context, safeOptions);
    }
    subexit();
    return result;
  }
  function handleTableRowAsData(node2, context, safeOptions) {
    const children = node2.children;
    let index2 = -1;
    const result = [];
    const subexit = context.enter("tableRow");
    while (++index2 < children.length) {
      result[index2] = handleTableCell(children[index2], node2, context, safeOptions);
    }
    subexit();
    return result;
  }
  function inlineCodeWithTable(node2, parent, context) {
    let value2 = inlineCode(node2, parent, context);
    if (context.stack.includes("tableCell")) {
      value2 = value2.replace(/\|/g, "\\$&");
    }
    return value2;
  }
}

// node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/check-bullet.js
function checkBullet(state) {
  const marker = state.options.bullet || "*";
  if (marker !== "*" && marker !== "+" && marker !== "-") {
    throw new Error("Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`");
  }
  return marker;
}

// node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js
function checkListItemIndent(state) {
  const style = state.options.listItemIndent || "tab";
  if (style === 1 || style === "1") {
    return "one";
  }
  if (style !== "tab" && style !== "one" && style !== "mixed") {
    throw new Error("Cannot serialize items with `" + style + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`");
  }
  return style;
}

// node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/handle/list-item.js
function listItem(node2, parent, state, info) {
  const listItemIndent = checkListItemIndent(state);
  let bullet = state.bulletCurrent || checkBullet(state);
  if (parent && parent.type === "list" && parent.ordered) {
    bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node2)) + bullet;
  }
  let size2 = bullet.length + 1;
  if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node2.spread)) {
    size2 = Math.ceil(size2 / 4) * 4;
  }
  const tracker = state.createTracker(info);
  tracker.move(bullet + " ".repeat(size2 - bullet.length));
  tracker.shift(size2);
  const exit4 = state.enter("listItem");
  const value2 = state.indentLines(state.containerFlow(node2, tracker.current()), map2);
  exit4();
  return value2;
  function map2(line, index2, blank) {
    if (index2) {
      return (blank ? "" : " ".repeat(size2)) + line;
    }
    return (blank ? bullet : bullet + " ".repeat(size2 - bullet.length)) + line;
  }
}

// node_modules/.pnpm/mdast-util-gfm-task-list-item@1.0.2/node_modules/mdast-util-gfm-task-list-item/lib/index.js
var gfmTaskListItemFromMarkdown = {
  exit: {
    taskListCheckValueChecked: exitCheck,
    taskListCheckValueUnchecked: exitCheck,
    paragraph: exitParagraphWithTaskListItem
  }
};
var gfmTaskListItemToMarkdown = {
  unsafe: [{ atBreak: true, character: "-", after: "[:|-]" }],
  handlers: { listItem: listItemWithTaskListItem }
};
function exitCheck(token) {
  const node2 = this.stack[this.stack.length - 2];
  node2.checked = token.type === "taskListCheckValueChecked";
}
function exitParagraphWithTaskListItem(token) {
  const parent = this.stack[this.stack.length - 2];
  if (parent && parent.type === "listItem" && typeof parent.checked === "boolean") {
    const node2 = this.stack[this.stack.length - 1];
    const head = node2.children[0];
    if (head && head.type === "text") {
      const siblings = parent.children;
      let index2 = -1;
      let firstParaghraph;
      while (++index2 < siblings.length) {
        const sibling = siblings[index2];
        if (sibling.type === "paragraph") {
          firstParaghraph = sibling;
          break;
        }
      }
      if (firstParaghraph === node2) {
        head.value = head.value.slice(1);
        if (head.value.length === 0) {
          node2.children.shift();
        } else if (node2.position && head.position && typeof head.position.start.offset === "number") {
          head.position.start.column++;
          head.position.start.offset++;
          node2.position.start = Object.assign({}, head.position.start);
        }
      }
    }
  }
  this.exit(token);
}
function listItemWithTaskListItem(node2, parent, context, safeOptions) {
  const head = node2.children[0];
  const checkable = typeof node2.checked === "boolean" && head && head.type === "paragraph";
  const checkbox = "[" + (node2.checked ? "x" : " ") + "] ";
  const tracker = track(safeOptions);
  if (checkable) {
    tracker.move(checkbox);
  }
  let value2 = listItem(node2, parent, context, __spreadValues(__spreadValues({}, safeOptions), tracker.current()));
  if (checkable) {
    value2 = value2.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check2);
  }
  return value2;
  function check2($0) {
    return $0 + checkbox;
  }
}

// node_modules/.pnpm/mdast-util-gfm@2.0.2/node_modules/mdast-util-gfm/lib/index.js
function gfmFromMarkdown() {
  return [
    gfmAutolinkLiteralFromMarkdown,
    gfmFootnoteFromMarkdown(),
    gfmStrikethroughFromMarkdown,
    gfmTableFromMarkdown,
    gfmTaskListItemFromMarkdown
  ];
}
function gfmToMarkdown(options) {
  return {
    extensions: [
      gfmAutolinkLiteralToMarkdown,
      gfmFootnoteToMarkdown(),
      gfmStrikethroughToMarkdown,
      gfmTableToMarkdown(options),
      gfmTaskListItemToMarkdown
    ]
  };
}

// node_modules/.pnpm/remark-gfm@3.0.1/node_modules/remark-gfm/index.js
function remarkGfm(options = {}) {
  const data = this.data();
  add("micromarkExtensions", gfm(options));
  add("fromMarkdownExtensions", gfmFromMarkdown());
  add("toMarkdownExtensions", gfmToMarkdown(options));
  function add(field, value2) {
    const list2 = data[field] ? data[field] : data[field] = [];
    list2.push(value2);
  }
}

// node_modules/.pnpm/micromark-extension-directive@2.2.1/node_modules/micromark-extension-directive/lib/factory-attributes.js
function factoryAttributes(effects, ok2, nok, attributesType, attributesMarkerType, attributeType, attributeIdType, attributeClassType, attributeNameType, attributeInitializerType, attributeValueLiteralType, attributeValueType, attributeValueMarker, attributeValueData, disallowEol) {
  let type;
  let marker;
  return start;
  function start(code2) {
    effects.enter(attributesType);
    effects.enter(attributesMarkerType);
    effects.consume(code2);
    effects.exit(attributesMarkerType);
    return between2;
  }
  function between2(code2) {
    if (code2 === 35) {
      type = attributeIdType;
      return shortcutStart(code2);
    }
    if (code2 === 46) {
      type = attributeClassType;
      return shortcutStart(code2);
    }
    if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
      effects.enter(attributeType);
      effects.enter(attributeNameType);
      effects.consume(code2);
      return name;
    }
    if (disallowEol && markdownSpace(code2)) {
      return factorySpace(effects, between2, "whitespace")(code2);
    }
    if (!disallowEol && markdownLineEndingOrSpace(code2)) {
      return factoryWhitespace(effects, between2)(code2);
    }
    return end(code2);
  }
  function shortcutStart(code2) {
    const markerType = type + "Marker";
    effects.enter(attributeType);
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code2);
    effects.exit(markerType);
    return shortcutStartAfter;
  }
  function shortcutStartAfter(code2) {
    if (code2 === null || code2 === 34 || code2 === 35 || code2 === 39 || code2 === 46 || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96 || code2 === 125 || markdownLineEndingOrSpace(code2)) {
      return nok(code2);
    }
    const valueType = type + "Value";
    effects.enter(valueType);
    effects.consume(code2);
    return shortcut2;
  }
  function shortcut2(code2) {
    if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 35 || code2 === 46 || code2 === 125 || markdownLineEndingOrSpace(code2)) {
      const valueType = type + "Value";
      effects.exit(valueType);
      effects.exit(type);
      effects.exit(attributeType);
      return between2(code2);
    }
    effects.consume(code2);
    return shortcut2;
  }
  function name(code2) {
    if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return name;
    }
    effects.exit(attributeNameType);
    if (disallowEol && markdownSpace(code2)) {
      return factorySpace(effects, nameAfter, "whitespace")(code2);
    }
    if (!disallowEol && markdownLineEndingOrSpace(code2)) {
      return factoryWhitespace(effects, nameAfter)(code2);
    }
    return nameAfter(code2);
  }
  function nameAfter(code2) {
    if (code2 === 61) {
      effects.enter(attributeInitializerType);
      effects.consume(code2);
      effects.exit(attributeInitializerType);
      return valueBefore;
    }
    effects.exit(attributeType);
    return between2(code2);
  }
  function valueBefore(code2) {
    if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96 || code2 === 125 || disallowEol && markdownLineEnding(code2)) {
      return nok(code2);
    }
    if (code2 === 34 || code2 === 39) {
      effects.enter(attributeValueLiteralType);
      effects.enter(attributeValueMarker);
      effects.consume(code2);
      effects.exit(attributeValueMarker);
      marker = code2;
      return valueQuotedStart;
    }
    if (disallowEol && markdownSpace(code2)) {
      return factorySpace(effects, valueBefore, "whitespace")(code2);
    }
    if (!disallowEol && markdownLineEndingOrSpace(code2)) {
      return factoryWhitespace(effects, valueBefore)(code2);
    }
    effects.enter(attributeValueType);
    effects.enter(attributeValueData);
    effects.consume(code2);
    marker = void 0;
    return valueUnquoted;
  }
  function valueUnquoted(code2) {
    if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 125 || markdownLineEndingOrSpace(code2)) {
      effects.exit(attributeValueData);
      effects.exit(attributeValueType);
      effects.exit(attributeType);
      return between2(code2);
    }
    effects.consume(code2);
    return valueUnquoted;
  }
  function valueQuotedStart(code2) {
    if (code2 === marker) {
      effects.enter(attributeValueMarker);
      effects.consume(code2);
      effects.exit(attributeValueMarker);
      effects.exit(attributeValueLiteralType);
      effects.exit(attributeType);
      return valueQuotedAfter;
    }
    effects.enter(attributeValueType);
    return valueQuotedBetween(code2);
  }
  function valueQuotedBetween(code2) {
    if (code2 === marker) {
      effects.exit(attributeValueType);
      return valueQuotedStart(code2);
    }
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      return disallowEol ? nok(code2) : factoryWhitespace(effects, valueQuotedBetween)(code2);
    }
    effects.enter(attributeValueData);
    effects.consume(code2);
    return valueQuoted;
  }
  function valueQuoted(code2) {
    if (code2 === marker || code2 === null || markdownLineEnding(code2)) {
      effects.exit(attributeValueData);
      return valueQuotedBetween(code2);
    }
    effects.consume(code2);
    return valueQuoted;
  }
  function valueQuotedAfter(code2) {
    return code2 === 125 || markdownLineEndingOrSpace(code2) ? between2(code2) : end(code2);
  }
  function end(code2) {
    if (code2 === 125) {
      effects.enter(attributesMarkerType);
      effects.consume(code2);
      effects.exit(attributesMarkerType);
      effects.exit(attributesType);
      return ok2;
    }
    return nok(code2);
  }
}

// node_modules/.pnpm/micromark-extension-directive@2.2.1/node_modules/micromark-extension-directive/lib/factory-label.js
function factoryLabel2(effects, ok2, nok, type, markerType, stringType, disallowEol) {
  let size2 = 0;
  let balance = 0;
  let previous5;
  return start;
  function start(code2) {
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code2);
    effects.exit(markerType);
    return afterStart;
  }
  function afterStart(code2) {
    if (code2 === 93) {
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type);
      return ok2;
    }
    effects.enter(stringType);
    return lineStart(code2);
  }
  function lineStart(code2) {
    if (code2 === 93 && !balance) {
      return atClosingBrace(code2);
    }
    const token = effects.enter("chunkText", {
      contentType: "text",
      previous: previous5
    });
    if (previous5)
      previous5.next = token;
    previous5 = token;
    return data(code2);
  }
  function data(code2) {
    if (code2 === null || size2 > 999) {
      return nok(code2);
    }
    if (code2 === 91 && ++balance > 32) {
      return nok(code2);
    }
    if (code2 === 93 && !balance--) {
      effects.exit("chunkText");
      return atClosingBrace(code2);
    }
    if (markdownLineEnding(code2)) {
      if (disallowEol) {
        return nok(code2);
      }
      effects.consume(code2);
      effects.exit("chunkText");
      return lineStart;
    }
    effects.consume(code2);
    return code2 === 92 ? dataEscape : data;
  }
  function dataEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size2++;
      return data;
    }
    return data(code2);
  }
  function atClosingBrace(code2) {
    effects.exit(stringType);
    effects.enter(markerType);
    effects.consume(code2);
    effects.exit(markerType);
    effects.exit(type);
    return ok2;
  }
}

// node_modules/.pnpm/micromark-extension-directive@2.2.1/node_modules/micromark-extension-directive/lib/factory-name.js
function factoryName(effects, ok2, nok, type) {
  const self = this;
  return start;
  function start(code2) {
    if (asciiAlpha(code2)) {
      effects.enter(type);
      effects.consume(code2);
      return name;
    }
    return nok(code2);
  }
  function name(code2) {
    if (code2 === 45 || code2 === 95 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return name;
    }
    effects.exit(type);
    return self.previous === 45 || self.previous === 95 ? nok(code2) : ok2(code2);
  }
}

// node_modules/.pnpm/micromark-extension-directive@2.2.1/node_modules/micromark-extension-directive/lib/directive-container.js
var directiveContainer = {
  tokenize: tokenizeDirectiveContainer,
  concrete: true
};
var label = {
  tokenize: tokenizeLabel,
  partial: true
};
var attributes = {
  tokenize: tokenizeAttributes,
  partial: true
};
var nonLazyLine = {
  tokenize: tokenizeNonLazyLine,
  partial: true
};
function tokenizeDirectiveContainer(effects, ok2, nok) {
  const self = this;
  const tail = self.events[self.events.length - 1];
  const initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let sizeOpen = 0;
  let previous5;
  return start;
  function start(code2) {
    effects.enter("directiveContainer");
    effects.enter("directiveContainerFence");
    effects.enter("directiveContainerSequence");
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === 58) {
      effects.consume(code2);
      sizeOpen++;
      return sequenceOpen;
    }
    if (sizeOpen < 3) {
      return nok(code2);
    }
    effects.exit("directiveContainerSequence");
    return factoryName.call(self, effects, afterName, nok, "directiveContainerName")(code2);
  }
  function afterName(code2) {
    return code2 === 91 ? effects.attempt(label, afterLabel, afterLabel)(code2) : afterLabel(code2);
  }
  function afterLabel(code2) {
    return code2 === 123 ? effects.attempt(attributes, afterAttributes, afterAttributes)(code2) : afterAttributes(code2);
  }
  function afterAttributes(code2) {
    return factorySpace(effects, openAfter, "whitespace")(code2);
  }
  function openAfter(code2) {
    effects.exit("directiveContainerFence");
    if (code2 === null) {
      return afterOpening(code2);
    }
    if (markdownLineEnding(code2)) {
      if (self.interrupt) {
        return ok2(code2);
      }
      return effects.attempt(nonLazyLine, contentStart, afterOpening)(code2);
    }
    return nok(code2);
  }
  function afterOpening(code2) {
    effects.exit("directiveContainer");
    return ok2(code2);
  }
  function contentStart(code2) {
    if (code2 === null) {
      effects.exit("directiveContainer");
      return ok2(code2);
    }
    effects.enter("directiveContainerContent");
    return lineStart(code2);
  }
  function lineStart(code2) {
    if (code2 === null) {
      return after(code2);
    }
    return effects.attempt({
      tokenize: tokenizeClosingFence,
      partial: true
    }, after, initialSize ? factorySpace(effects, chunkStart, "linePrefix", initialSize + 1) : chunkStart)(code2);
  }
  function chunkStart(code2) {
    if (code2 === null) {
      return after(code2);
    }
    const token = effects.enter("chunkDocument", {
      contentType: "document",
      previous: previous5
    });
    if (previous5)
      previous5.next = token;
    previous5 = token;
    return contentContinue(code2);
  }
  function contentContinue(code2) {
    if (code2 === null) {
      const t2 = effects.exit("chunkDocument");
      self.parser.lazy[t2.start.line] = false;
      return after(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.check(nonLazyLine, nonLazyLineAfter, lineAfter)(code2);
    }
    effects.consume(code2);
    return contentContinue;
  }
  function nonLazyLineAfter(code2) {
    effects.consume(code2);
    const t2 = effects.exit("chunkDocument");
    self.parser.lazy[t2.start.line] = false;
    return lineStart;
  }
  function lineAfter(code2) {
    const t2 = effects.exit("chunkDocument");
    self.parser.lazy[t2.start.line] = false;
    return after(code2);
  }
  function after(code2) {
    effects.exit("directiveContainerContent");
    effects.exit("directiveContainer");
    return ok2(code2);
  }
  function tokenizeClosingFence(effects2, ok3, nok2) {
    let size2 = 0;
    return factorySpace(effects2, closingPrefixAfter, "linePrefix", 4);
    function closingPrefixAfter(code2) {
      effects2.enter("directiveContainerFence");
      effects2.enter("directiveContainerSequence");
      return closingSequence(code2);
    }
    function closingSequence(code2) {
      if (code2 === 58) {
        effects2.consume(code2);
        size2++;
        return closingSequence;
      }
      if (size2 < sizeOpen)
        return nok2(code2);
      effects2.exit("directiveContainerSequence");
      return factorySpace(effects2, closingSequenceEnd, "whitespace")(code2);
    }
    function closingSequenceEnd(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects2.exit("directiveContainerFence");
        return ok3(code2);
      }
      return nok2(code2);
    }
  }
}
function tokenizeLabel(effects, ok2, nok) {
  return factoryLabel2(effects, ok2, nok, "directiveContainerLabel", "directiveContainerLabelMarker", "directiveContainerLabelString", true);
}
function tokenizeAttributes(effects, ok2, nok) {
  return factoryAttributes(effects, ok2, nok, "directiveContainerAttributes", "directiveContainerAttributesMarker", "directiveContainerAttribute", "directiveContainerAttributeId", "directiveContainerAttributeClass", "directiveContainerAttributeName", "directiveContainerAttributeInitializerMarker", "directiveContainerAttributeValueLiteral", "directiveContainerAttributeValue", "directiveContainerAttributeValueMarker", "directiveContainerAttributeValueData", true);
}
function tokenizeNonLazyLine(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return lineStart;
  }
  function lineStart(code2) {
    return self.parser.lazy[self.now().line] ? nok(code2) : ok2(code2);
  }
}

// node_modules/.pnpm/micromark-extension-directive@2.2.1/node_modules/micromark-extension-directive/lib/directive-leaf.js
var directiveLeaf = {
  tokenize: tokenizeDirectiveLeaf
};
var label2 = {
  tokenize: tokenizeLabel2,
  partial: true
};
var attributes2 = {
  tokenize: tokenizeAttributes2,
  partial: true
};
function tokenizeDirectiveLeaf(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    effects.enter("directiveLeaf");
    effects.enter("directiveLeafSequence");
    effects.consume(code2);
    return inStart;
  }
  function inStart(code2) {
    if (code2 === 58) {
      effects.consume(code2);
      effects.exit("directiveLeafSequence");
      return factoryName.call(self, effects, afterName, nok, "directiveLeafName");
    }
    return nok(code2);
  }
  function afterName(code2) {
    return code2 === 91 ? effects.attempt(label2, afterLabel, afterLabel)(code2) : afterLabel(code2);
  }
  function afterLabel(code2) {
    return code2 === 123 ? effects.attempt(attributes2, afterAttributes, afterAttributes)(code2) : afterAttributes(code2);
  }
  function afterAttributes(code2) {
    return factorySpace(effects, end, "whitespace")(code2);
  }
  function end(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("directiveLeaf");
      return ok2(code2);
    }
    return nok(code2);
  }
}
function tokenizeLabel2(effects, ok2, nok) {
  return factoryLabel2(effects, ok2, nok, "directiveLeafLabel", "directiveLeafLabelMarker", "directiveLeafLabelString", true);
}
function tokenizeAttributes2(effects, ok2, nok) {
  return factoryAttributes(effects, ok2, nok, "directiveLeafAttributes", "directiveLeafAttributesMarker", "directiveLeafAttribute", "directiveLeafAttributeId", "directiveLeafAttributeClass", "directiveLeafAttributeName", "directiveLeafAttributeInitializerMarker", "directiveLeafAttributeValueLiteral", "directiveLeafAttributeValue", "directiveLeafAttributeValueMarker", "directiveLeafAttributeValueData", true);
}

// node_modules/.pnpm/micromark-extension-directive@2.2.1/node_modules/micromark-extension-directive/lib/directive-text.js
var directiveText = {
  tokenize: tokenizeDirectiveText,
  previous: previous4
};
var label3 = {
  tokenize: tokenizeLabel3,
  partial: true
};
var attributes3 = {
  tokenize: tokenizeAttributes3,
  partial: true
};
function previous4(code2) {
  return code2 !== 58 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function tokenizeDirectiveText(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    effects.enter("directiveText");
    effects.enter("directiveTextMarker");
    effects.consume(code2);
    effects.exit("directiveTextMarker");
    return factoryName.call(self, effects, afterName, nok, "directiveTextName");
  }
  function afterName(code2) {
    return code2 === 58 ? nok(code2) : code2 === 91 ? effects.attempt(label3, afterLabel, afterLabel)(code2) : afterLabel(code2);
  }
  function afterLabel(code2) {
    return code2 === 123 ? effects.attempt(attributes3, afterAttributes, afterAttributes)(code2) : afterAttributes(code2);
  }
  function afterAttributes(code2) {
    effects.exit("directiveText");
    return ok2(code2);
  }
}
function tokenizeLabel3(effects, ok2, nok) {
  return factoryLabel2(effects, ok2, nok, "directiveTextLabel", "directiveTextLabelMarker", "directiveTextLabelString");
}
function tokenizeAttributes3(effects, ok2, nok) {
  return factoryAttributes(effects, ok2, nok, "directiveTextAttributes", "directiveTextAttributesMarker", "directiveTextAttribute", "directiveTextAttributeId", "directiveTextAttributeClass", "directiveTextAttributeName", "directiveTextAttributeInitializerMarker", "directiveTextAttributeValueLiteral", "directiveTextAttributeValue", "directiveTextAttributeValueMarker", "directiveTextAttributeValueData");
}

// node_modules/.pnpm/micromark-extension-directive@2.2.1/node_modules/micromark-extension-directive/lib/syntax.js
function directive() {
  return {
    text: {
      [58]: directiveText
    },
    flow: {
      [58]: [directiveContainer, directiveLeaf]
    }
  };
}

// node_modules/.pnpm/character-entities-legacy@3.0.0/node_modules/character-entities-legacy/index.js
var characterEntitiesLegacy = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
];

// node_modules/.pnpm/character-reference-invalid@2.0.1/node_modules/character-reference-invalid/index.js
var characterReferenceInvalid = {
  0: "\uFFFD",
  128: "\u20AC",
  130: "\u201A",
  131: "\u0192",
  132: "\u201E",
  133: "\u2026",
  134: "\u2020",
  135: "\u2021",
  136: "\u02C6",
  137: "\u2030",
  138: "\u0160",
  139: "\u2039",
  140: "\u0152",
  142: "\u017D",
  145: "\u2018",
  146: "\u2019",
  147: "\u201C",
  148: "\u201D",
  149: "\u2022",
  150: "\u2013",
  151: "\u2014",
  152: "\u02DC",
  153: "\u2122",
  154: "\u0161",
  155: "\u203A",
  156: "\u0153",
  158: "\u017E",
  159: "\u0178"
};

// node_modules/.pnpm/is-decimal@2.0.1/node_modules/is-decimal/index.js
function isDecimal(character) {
  const code2 = typeof character === "string" ? character.charCodeAt(0) : character;
  return code2 >= 48 && code2 <= 57;
}

// node_modules/.pnpm/is-hexadecimal@2.0.1/node_modules/is-hexadecimal/index.js
function isHexadecimal(character) {
  const code2 = typeof character === "string" ? character.charCodeAt(0) : character;
  return code2 >= 97 && code2 <= 102 || code2 >= 65 && code2 <= 70 || code2 >= 48 && code2 <= 57;
}

// node_modules/.pnpm/is-alphabetical@2.0.1/node_modules/is-alphabetical/index.js
function isAlphabetical(character) {
  const code2 = typeof character === "string" ? character.charCodeAt(0) : character;
  return code2 >= 97 && code2 <= 122 || code2 >= 65 && code2 <= 90;
}

// node_modules/.pnpm/is-alphanumerical@2.0.1/node_modules/is-alphanumerical/index.js
function isAlphanumerical(character) {
  return isAlphabetical(character) || isDecimal(character);
}

// node_modules/.pnpm/parse-entities@4.0.2/node_modules/parse-entities/lib/index.js
var messages = [
  "",
  "Named character references must be terminated by a semicolon",
  "Numeric character references must be terminated by a semicolon",
  "Named character references cannot be empty",
  "Numeric character references cannot be empty",
  "Named character references must be known",
  "Numeric character references cannot be disallowed",
  "Numeric character references cannot be outside the permissible Unicode range"
];
function parseEntities(value2, options) {
  const settings = options || {};
  const additional = typeof settings.additional === "string" ? settings.additional.charCodeAt(0) : settings.additional;
  const result = [];
  let index2 = 0;
  let lines = -1;
  let queue = "";
  let point3;
  let indent3;
  if (settings.position) {
    if ("start" in settings.position || "indent" in settings.position) {
      indent3 = settings.position.indent;
      point3 = settings.position.start;
    } else {
      point3 = settings.position;
    }
  }
  let line = (point3 ? point3.line : 0) || 1;
  let column = (point3 ? point3.column : 0) || 1;
  let previous5 = now();
  let character;
  index2--;
  while (++index2 <= value2.length) {
    if (character === 10) {
      column = (indent3 ? indent3[lines] : 0) || 1;
    }
    character = value2.charCodeAt(index2);
    if (character === 38) {
      const following = value2.charCodeAt(index2 + 1);
      if (following === 9 || following === 10 || following === 12 || following === 32 || following === 38 || following === 60 || Number.isNaN(following) || additional && following === additional) {
        queue += String.fromCharCode(character);
        column++;
        continue;
      }
      const start = index2 + 1;
      let begin = start;
      let end = start;
      let type;
      if (following === 35) {
        end = ++begin;
        const following2 = value2.charCodeAt(end);
        if (following2 === 88 || following2 === 120) {
          type = "hexadecimal";
          end = ++begin;
        } else {
          type = "decimal";
        }
      } else {
        type = "named";
      }
      let characterReferenceCharacters = "";
      let characterReference2 = "";
      let characters = "";
      const test = type === "named" ? isAlphanumerical : type === "decimal" ? isDecimal : isHexadecimal;
      end--;
      while (++end <= value2.length) {
        const following2 = value2.charCodeAt(end);
        if (!test(following2)) {
          break;
        }
        characters += String.fromCharCode(following2);
        if (type === "named" && characterEntitiesLegacy.includes(characters)) {
          characterReferenceCharacters = characters;
          characterReference2 = decodeNamedCharacterReference(characters);
        }
      }
      let terminated = value2.charCodeAt(end) === 59;
      if (terminated) {
        end++;
        const namedReference = type === "named" ? decodeNamedCharacterReference(characters) : false;
        if (namedReference) {
          characterReferenceCharacters = characters;
          characterReference2 = namedReference;
        }
      }
      let diff = 1 + end - start;
      let reference = "";
      if (!terminated && settings.nonTerminated === false) {
      } else if (!characters) {
        if (type !== "named") {
          warning(4, diff);
        }
      } else if (type === "named") {
        if (terminated && !characterReference2) {
          warning(5, 1);
        } else {
          if (characterReferenceCharacters !== characters) {
            end = begin + characterReferenceCharacters.length;
            diff = 1 + end - begin;
            terminated = false;
          }
          if (!terminated) {
            const reason = characterReferenceCharacters ? 1 : 3;
            if (settings.attribute) {
              const following2 = value2.charCodeAt(end);
              if (following2 === 61) {
                warning(reason, diff);
                characterReference2 = "";
              } else if (isAlphanumerical(following2)) {
                characterReference2 = "";
              } else {
                warning(reason, diff);
              }
            } else {
              warning(reason, diff);
            }
          }
        }
        reference = characterReference2;
      } else {
        if (!terminated) {
          warning(2, diff);
        }
        let referenceCode = Number.parseInt(characters, type === "hexadecimal" ? 16 : 10);
        if (prohibited(referenceCode)) {
          warning(7, diff);
          reference = String.fromCharCode(65533);
        } else if (referenceCode in characterReferenceInvalid) {
          warning(6, diff);
          reference = characterReferenceInvalid[referenceCode];
        } else {
          let output = "";
          if (disallowed(referenceCode)) {
            warning(6, diff);
          }
          if (referenceCode > 65535) {
            referenceCode -= 65536;
            output += String.fromCharCode(referenceCode >>> (10 & 1023) | 55296);
            referenceCode = 56320 | referenceCode & 1023;
          }
          reference = output + String.fromCharCode(referenceCode);
        }
      }
      if (reference) {
        flush();
        previous5 = now();
        index2 = end - 1;
        column += end - start + 1;
        result.push(reference);
        const next = now();
        next.offset++;
        if (settings.reference) {
          settings.reference.call(settings.referenceContext || void 0, reference, { start: previous5, end: next }, value2.slice(start - 1, end));
        }
        previous5 = next;
      } else {
        characters = value2.slice(start - 1, end);
        queue += characters;
        column += characters.length;
        index2 = end - 1;
      }
    } else {
      if (character === 10) {
        line++;
        lines++;
        column = 0;
      }
      if (Number.isNaN(character)) {
        flush();
      } else {
        queue += String.fromCharCode(character);
        column++;
      }
    }
  }
  return result.join("");
  function now() {
    return {
      line,
      column,
      offset: index2 + ((point3 ? point3.offset : 0) || 0)
    };
  }
  function warning(code2, offset) {
    let position2;
    if (settings.warning) {
      position2 = now();
      position2.column += offset;
      position2.offset += offset;
      settings.warning.call(settings.warningContext || void 0, messages[code2], position2, code2);
    }
  }
  function flush() {
    if (queue) {
      result.push(queue);
      if (settings.text) {
        settings.text.call(settings.textContext || void 0, queue, {
          start: previous5,
          end: now()
        });
      }
      queue = "";
    }
  }
}
function prohibited(code2) {
  return code2 >= 55296 && code2 <= 57343 || code2 > 1114111;
}
function disallowed(code2) {
  return code2 >= 1 && code2 <= 8 || code2 === 11 || code2 >= 13 && code2 <= 31 || code2 >= 127 && code2 <= 159 || code2 >= 64976 && code2 <= 65007 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534;
}

// node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/core.js
var defaultSubsetRegex = /["&'<>`]/g;
var surrogatePairsRegex = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
var controlCharactersRegex = /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
var regexEscapeRegex = /[|\\{}()[\]^$+*?.]/g;
var subsetToRegexCache = /* @__PURE__ */ new WeakMap();
function core(value2, options) {
  value2 = value2.replace(options.subset ? charactersToExpressionCached(options.subset) : defaultSubsetRegex, basic);
  if (options.subset || options.escapeOnly) {
    return value2;
  }
  return value2.replace(surrogatePairsRegex, surrogate).replace(controlCharactersRegex, basic);
  function surrogate(pair, index2, all2) {
    return options.format((pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536, all2.charCodeAt(index2 + 2), options);
  }
  function basic(character, index2, all2) {
    return options.format(character.charCodeAt(0), all2.charCodeAt(index2 + 1), options);
  }
}
function charactersToExpressionCached(subset) {
  let cached = subsetToRegexCache.get(subset);
  if (!cached) {
    cached = charactersToExpression(subset);
    subsetToRegexCache.set(subset, cached);
  }
  return cached;
}
function charactersToExpression(subset) {
  const groups = [];
  let index2 = -1;
  while (++index2 < subset.length) {
    groups.push(subset[index2].replace(regexEscapeRegex, "\\$&"));
  }
  return new RegExp("(?:" + groups.join("|") + ")", "g");
}

// node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/util/format-basic.js
function formatBasic(code2) {
  return "&#x" + code2.toString(16).toUpperCase() + ";";
}

// node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/index.js
function stringifyEntitiesLight(value2, options) {
  return core(value2, Object.assign({ format: formatBasic }, options));
}

// node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/check-quote.js
function checkQuote(state) {
  const marker = state.options.quote || '"';
  if (marker !== '"' && marker !== "'") {
    throw new Error("Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`");
  }
  return marker;
}

// node_modules/.pnpm/mdast-util-directive@2.2.4/node_modules/mdast-util-directive/lib/index.js
var own4 = {}.hasOwnProperty;
var shortcut = /^[^\t\n\r "#'.<=>`}]+$/;
handleDirective.peek = peekDirective;
var directiveFromMarkdown = {
  canContainEols: ["textDirective"],
  enter: {
    directiveContainer: enterContainer,
    directiveContainerAttributes: enterAttributes,
    directiveContainerLabel: enterContainerLabel,
    directiveLeaf: enterLeaf,
    directiveLeafAttributes: enterAttributes,
    directiveText: enterText,
    directiveTextAttributes: enterAttributes
  },
  exit: {
    directiveContainer: exit3,
    directiveContainerAttributeClassValue: exitAttributeClassValue,
    directiveContainerAttributeIdValue: exitAttributeIdValue,
    directiveContainerAttributeName: exitAttributeName,
    directiveContainerAttributeValue: exitAttributeValue,
    directiveContainerAttributes: exitAttributes,
    directiveContainerLabel: exitContainerLabel,
    directiveContainerName: exitName,
    directiveLeaf: exit3,
    directiveLeafAttributeClassValue: exitAttributeClassValue,
    directiveLeafAttributeIdValue: exitAttributeIdValue,
    directiveLeafAttributeName: exitAttributeName,
    directiveLeafAttributeValue: exitAttributeValue,
    directiveLeafAttributes: exitAttributes,
    directiveLeafName: exitName,
    directiveText: exit3,
    directiveTextAttributeClassValue: exitAttributeClassValue,
    directiveTextAttributeIdValue: exitAttributeIdValue,
    directiveTextAttributeName: exitAttributeName,
    directiveTextAttributeValue: exitAttributeValue,
    directiveTextAttributes: exitAttributes,
    directiveTextName: exitName
  }
};
var directiveToMarkdown = {
  unsafe: [
    {
      character: "\r",
      inConstruct: ["leafDirectiveLabel", "containerDirectiveLabel"]
    },
    {
      character: "\n",
      inConstruct: ["leafDirectiveLabel", "containerDirectiveLabel"]
    },
    {
      before: "[^:]",
      character: ":",
      after: "[A-Za-z]",
      inConstruct: ["phrasing"]
    },
    { atBreak: true, character: ":", after: ":" }
  ],
  handlers: {
    containerDirective: handleDirective,
    leafDirective: handleDirective,
    textDirective: handleDirective
  }
};
function enterContainer(token) {
  enter.call(this, "containerDirective", token);
}
function enterLeaf(token) {
  enter.call(this, "leafDirective", token);
}
function enterText(token) {
  enter.call(this, "textDirective", token);
}
function enter(type, token) {
  this.enter({ type, name: "", attributes: {}, children: [] }, token);
}
function exitName(token) {
  const node2 = this.stack[this.stack.length - 1];
  node2.name = this.sliceSerialize(token);
}
function enterContainerLabel(token) {
  this.enter({ type: "paragraph", data: { directiveLabel: true }, children: [] }, token);
}
function exitContainerLabel(token) {
  this.exit(token);
}
function enterAttributes() {
  this.setData("directiveAttributes", []);
  this.buffer();
}
function exitAttributeIdValue(token) {
  const list2 = this.getData("directiveAttributes");
  list2.push([
    "id",
    parseEntities(this.sliceSerialize(token), {
      attribute: true
    })
  ]);
}
function exitAttributeClassValue(token) {
  const list2 = this.getData("directiveAttributes");
  list2.push([
    "class",
    parseEntities(this.sliceSerialize(token), {
      attribute: true
    })
  ]);
}
function exitAttributeValue(token) {
  const list2 = this.getData("directiveAttributes");
  list2[list2.length - 1][1] = parseEntities(this.sliceSerialize(token), {
    attribute: true
  });
}
function exitAttributeName(token) {
  const list2 = this.getData("directiveAttributes");
  list2.push([this.sliceSerialize(token), ""]);
}
function exitAttributes() {
  const list2 = this.getData("directiveAttributes");
  const cleaned = {};
  let index2 = -1;
  while (++index2 < list2.length) {
    const attribute = list2[index2];
    if (attribute[0] === "class" && cleaned.class) {
      cleaned.class += " " + attribute[1];
    } else {
      cleaned[attribute[0]] = attribute[1];
    }
  }
  this.setData("directiveAttributes");
  this.resume();
  const node2 = this.stack[this.stack.length - 1];
  node2.attributes = cleaned;
}
function exit3(token) {
  this.exit(token);
}
function handleDirective(node2, _, state, safeOptions) {
  const tracker = track(safeOptions);
  const sequence = fence(node2);
  const exit4 = state.enter(node2.type);
  let value2 = tracker.move(sequence + (node2.name || ""));
  let label4;
  if (node2.type === "containerDirective") {
    const head = (node2.children || [])[0];
    label4 = inlineDirectiveLabel(head) ? head : void 0;
  } else {
    label4 = node2;
  }
  if (label4 && label4.children && label4.children.length > 0) {
    const exit5 = state.enter("label");
    const labelType = `${node2.type}Label`;
    const subexit = state.enter(labelType);
    value2 += tracker.move("[");
    value2 += tracker.move(containerPhrasing(label4, state, __spreadProps(__spreadValues({}, tracker.current()), {
      before: value2,
      after: "]"
    })));
    value2 += tracker.move("]");
    subexit();
    exit5();
  }
  value2 += tracker.move(attributes4(node2, state));
  if (node2.type === "containerDirective") {
    const head = (node2.children || [])[0];
    let shallow = node2;
    if (inlineDirectiveLabel(head)) {
      shallow = Object.assign({}, node2, { children: node2.children.slice(1) });
    }
    if (shallow && shallow.children && shallow.children.length > 0) {
      value2 += tracker.move("\n");
      value2 += tracker.move(containerFlow(shallow, state, tracker.current()));
    }
    value2 += tracker.move("\n" + sequence);
  }
  exit4();
  return value2;
}
function peekDirective() {
  return ":";
}
function attributes4(node2, state) {
  const quote = checkQuote(state);
  const subset = node2.type === "textDirective" ? [quote] : [quote, "\n", "\r"];
  const attrs = node2.attributes || {};
  const values = [];
  let classesFull;
  let classes;
  let id;
  let key;
  for (key in attrs) {
    if (own4.call(attrs, key) && attrs[key] !== void 0 && attrs[key] !== null) {
      const value2 = String(attrs[key]);
      if (key === "id") {
        id = shortcut.test(value2) ? "#" + value2 : quoted("id", value2);
      } else if (key === "class") {
        const list2 = value2.split(/[\t\n\r ]+/g);
        const classesFullList = [];
        const classesList = [];
        let index2 = -1;
        while (++index2 < list2.length) {
          ;
          (shortcut.test(list2[index2]) ? classesList : classesFullList).push(list2[index2]);
        }
        classesFull = classesFullList.length > 0 ? quoted("class", classesFullList.join(" ")) : "";
        classes = classesList.length > 0 ? "." + classesList.join(".") : "";
      } else {
        values.push(quoted(key, value2));
      }
    }
  }
  if (classesFull) {
    values.unshift(classesFull);
  }
  if (classes) {
    values.unshift(classes);
  }
  if (id) {
    values.unshift(id);
  }
  return values.length > 0 ? "{" + values.join(" ") + "}" : "";
  function quoted(key2, value2) {
    return key2 + (value2 ? "=" + quote + stringifyEntitiesLight(value2, { subset }) + quote : "");
  }
}
function inlineDirectiveLabel(node2) {
  return Boolean(node2 && node2.type === "paragraph" && node2.data && node2.data.directiveLabel);
}
function fence(node2) {
  let size2 = 0;
  if (node2.type === "containerDirective") {
    visitParents(node2, function(node3, parents) {
      if (node3.type === "containerDirective") {
        let index2 = parents.length;
        let nesting = 0;
        while (index2--) {
          if (parents[index2].type === "containerDirective") {
            nesting++;
          }
        }
        if (nesting > size2)
          size2 = nesting;
      }
    });
    size2 += 3;
  } else if (node2.type === "leafDirective") {
    size2 = 2;
  } else {
    size2 = 1;
  }
  return ":".repeat(size2);
}

// node_modules/.pnpm/remark-directive@2.0.1/node_modules/remark-directive/index.js
function remarkDirective() {
  const data = this.data();
  add("micromarkExtensions", directive());
  add("fromMarkdownExtensions", directiveFromMarkdown);
  add("toMarkdownExtensions", directiveToMarkdown);
  function add(field, value2) {
    const list2 = data[field] ? data[field] : data[field] = [];
    list2.push(value2);
  }
}

// node_modules/.pnpm/micromark-extension-footnote@1.0.2/node_modules/micromark-extension-footnote/lib/syntax.js
var indent2 = {
  tokenize: tokenizeIndent3,
  partial: true
};
function footnote(options = {}) {
  const call = {
    tokenize: tokenizeFootnoteCall
  };
  const noteStart = {
    tokenize: tokenizeNoteStart,
    resolveAll: resolveAllNote
  };
  const noteEnd = {
    add: "after",
    tokenize: tokenizeNoteEnd,
    resolveAll: resolveAllNote,
    resolveTo: resolveToNoteEnd
  };
  const definition2 = {
    tokenize: tokenizeDefinitionStart2,
    continuation: {
      tokenize: tokenizeDefinitionContinuation2
    },
    exit: footnoteDefinitionEnd
  };
  const text4 = {
    [91]: call
  };
  if (options.inlineNotes) {
    text4[93] = noteEnd;
    text4[94] = noteStart;
  }
  return {
    _hiddenFootnoteSupport: {},
    document: {
      [91]: definition2
    },
    text: text4
  };
}
function resolveAllNote(events) {
  let index2 = -1;
  let token;
  while (++index2 < events.length) {
    token = events[index2][1];
    if (events[index2][0] === "enter" && token.type === "inlineNoteStart") {
      token.type = "data";
      events.splice(index2 + 1, 4);
    }
  }
  return events;
}
function resolveToNoteEnd(events, context) {
  let index2 = events.length - 4;
  let token;
  let openIndex;
  while (index2--) {
    token = events[index2][1];
    if (events[index2][0] === "enter" && token.type === "inlineNoteStart") {
      openIndex = index2;
      break;
    }
  }
  const group = {
    type: "inlineNote",
    start: Object.assign({}, events[openIndex][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const text4 = {
    type: "inlineNoteText",
    start: Object.assign({}, events[openIndex + 4][1].end),
    end: Object.assign({}, events[events.length - 3][1].start)
  };
  const note = [
    ["enter", group, context],
    events[openIndex + 1],
    events[openIndex + 2],
    events[openIndex + 3],
    events[openIndex + 4],
    ["enter", text4, context]
  ];
  splice(note, note.length, 0, resolveAll(context.parser.constructs.insideSpan.null, events.slice(openIndex + 6, -4), context));
  note.push(["exit", text4, context], events[events.length - 2], events[events.length - 3], ["exit", group, context]);
  splice(events, index2, events.length - index2, note);
  return events;
}
function tokenizeFootnoteCall(effects, ok2, nok) {
  const self = this;
  const defined = self.parser.footnotes || (self.parser.footnotes = []);
  let size2 = 0;
  let data;
  return start;
  function start(code2) {
    effects.enter("footnoteCall");
    effects.enter("footnoteCallLabelMarker");
    effects.consume(code2);
    effects.exit("footnoteCallLabelMarker");
    return callStart;
  }
  function callStart(code2) {
    if (code2 !== 94)
      return nok(code2);
    effects.enter("footnoteCallMarker");
    effects.consume(code2);
    effects.exit("footnoteCallMarker");
    effects.enter("footnoteCallString");
    effects.enter("chunkString").contentType = "string";
    return callData;
  }
  function callData(code2) {
    let token;
    if (code2 === null || code2 === 91 || size2++ > 999) {
      return nok(code2);
    }
    if (code2 === 93) {
      if (!data) {
        return nok(code2);
      }
      effects.exit("chunkString");
      token = effects.exit("footnoteCallString");
      return defined.includes(normalizeIdentifier(self.sliceSerialize(token))) ? end(code2) : nok(code2);
    }
    effects.consume(code2);
    if (!markdownLineEndingOrSpace(code2)) {
      data = true;
    }
    return code2 === 92 ? callEscape : callData;
  }
  function callEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size2++;
      return callData;
    }
    return callData(code2);
  }
  function end(code2) {
    effects.enter("footnoteCallLabelMarker");
    effects.consume(code2);
    effects.exit("footnoteCallLabelMarker");
    effects.exit("footnoteCall");
    return ok2;
  }
}
function tokenizeNoteStart(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("inlineNoteStart");
    effects.enter("inlineNoteMarker");
    effects.consume(code2);
    effects.exit("inlineNoteMarker");
    return noteStart;
  }
  function noteStart(code2) {
    if (code2 !== 91)
      return nok(code2);
    effects.enter("inlineNoteStartMarker");
    effects.consume(code2);
    effects.exit("inlineNoteStartMarker");
    effects.exit("inlineNoteStart");
    return ok2;
  }
}
function tokenizeNoteEnd(effects, ok2, nok) {
  const self = this;
  return start;
  function start(code2) {
    let index2 = self.events.length;
    let hasStart;
    while (index2--) {
      if (self.events[index2][1].type === "inlineNoteStart") {
        hasStart = true;
        break;
      }
    }
    if (!hasStart) {
      return nok(code2);
    }
    effects.enter("inlineNoteEnd");
    effects.enter("inlineNoteEndMarker");
    effects.consume(code2);
    effects.exit("inlineNoteEndMarker");
    effects.exit("inlineNoteEnd");
    return ok2;
  }
}
function tokenizeDefinitionStart2(effects, ok2, nok) {
  const self = this;
  const defined = self.parser.footnotes || (self.parser.footnotes = []);
  let identifier;
  let size2 = 0;
  let data;
  return start;
  function start(code2) {
    effects.enter("footnoteDefinition")._container = true;
    effects.enter("footnoteDefinitionLabel");
    effects.enter("footnoteDefinitionLabelMarker");
    effects.consume(code2);
    effects.exit("footnoteDefinitionLabelMarker");
    return labelStart;
  }
  function labelStart(code2) {
    if (code2 !== 94)
      return nok(code2);
    effects.enter("footnoteDefinitionMarker");
    effects.consume(code2);
    effects.exit("footnoteDefinitionMarker");
    effects.enter("footnoteDefinitionLabelString");
    return atBreak;
  }
  function atBreak(code2) {
    let token;
    if (code2 === null || code2 === 91 || size2 > 999) {
      return nok(code2);
    }
    if (code2 === 93) {
      if (!data) {
        return nok(code2);
      }
      token = effects.exit("footnoteDefinitionLabelString");
      identifier = normalizeIdentifier(self.sliceSerialize(token));
      effects.enter("footnoteDefinitionLabelMarker");
      effects.consume(code2);
      effects.exit("footnoteDefinitionLabelMarker");
      effects.exit("footnoteDefinitionLabel");
      return labelAfter;
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      size2++;
      return atBreak;
    }
    effects.enter("chunkString").contentType = "string";
    return label4(code2);
  }
  function label4(code2) {
    if (code2 === null || markdownLineEnding(code2) || code2 === 91 || code2 === 93 || size2 > 999) {
      effects.exit("chunkString");
      return atBreak(code2);
    }
    if (!markdownLineEndingOrSpace(code2)) {
      data = true;
    }
    size2++;
    effects.consume(code2);
    return code2 === 92 ? labelEscape : label4;
  }
  function labelEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size2++;
      return label4;
    }
    return label4(code2);
  }
  function labelAfter(code2) {
    if (code2 !== 58) {
      return nok(code2);
    }
    effects.enter("definitionMarker");
    effects.consume(code2);
    effects.exit("definitionMarker");
    return effects.check(blankLine, onBlank, nonBlank);
  }
  function onBlank(code2) {
    self.containerState.initialBlankLine = true;
    return done(code2);
  }
  function nonBlank(code2) {
    if (markdownSpace(code2)) {
      effects.enter("footnoteDefinitionWhitespace");
      effects.consume(code2);
      effects.exit("footnoteDefinitionWhitespace");
      return done(code2);
    }
    return done(code2);
  }
  function done(code2) {
    if (!defined.includes(identifier)) {
      defined.push(identifier);
    }
    return ok2(code2);
  }
}
function tokenizeDefinitionContinuation2(effects, ok2, nok) {
  const self = this;
  return effects.check(blankLine, onBlank, notBlank);
  function onBlank(code2) {
    if (self.containerState.initialBlankLine) {
      self.containerState.furtherBlankLines = true;
    }
    return ok2(code2);
  }
  function notBlank(code2) {
    if (self.containerState.furtherBlankLines || !markdownSpace(code2)) {
      return nok(code2);
    }
    self.containerState.initialBlankLine = void 0;
    self.containerState.furtherBlankLines = void 0;
    return effects.attempt(indent2, ok2, nok)(code2);
  }
}
function footnoteDefinitionEnd(effects) {
  effects.exit("footnoteDefinition");
}
function tokenizeIndent3(effects, ok2, nok) {
  const self = this;
  return factorySpace(effects, afterPrefix, "footnoteDefinitionIndent", 4 + 1);
  function afterPrefix(code2) {
    const tail = self.events[self.events.length - 1];
    return tail && tail[1].type === "footnoteDefinitionIndent" && tail[2].sliceSerialize(tail[1], true).length === 4 ? ok2(code2) : nok(code2);
  }
}

// node_modules/.pnpm/mdast-util-footnote@1.1.1/node_modules/mdast-util-footnote/lib/index.js
var footnoteFromMarkdown = {
  canContainEols: ["footnote"],
  enter: {
    footnoteDefinition: enterFootnoteDefinition2,
    footnoteDefinitionLabelString: enterFootnoteDefinitionLabelString2,
    footnoteCall: enterFootnoteCall2,
    footnoteCallString: enterFootnoteCallString2,
    inlineNote: enterNote
  },
  exit: {
    footnoteDefinition: exitFootnoteDefinition2,
    footnoteDefinitionLabelString: exitFootnoteDefinitionLabelString2,
    footnoteCall: exitFootnoteCall2,
    footnoteCallString: exitFootnoteCallString2,
    inlineNote: exitNote
  }
};
var footnoteToMarkdown = {
  unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
  handlers: { footnote: footnote2, footnoteDefinition: footnoteDefinition2, footnoteReference: footnoteReference2 }
};
footnoteReference2.peek = footnoteReferencePeek2;
footnote2.peek = footnotePeek;
function enterFootnoteDefinition2(token) {
  this.enter({ type: "footnoteDefinition", identifier: "", label: "", children: [] }, token);
}
function enterFootnoteDefinitionLabelString2() {
  this.buffer();
}
function exitFootnoteDefinitionLabelString2(token) {
  const label4 = this.resume();
  const node2 = this.stack[this.stack.length - 1];
  node2.label = label4;
  node2.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
}
function exitFootnoteDefinition2(token) {
  this.exit(token);
}
function enterFootnoteCall2(token) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, token);
}
function enterFootnoteCallString2() {
  this.buffer();
}
function exitFootnoteCallString2(token) {
  const label4 = this.resume();
  const node2 = this.stack[this.stack.length - 1];
  node2.label = label4;
  node2.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
}
function exitFootnoteCall2(token) {
  this.exit(token);
}
function enterNote(token) {
  this.enter({ type: "footnote", children: [] }, token);
}
function exitNote(token) {
  this.exit(token);
}
function footnoteReference2(node2, _, context, safeOptions) {
  const tracker = track(safeOptions);
  let value2 = tracker.move("[^");
  const exit4 = context.enter("footnoteReference");
  const subexit = context.enter("reference");
  value2 += tracker.move(safe(context, association(node2), __spreadProps(__spreadValues({}, tracker.current()), {
    before: value2,
    after: "]"
  })));
  subexit();
  exit4();
  value2 += tracker.move("]");
  return value2;
}
function footnoteReferencePeek2() {
  return "[";
}
function footnote2(node2, _, context, safeOptions) {
  const tracker = track(safeOptions);
  let value2 = tracker.move("^[");
  const exit4 = context.enter("footnote");
  const subexit = context.enter("label");
  value2 += tracker.move(containerPhrasing(node2, context, __spreadProps(__spreadValues({}, tracker.current()), {
    before: value2,
    after: "]"
  })));
  subexit();
  exit4();
  value2 += tracker.move("]");
  return value2;
}
function footnotePeek() {
  return "^";
}
function footnoteDefinition2(node2, _, context, safeOptions) {
  const tracker = track(safeOptions);
  let value2 = tracker.move("[^");
  const exit4 = context.enter("footnoteDefinition");
  const subexit = context.enter("label");
  value2 += tracker.move(safe(context, association(node2), __spreadProps(__spreadValues({}, tracker.current()), {
    before: value2,
    after: "]"
  })));
  subexit();
  value2 += tracker.move("]:" + (node2.children && node2.children.length > 0 ? " " : ""));
  tracker.shift(4);
  value2 += tracker.move(indentLines(containerFlow(node2, context, tracker.current()), map2));
  exit4();
  return value2;
  function map2(line, index2, blank) {
    if (index2) {
      return (blank ? "" : "    ") + line;
    }
    return line;
  }
}

// node_modules/.pnpm/remark-footnotes@4.0.1/node_modules/remark-footnotes/index.js
function remarkFootnotes(options = {}) {
  const data = this.data();
  add("micromarkExtensions", footnote(options));
  add("fromMarkdownExtensions", footnoteFromMarkdown);
  add("toMarkdownExtensions", footnoteToMarkdown);
  function add(field, value2) {
    const list2 = data[field] ? data[field] : data[field] = [];
    list2.push(value2);
  }
}

// node_modules/.pnpm/micromark-extension-wiki-link@0.0.4/node_modules/micromark-extension-wiki-link/dist/index.umd.js
var codes = {
  horizontalTab: -2,
  virtualSpace: -1,
  nul: 0,
  eof: null,
  space: 32
};
function markdownLineEndingOrSpace2(code2) {
  return code2 < codes.nul || code2 === codes.space;
}
function markdownLineEnding2(code2) {
  return code2 < codes.horizontalTab;
}
function wikiLink() {
  var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var aliasDivider = opts.aliasDivider || ":";
  var aliasMarker = aliasDivider;
  var startMarker = "[[";
  var endMarker = "]]";
  function tokenize(effects, ok2, nok) {
    var data;
    var alias;
    var aliasCursor = 0;
    var startMarkerCursor = 0;
    var endMarkerCursor = 0;
    return start;
    function start(code2) {
      if (code2 !== startMarker.charCodeAt(startMarkerCursor))
        return nok(code2);
      effects.enter("wikiLink");
      effects.enter("wikiLinkMarker");
      return consumeStart(code2);
    }
    function consumeStart(code2) {
      if (startMarkerCursor === startMarker.length) {
        effects.exit("wikiLinkMarker");
        return consumeData(code2);
      }
      if (code2 !== startMarker.charCodeAt(startMarkerCursor)) {
        return nok(code2);
      }
      effects.consume(code2);
      startMarkerCursor++;
      return consumeStart;
    }
    function consumeData(code2) {
      if (markdownLineEnding2(code2) || code2 === codes.eof) {
        return nok(code2);
      }
      effects.enter("wikiLinkData");
      effects.enter("wikiLinkTarget");
      return consumeTarget(code2);
    }
    function consumeTarget(code2) {
      if (code2 === aliasMarker.charCodeAt(aliasCursor)) {
        if (!data)
          return nok(code2);
        effects.exit("wikiLinkTarget");
        effects.enter("wikiLinkAliasMarker");
        return consumeAliasMarker(code2);
      }
      if (code2 === endMarker.charCodeAt(endMarkerCursor)) {
        if (!data)
          return nok(code2);
        effects.exit("wikiLinkTarget");
        effects.exit("wikiLinkData");
        effects.enter("wikiLinkMarker");
        return consumeEnd(code2);
      }
      if (markdownLineEnding2(code2) || code2 === codes.eof) {
        return nok(code2);
      }
      if (!markdownLineEndingOrSpace2(code2)) {
        data = true;
      }
      effects.consume(code2);
      return consumeTarget;
    }
    function consumeAliasMarker(code2) {
      if (aliasCursor === aliasMarker.length) {
        effects.exit("wikiLinkAliasMarker");
        effects.enter("wikiLinkAlias");
        return consumeAlias(code2);
      }
      if (code2 !== aliasMarker.charCodeAt(aliasCursor)) {
        return nok(code2);
      }
      effects.consume(code2);
      aliasCursor++;
      return consumeAliasMarker;
    }
    function consumeAlias(code2) {
      if (code2 === endMarker.charCodeAt(endMarkerCursor)) {
        if (!alias)
          return nok(code2);
        effects.exit("wikiLinkAlias");
        effects.exit("wikiLinkData");
        effects.enter("wikiLinkMarker");
        return consumeEnd(code2);
      }
      if (markdownLineEnding2(code2) || code2 === codes.eof) {
        return nok(code2);
      }
      if (!markdownLineEndingOrSpace2(code2)) {
        alias = true;
      }
      effects.consume(code2);
      return consumeAlias;
    }
    function consumeEnd(code2) {
      if (endMarkerCursor === endMarker.length) {
        effects.exit("wikiLinkMarker");
        effects.exit("wikiLink");
        return ok2(code2);
      }
      if (code2 !== endMarker.charCodeAt(endMarkerCursor)) {
        return nok(code2);
      }
      effects.consume(code2);
      endMarkerCursor++;
      return consumeEnd;
    }
  }
  var call = {
    tokenize
  };
  return {
    text: {
      91: call
    }
  };
}

// node_modules/.pnpm/mdast-util-wiki-link@0.0.2/node_modules/mdast-util-wiki-link/dist/index.umd.js
var import_safe4 = __toESM(require_safe());
function fromMarkdown2() {
  var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var permalinks = opts.permalinks || [];
  var defaultPageResolver = function defaultPageResolver2(name) {
    return [name.replace(/ /g, "_").toLowerCase()];
  };
  var pageResolver = opts.pageResolver || defaultPageResolver;
  var newClassName = opts.newClassName || "new";
  var wikiLinkClassName = opts.wikiLinkClassName || "internal";
  var defaultHrefTemplate = function defaultHrefTemplate2(permalink) {
    return "#/page/".concat(permalink);
  };
  var hrefTemplate = opts.hrefTemplate || defaultHrefTemplate;
  function enterWikiLink(token) {
    this.enter({
      type: "wikiLink",
      value: null,
      data: {
        alias: null,
        permalink: null,
        exists: null
      }
    }, token);
  }
  function top(stack) {
    return stack[stack.length - 1];
  }
  function exitWikiLinkAlias(token) {
    var alias = this.sliceSerialize(token);
    var current = top(this.stack);
    current.data.alias = alias;
  }
  function exitWikiLinkTarget(token) {
    var target = this.sliceSerialize(token);
    var current = top(this.stack);
    current.value = target;
  }
  function exitWikiLink(token) {
    var wikiLink2 = this.exit(token);
    var pagePermalinks = pageResolver(wikiLink2.value);
    var permalink = pagePermalinks.find(function(p) {
      return permalinks.indexOf(p) !== -1;
    });
    var exists = permalink !== void 0;
    if (!exists) {
      permalink = pagePermalinks[0];
    }
    var displayName = wikiLink2.value;
    if (wikiLink2.data.alias) {
      displayName = wikiLink2.data.alias;
    }
    var classNames = wikiLinkClassName;
    if (!exists) {
      classNames += " " + newClassName;
    }
    wikiLink2.data.alias = displayName;
    wikiLink2.data.permalink = permalink;
    wikiLink2.data.exists = exists;
    wikiLink2.data.hName = "a";
    wikiLink2.data.hProperties = {
      className: classNames,
      href: hrefTemplate(permalink)
    };
    wikiLink2.data.hChildren = [{
      type: "text",
      value: displayName
    }];
  }
  return {
    enter: {
      wikiLink: enterWikiLink
    },
    exit: {
      wikiLinkTarget: exitWikiLinkTarget,
      wikiLinkAlias: exitWikiLinkAlias,
      wikiLink: exitWikiLink
    }
  };
}
function toMarkdown() {
  var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var aliasDivider = opts.aliasDivider || ":";
  var unsafe = [{
    character: "[",
    inConstruct: ["phrasing", "label", "reference"]
  }, {
    character: "]",
    inConstruct: ["label", "reference"]
  }];
  function handler2(node2, _, context) {
    var exit4 = context.enter("wikiLink");
    var nodeValue = (0, import_safe4.default)(context, node2.value, {
      before: "[",
      after: "]"
    });
    var nodeAlias = (0, import_safe4.default)(context, node2.data.alias, {
      before: "[",
      after: "]"
    });
    var value2;
    if (nodeAlias !== nodeValue) {
      value2 = "[[".concat(nodeValue).concat(aliasDivider).concat(nodeAlias, "]]");
    } else {
      value2 = "[[".concat(nodeValue, "]]");
    }
    exit4();
    return value2;
  }
  return {
    unsafe,
    handlers: {
      wikiLink: handler2
    }
  };
}

// node_modules/.pnpm/remark-wiki-link@1.0.4/node_modules/remark-wiki-link/dist/index.umd.js
var warningIssued;
function wikiLinkPlugin() {
  var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var data = this.data();
  function add(field, value2) {
    if (data[field])
      data[field].push(value2);
    else
      data[field] = [value2];
  }
  if (!warningIssued && (this.Parser && this.Parser.prototype && this.Parser.prototype.blockTokenizers || this.Compiler && this.Compiler.prototype && this.Compiler.prototype.visitors)) {
    warningIssued = true;
    console.warn("[remark-wiki-link] Warning: please upgrade to remark 13 to use this plugin");
  }
  add("micromarkExtensions", wikiLink(opts));
  add("fromMarkdownExtensions", fromMarkdown2(opts));
  add("toMarkdownExtensions", toMarkdown(opts));
}
wikiLinkPlugin.wikiLinkPlugin = wikiLinkPlugin;
var index_umd_default = wikiLinkPlugin;

// node_modules/.pnpm/fault@2.0.1/node_modules/fault/index.js
var import_format = __toESM(require_format(), 1);
var fault = Object.assign(create(Error), {
  eval: create(EvalError),
  range: create(RangeError),
  reference: create(ReferenceError),
  syntax: create(SyntaxError),
  type: create(TypeError),
  uri: create(URIError)
});
function create(Constructor) {
  FormattedError.displayName = Constructor.displayName || Constructor.name;
  return FormattedError;
  function FormattedError(format2, ...values) {
    const reason = format2 ? (0, import_format.default)(format2, ...values) : format2;
    return new Constructor(reason);
  }
}

// node_modules/.pnpm/micromark-extension-frontmatter@1.1.1/node_modules/micromark-extension-frontmatter/matters.js
var own5 = {}.hasOwnProperty;
var markers = {
  yaml: "-",
  toml: "+"
};
function matters(options) {
  const result = [];
  let index2 = -1;
  const presetsOrMatters = Array.isArray(options) ? options : options ? [options] : ["yaml"];
  while (++index2 < presetsOrMatters.length) {
    result[index2] = matter(presetsOrMatters[index2]);
  }
  return result;
}
function matter(option) {
  let result = option;
  if (typeof result === "string") {
    if (!own5.call(markers, result)) {
      throw fault("Missing matter definition for `%s`", result);
    }
    result = {
      type: result,
      marker: markers[result]
    };
  } else if (typeof result !== "object") {
    throw fault("Expected matter to be an object, not `%j`", result);
  }
  if (!own5.call(result, "type")) {
    throw fault("Missing `type` in matter `%j`", result);
  }
  if (!own5.call(result, "fence") && !own5.call(result, "marker")) {
    throw fault("Missing `marker` or `fence` in matter `%j`", result);
  }
  return result;
}

// node_modules/.pnpm/micromark-extension-frontmatter@1.1.1/node_modules/micromark-extension-frontmatter/lib/syntax.js
function frontmatter(options) {
  const listOfMatters = matters(options);
  const flow3 = {};
  let index2 = -1;
  while (++index2 < listOfMatters.length) {
    const matter2 = listOfMatters[index2];
    const code2 = fence2(matter2, "open").charCodeAt(0);
    const construct = createConstruct(matter2);
    const existing = flow3[code2];
    if (Array.isArray(existing)) {
      existing.push(construct);
    } else {
      flow3[code2] = [construct];
    }
  }
  return {
    flow: flow3
  };
}
function createConstruct(matter2) {
  const anywhere = matter2.anywhere;
  const frontmatterType = matter2.type;
  const fenceType = frontmatterType + "Fence";
  const sequenceType = fenceType + "Sequence";
  const valueType = frontmatterType + "Value";
  const closingFenceConstruct = {
    tokenize: tokenizeClosingFence,
    partial: true
  };
  let buffer2;
  let bufferIndex = 0;
  return {
    tokenize: tokenizeFrontmatter,
    concrete: true
  };
  function tokenizeFrontmatter(effects, ok2, nok) {
    const self = this;
    return start;
    function start(code2) {
      const position2 = self.now();
      if (position2.column === 1 && (position2.line === 1 || anywhere)) {
        buffer2 = fence2(matter2, "open");
        bufferIndex = 0;
        if (code2 === buffer2.charCodeAt(bufferIndex)) {
          effects.enter(frontmatterType);
          effects.enter(fenceType);
          effects.enter(sequenceType);
          return openSequence(code2);
        }
      }
      return nok(code2);
    }
    function openSequence(code2) {
      if (bufferIndex === buffer2.length) {
        effects.exit(sequenceType);
        if (markdownSpace(code2)) {
          effects.enter("whitespace");
          return openSequenceWhitespace(code2);
        }
        return openAfter(code2);
      }
      if (code2 === buffer2.charCodeAt(bufferIndex++)) {
        effects.consume(code2);
        return openSequence;
      }
      return nok(code2);
    }
    function openSequenceWhitespace(code2) {
      if (markdownSpace(code2)) {
        effects.consume(code2);
        return openSequenceWhitespace;
      }
      effects.exit("whitespace");
      return openAfter(code2);
    }
    function openAfter(code2) {
      if (markdownLineEnding(code2)) {
        effects.exit(fenceType);
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        buffer2 = fence2(matter2, "close");
        bufferIndex = 0;
        return effects.attempt(closingFenceConstruct, after, contentStart);
      }
      return nok(code2);
    }
    function contentStart(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        return contentEnd(code2);
      }
      effects.enter(valueType);
      return contentInside(code2);
    }
    function contentInside(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects.exit(valueType);
        return contentEnd(code2);
      }
      effects.consume(code2);
      return contentInside;
    }
    function contentEnd(code2) {
      if (code2 === null) {
        return nok(code2);
      }
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return effects.attempt(closingFenceConstruct, after, contentStart);
    }
    function after(code2) {
      effects.exit(frontmatterType);
      return ok2(code2);
    }
  }
  function tokenizeClosingFence(effects, ok2, nok) {
    let bufferIndex2 = 0;
    return closeStart;
    function closeStart(code2) {
      if (code2 === buffer2.charCodeAt(bufferIndex2)) {
        effects.enter(fenceType);
        effects.enter(sequenceType);
        return closeSequence(code2);
      }
      return nok(code2);
    }
    function closeSequence(code2) {
      if (bufferIndex2 === buffer2.length) {
        effects.exit(sequenceType);
        if (markdownSpace(code2)) {
          effects.enter("whitespace");
          return closeSequenceWhitespace(code2);
        }
        return closeAfter(code2);
      }
      if (code2 === buffer2.charCodeAt(bufferIndex2++)) {
        effects.consume(code2);
        return closeSequence;
      }
      return nok(code2);
    }
    function closeSequenceWhitespace(code2) {
      if (markdownSpace(code2)) {
        effects.consume(code2);
        return closeSequenceWhitespace;
      }
      effects.exit("whitespace");
      return closeAfter(code2);
    }
    function closeAfter(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects.exit(fenceType);
        return ok2(code2);
      }
      return nok(code2);
    }
  }
}
function fence2(matter2, prop) {
  return matter2.marker ? pick(matter2.marker, prop).repeat(3) : pick(matter2.fence, prop);
}
function pick(schema, prop) {
  return typeof schema === "string" ? schema : schema[prop];
}

// node_modules/.pnpm/mdast-util-frontmatter@1.0.1/node_modules/mdast-util-frontmatter/lib/index.js
function frontmatterFromMarkdown(options) {
  const settings = matters(options);
  const enter2 = {};
  const exit4 = {};
  let index2 = -1;
  while (++index2 < settings.length) {
    const matter2 = settings[index2];
    enter2[matter2.type] = opener(matter2);
    exit4[matter2.type] = close;
    exit4[matter2.type + "Value"] = value;
  }
  return { enter: enter2, exit: exit4 };
}
function opener(matter2) {
  return open;
  function open(token) {
    this.enter({ type: matter2.type, value: "" }, token);
    this.buffer();
  }
}
function close(token) {
  const data = this.resume();
  const node2 = this.exit(token);
  node2.value = data.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
}
function value(token) {
  this.config.enter.data.call(this, token);
  this.config.exit.data.call(this, token);
}
function frontmatterToMarkdown(options) {
  const unsafe = [];
  const handlers = {};
  const settings = matters(options);
  let index2 = -1;
  while (++index2 < settings.length) {
    const matter2 = settings[index2];
    handlers[matter2.type] = handler(matter2);
    unsafe.push({ atBreak: true, character: fence3(matter2, "open").charAt(0) });
  }
  return { unsafe, handlers };
}
function handler(matter2) {
  const open = fence3(matter2, "open");
  const close2 = fence3(matter2, "close");
  return handle;
  function handle(node2) {
    return open + (node2.value ? "\n" + node2.value : "") + "\n" + close2;
  }
}
function fence3(matter2, prop) {
  return matter2.marker ? pick2(matter2.marker, prop).repeat(3) : pick2(matter2.fence, prop);
}
function pick2(schema, prop) {
  return typeof schema === "string" ? schema : schema[prop];
}

// node_modules/.pnpm/remark-frontmatter@4.0.1/node_modules/remark-frontmatter/index.js
function remarkFrontmatter(options = "yaml") {
  const data = this.data();
  add("micromarkExtensions", frontmatter(options));
  add("fromMarkdownExtensions", frontmatterFromMarkdown(options));
  add("toMarkdownExtensions", frontmatterToMarkdown(options));
  function add(field, value2) {
    const list2 = data[field] ? data[field] : data[field] = [];
    list2.push(value2);
  }
}

// node_modules/.pnpm/unist-util-visit@4.1.2/node_modules/unist-util-visit/lib/index.js
var visit = function(tree, test, visitor, reverse) {
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
    test = null;
  }
  visitParents(tree, test, overload, reverse);
  function overload(node2, parents) {
    const parent = parents[parents.length - 1];
    return visitor(node2, parent ? parent.children.indexOf(node2) : null, parent);
  }
};

// src/nodeTypeHelpers.ts
function isParent(node2) {
  return "children" in node2;
}
function assertNodeType(node2, type) {
  if (!is(node2, type))
    throwWrongNode(type, node2);
}
function throwWrongNode(expected, node2) {
  throw new Error(`Expected node of type ${expected} but received node ${JSON.stringify(node2)}`);
}

// src/transform/embeds/embedDirective.ts
var isEmbedDirective = convert({
  type: "textDirective",
  name: "embed"
});
function assertEmbedDirective(node2) {
  if (!isEmbedDirective(node2))
    throwWrongNode("embed", node2);
}

// src/transform/embeds/embedResolver.ts
var import_obsidian = require("obsidian");

// src/transform/preprocessor.ts
function preprocess2(data) {
  return data.replaceAll(/\$\$(.+)$/gm, "$$$$\n$1").replaceAll(/^(.+)\$\$/gm, "$1\n$$$$").replaceAll(/!\[\[([^\]]+)]]/gm, ':embed{target="$1"}');
}

// src/file.ts
function toVFile(file) {
  return __async(this, null, function* () {
    if (!(yield file.vault.adapter.exists(file.path))) {
      throw new Error(`${file.basename} does not exist`);
    }
    const data = yield file.vault.cachedRead(file);
    return makeVFile(data, file.path);
  });
}
function vfileFromSelection(view) {
  return makeVFile(view.editor.getSelection(), view.file.path);
}
function makeVFile(contents, path3, subpath) {
  const options = {
    value: preprocess2(contents),
    path: path3,
    data: { embedded: new Array() },
    subpath
  };
  return new VFile(options);
}
function toNamedVFile(vfile2) {
  if (vfile2.path === void 0)
    throw new Error("Processed file must have a name");
  return vfile2;
}

// node_modules/.pnpm/is-what@4.1.16/node_modules/is-what/dist/index.js
function getType(payload) {
  return Object.prototype.toString.call(payload).slice(8, -1);
}
function isPlainObject2(payload) {
  if (getType(payload) !== "Object")
    return false;
  const prototype = Object.getPrototypeOf(payload);
  return !!prototype && prototype.constructor === Object && prototype === Object.prototype;
}
function isNull(payload) {
  return getType(payload) === "Null";
}
function isOneOf(a, b, c, d, e) {
  return (value2) => a(value2) || b(value2) || !!c && c(value2) || !!d && d(value2) || !!e && e(value2);
}
function isUndefined(payload) {
  return getType(payload) === "Undefined";
}
var isNullOrUndefined = isOneOf(isNull, isUndefined);
function isSymbol(payload) {
  return getType(payload) === "Symbol";
}

// node_modules/.pnpm/merge-anything@5.1.7/node_modules/merge-anything/dist/index.js
function assignProp(carry, key, newVal, originalObject) {
  const propType = {}.propertyIsEnumerable.call(originalObject, key) ? "enumerable" : "nonenumerable";
  if (propType === "enumerable")
    carry[key] = newVal;
  if (propType === "nonenumerable") {
    Object.defineProperty(carry, key, {
      value: newVal,
      enumerable: false,
      writable: true,
      configurable: true
    });
  }
}
function mergeRecursively(origin, newComer, compareFn) {
  if (!isPlainObject2(newComer))
    return newComer;
  let newObject = {};
  if (isPlainObject2(origin)) {
    const props2 = Object.getOwnPropertyNames(origin);
    const symbols2 = Object.getOwnPropertySymbols(origin);
    newObject = [...props2, ...symbols2].reduce((carry, key) => {
      const targetVal = origin[key];
      if (!isSymbol(key) && !Object.getOwnPropertyNames(newComer).includes(key) || isSymbol(key) && !Object.getOwnPropertySymbols(newComer).includes(key)) {
        assignProp(carry, key, targetVal, origin);
      }
      return carry;
    }, {});
  }
  const props = Object.getOwnPropertyNames(newComer);
  const symbols = Object.getOwnPropertySymbols(newComer);
  const result = [...props, ...symbols].reduce((carry, key) => {
    let newVal = newComer[key];
    const targetVal = isPlainObject2(origin) ? origin[key] : void 0;
    if (targetVal !== void 0 && isPlainObject2(newVal)) {
      newVal = mergeRecursively(targetVal, newVal, compareFn);
    }
    const propToAssign = compareFn ? compareFn(targetVal, newVal, key) : newVal;
    assignProp(carry, key, propToAssign, newComer);
    return carry;
  }, newObject);
  return result;
}
function merge(object, ...otherObjects) {
  return otherObjects.reduce((result, newComer) => {
    return mergeRecursively(result, newComer);
  }, object);
}

// src/plugin/settings.ts
var ExportToTexSettings = class {
  constructor() {
    this.refCommand = "cref";
    this.defaultToEquation = false;
    this.additionalMathEnvironments = [];
    this.generateLabels = true;
    this.compressNewlines = false;
    this.imagePathSettings = 0 /* RelativeToRoot */;
    this.numberedSections = true;
    this.preamble = "\\documentclass[paper=a4]{jlreq}\n\\usepackage{amsmath}\n\\usepackage{amssymb}\n\\usepackage{amsthm}\n\\usepackage{amsfonts}\n\\usepackage{mathtools}\n\\usepackage{graphicx}\n\\usepackage{multirow}\n\\usepackage{hyperref}\n\\usepackage{diffcoeff}\n\\usepackage{comment}\n\\usepackage{mhchem}\n\\usepackage[separate-uncertainty]{siunitx}\n\\usepackage{newunicodechar}\n\\usepackage{listings}\n\\usepackage{float}\n\\usepackage{lscape}\n\\usepackage{adjustbox}\n\\usepackage{tabularx}\n\\usepackage{booktabs}\n\\usepackage{longtable}\n\\usepackage{caption}\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\\NewDocumentCommand\\degC{}{\\ensuremath{^\\circ\\symup{C}}}\n\\NewDocumentCommand\\abs{m}{\\left|#1\\right|}\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\\jlreqsetup{\n    appendix_counter={\n        section={\n            value=0,\n            the={\\Alph{section}}\n        },\n        table={\n            value=0,\n            the={\\Alph{section}\\arabic{table}}\n        },\n        figure={\n            value=0,\n            the={\\Alph{section}\\arabic{figure}}\n        }\n    },\n    appendix_heading={\n        section={\n            label_format={\u4ED8\u9332\\thesection:}\n        }\n    }\n}\n\n\\title{{{title}}}\n\\author{{{affiliation}} \\\\ {{student_id}} {{name}}}\n\\date{{{date}}}\n\n\n\\begin{document}\n";
    this.postamble = "\n\\end{document}";
    this.generateCaptions = true;
    this.figurePosition = "h";
    this.tablePosition = "H";
    this.askForFrontmatter = true;
    this.askForCaptions = true;
    this.askForExportPath = false;
  }
};
function ensureValidTemplate(template) {
  let result = template;
  if (!result.match(/\\documentclass/)) {
    result = "\\documentclass[paper=a4]{jlreq}\n" + result;
  }
  if (!result.match(/\\usepackage\{amsmath\}/)) {
    const docClassMatch = result.match(/\\documentclass[^\n]*\n/);
    if (docClassMatch) {
      const insertIndex = result.indexOf(docClassMatch[0]) + docClassMatch[0].length;
      result = result.substring(0, insertIndex) + "\\usepackage{amsmath}\n" + result.substring(insertIndex);
    }
  }
  if (!result.match(/\\usepackage(\[.*?\])?\{caption\}/)) {
    const docClassMatch = result.match(/\\documentclass[^\n]*\n/);
    if (docClassMatch) {
      const insertIndex = result.indexOf(docClassMatch[0]) + docClassMatch[0].length;
      result = result.substring(0, insertIndex) + "\\usepackage{caption}\n" + result.substring(insertIndex);
    }
  }
  if (!result.match(/\\begin\{document\}/)) {
    if (!result.endsWith("\n")) {
      result += "\n";
    }
    result += "\\begin{document}\n";
  }
  return result;
}
function ensureValidPostamble(postamble) {
  let result = postamble;
  if (!result.match(/\\end\{document\}/)) {
    if (!result.endsWith("\n")) {
      result += "\n";
    }
    result += "\\end{document}\n";
  }
  return result;
}
function ensureRequiredPackages(preamble) {
  const requiredPackages = [
    { name: "float", description: "Float positioning (table/figure)" },
    { name: "lscape", description: "Landscape page orientation" },
    { name: "adjustbox", description: "Adjust box sizing" },
    { name: "tabularx", description: "Flexible table columns" },
    { name: "booktabs", description: "Professional table formatting" },
    { name: "longtable", description: "Multi-page tables" }
  ];
  let updated = preamble;
  const addedPackages = [];
  for (const pkg of requiredPackages) {
    const pattern = new RegExp(`\\\\usepackage(?:\\[[^\\]]*\\])?\\{${pkg.name}\\}`);
    if (!pattern.test(updated)) {
      let insertPoint = -1;
      const candidates = [
        /\\usepackage\{float\}\n/,
        /\\usepackage\{booktabs\}\n/,
        /\\usepackage\{longtable\}\n/,
        /\\usepackage\{adjustbox\}\n/,
        /\\usepackage\{tabularx\}\n/,
        /\\usepackage\{lscape\}\n/,
        /\\usepackage\{listings\}\n/,
        /\\usepackage\{newunicodechar\}\n/
      ];
      for (const pattern2 of candidates) {
        const match = updated.match(pattern2);
        if (match) {
          insertPoint = updated.indexOf(match[0]) + match[0].length;
          break;
        }
      }
      if (insertPoint < 0) {
        const commentMatch = updated.match(/\n%+\n/);
        if (commentMatch) {
          insertPoint = updated.indexOf(commentMatch[0]);
        }
      }
      if (insertPoint < 0) {
        const lastUsepkgMatch = updated.match(/\\usepackage[^\n]*\n/g);
        if (lastUsepkgMatch && lastUsepkgMatch.length > 0) {
          const lastMatch = lastUsepkgMatch[lastUsepkgMatch.length - 1];
          insertPoint = updated.lastIndexOf(lastMatch) + lastMatch.length;
        }
      }
      if (insertPoint > 0) {
        updated = updated.substring(0, insertPoint) + `\\usepackage{${pkg.name}}
` + updated.substring(insertPoint);
        addedPackages.push(pkg.name);
      }
    }
  }
  if (addedPackages.length > 0) {
    const commentLine = `% Auto-added required packages: ${addedPackages.join(", ")}
`;
    const docClassMatch = updated.match(/\\documentclass[^\n]*\n/);
    if (docClassMatch) {
      const insertIndex = updated.indexOf(docClassMatch[0]) + docClassMatch[0].length;
      updated = updated.substring(0, insertIndex) + commentLine + updated.substring(insertIndex);
    }
  }
  return updated;
}
function ensureSettings(partial) {
  const settings = merge(new ExportToTexSettings(), partial);
  if (!settings.preamble || settings.preamble.trim() === "") {
    settings.preamble = new ExportToTexSettings().preamble;
  } else {
    settings.preamble = ensureValidTemplate(settings.preamble);
  }
  if (settings.preamble) {
    settings.preamble = ensureRequiredPackages(settings.preamble);
  }
  if (settings.postamble) {
    settings.postamble = ensureValidPostamble(settings.postamble);
  }
  if (settings.imagePathSettings === void 0 && partial.fullImagePath !== void 0) {
    settings.imagePathSettings = partial.fullImagePath ? 1 /* FullPath */ : 0 /* RelativeToRoot */;
  }
  return settings;
}

// src/transform/embeds/embedResolver.ts
var import_normalize_path = __toESM(require_normalize_path());
var _EmbedResolver = class {
  constructor(processor, parentFile, node2) {
    this.processor = processor;
    this.parentFile = parentFile;
    this.node = node2;
  }
  failedEmbed() {
    const embedTarget = this.node.attributes.target;
    this.parentFile.message(`Failed to resolve embed ${embedTarget}`, this.node);
    return { type: "inlineCode", value: `Missing ${embedTarget}` };
  }
  resolve() {
    return __async(this, null, function* () {
      const embedTarget = this.node.attributes.target;
      this.parentFile.info(`Resolving embed "${embedTarget}"`, this.node);
      const metadata = this.processor.data("metadata");
      if (!(metadata instanceof import_obsidian.MetadataCache)) {
        throw Error("metadata must be passed to the processor in the form of an obsidian MetadataCache");
      }
      const { file, result, subpath } = this.getTarget(metadata);
      if (file === void 0) {
        return this.failedEmbed();
      }
      switch (file.extension) {
        case "md":
          if (result === null) {
            return this.failedEmbed();
          }
          this.parentFile.info(`Reading embedded file ${file.basename}`, this.node);
          if (!(yield file.vault.adapter.exists(file.path))) {
            this.parentFile.message(`${file.basename} does not exists`, this.node);
            return this.failedEmbed();
          }
          return yield this.processMarkdownEmbed(embedTarget, subpath, file, result);
        default:
          return this.processImageEmbed(embedTarget, subpath, file);
      }
    });
  }
  processMarkdownEmbed(embedTarget, subpath, file, result) {
    return __async(this, null, function* () {
      var _a;
      const fileData = yield file.vault.cachedRead(file);
      const data = fileData.slice(result.start.offset, (_a = result.end) == null ? void 0 : _a.offset);
      this.parentFile.info(`Parsing "${embedTarget}"`, this.node);
      const embedFile = makeVFile(data, file.path, subpath);
      const node2 = this.processor.parse(embedFile);
      const processed = yield this.processor.run(node2, embedFile);
      this.parentFile.messages.push(...embedFile.messages);
      return processed;
    });
  }
  processImageEmbed(embedTarget, subpath, file) {
    this.parentFile.info(`Processing image "${embedTarget}"`, this.node);
    const settings = this.processor.data("settings");
    const imagePath = _EmbedResolver.getImagePath(file, settings);
    return {
      type: "image",
      url: imagePath
    };
  }
  getTarget(metadata) {
    const embedTarget = this.node.attributes.target;
    const { path: path3, subpath } = (0, import_obsidian.parseLinktext)(embedTarget);
    if (this.parentFile.path === void 0) {
      this.parentFile.message(`cannot resolve target of link ${embedTarget} as the path of the embedding file is not available`, this.node);
      return _EmbedResolver.FAILED_TARGET;
    }
    const target = metadata.getFirstLinkpathDest(path3, this.parentFile.path);
    if (target === null) {
      this.parentFile.message(`cannot resolve target of link ${embedTarget}`, this.node);
      return _EmbedResolver.FAILED_TARGET;
    }
    const cache = metadata.getFileCache(target);
    if (cache === null) {
      this.parentFile.message(`cannot access file cache of ${embedTarget}`, this.node);
      return _EmbedResolver.FAILED_TARGET;
    }
    return {
      file: target,
      subpath,
      result: (0, import_obsidian.resolveSubpath)(cache, subpath.trimEnd())
    };
  }
  static getImagePath(file, settings) {
    const adapter = file.vault.adapter;
    const absolutePath = adapter.getFullPath(file.path);
    switch (settings.exportToTex.imagePathSettings) {
      case 0 /* RelativeToRoot */:
        return (0, import_normalize_path.default)(file.path);
      case 1 /* FullPath */:
        return (0, import_normalize_path.default)(absolutePath);
      case 2 /* BaseName */:
        return file.basename;
      case 3 /* RelativeToExport */: {
        throw new Error("Relative to export setting is deprecated");
      }
    }
  }
};
var EmbedResolver = _EmbedResolver;
EmbedResolver.FAILED_TARGET = {
  subpath: "",
  result: null
};

// src/transform/embeds/index.ts
function embed() {
  return (tree, file) => __async(this, null, function* () {
    return yield embedTransformer(this, tree, file);
  });
}
function embedTransformer(processor, tree, file) {
  return __async(this, null, function* () {
    const promises = [];
    visit(tree, { type: "textDirective", name: "embed" }, (node2, index2, parent) => {
      assertEmbedDirective(node2);
      if (parent === void 0)
        throw new Error("found an embed without a parent");
      const resolver2 = new EmbedResolver(processor, file, node2);
      promises.push(resolver2.resolve().then((newNode) => {
        parent.children[index2] = newNode;
      }).catch((reason) => {
        file.message(reason, node2, "embed:error");
        parent.children[index2] = resolver2.failedEmbed();
      }));
    });
    return yield Promise.allSettled(promises).then(() => {
      file.info("All embeds resolved", tree);
    });
  });
}

// src/transform/labels/index.ts
var import_github_slugger = __toESM(require_github_slugger());

// src/transform/labels/labelNodes.ts
var LABEL_REGEX = /^\^\w+$/;
function isLabelText(node2) {
  return is(node2, "text") && node2.value.match(LABEL_REGEX) !== null;
}
function isLabelParagraph(node2) {
  return is(node2, "paragraph") && node2.children.length === 1 && isLabelText(node2.children[0]);
}

// src/transform/labels/linkTarget.ts
var import_obsidian2 = require("obsidian");
function setLinkTargets(labelsMap, tree, file) {
  visit(tree, "wikiLink", (node2) => {
    assertNodeType(node2, "wikiLink");
    if (node2.data.label !== void 0) {
      return;
    }
    if (!node2.value.contains("#")) {
      return;
    }
    const namedFile = toNamedVFile(file);
    const { path: path3, subpath } = (0, import_obsidian2.parseLinktext)(node2.value);
    const key = {
      isHeading: !node2.value.contains("^"),
      path: path3.length > 0 ? path3 : namedFile.stem,
      subpath
    };
    const label4 = labelsMap.get(keyToString(key));
    if (label4 !== null) {
      node2.data.label = label4;
    }
  });
}
function keyToString(key) {
  return `${key.isHeading ? "h" : "b"}:${key.path}:${key.subpath}`;
}

// src/transform/labels/label.ts
function associateLabels(slugger, labelsMap, tree, file) {
  visit(tree, ["heading", "paragraph", "text"], (node2, index2, parent) => {
    const labelData = getLabelData(file, node2, index2, parent);
    if (!labelData)
      return;
    createLabel(slugger, labelsMap, file, labelData);
    if (labelData == null ? void 0 : labelData.removeNode)
      return index2;
  });
}
function createLabel(slugger, labelsMap, file, labelData) {
  const namedFile = toNamedVFile(file);
  const { target: node2, name: subpath } = labelData;
  const key = {
    path: namedFile.stem,
    subpath,
    isHeading: node2.type === "heading"
  };
  if (node2.data === void 0) {
    node2.data = {};
  }
  if (node2.data.label === void 0) {
    node2.data.label = {
      name: slugger.slug(subpath),
      type: node2.type
    };
  }
  labelsMap.set(keyToString(key), node2.data.label);
}
function getLabelData(file, node2, index2, parent) {
  if (is(node2, "heading")) {
    return getHeadingLabel(node2);
  } else if (isLabelParagraph(node2)) {
    return getLabelParagraphData(file, node2, index2, parent);
  } else if (isLabelText(node2)) {
    return getLabelTextData(file, node2, index2, parent);
  }
}
function getHeadingLabel(node2) {
  return {
    name: `#${node2.children.map((c) => c.value).join("")}`,
    target: node2,
    removeNode: false
  };
}
function getLabelParagraphData(file, node2, index2, parent) {
  if (parent === void 0 || index2 === null || index2 === 0) {
    file.message(`Label ${node2.children[0].value} cannot be associated to a block`, node2.children[0]);
    replaceWithComment(node2.children[0].value, node2, index2, parent);
    return;
  }
  parent.children.splice(index2, 1);
  return {
    target: parent.children[index2 - 1],
    name: node2.children[0].value,
    removeNode: true
  };
}
function getLabelTextData(file, node2, index2, parent) {
  if (parent === void 0 || index2 === null || index2 === 0) {
    file.message(`Label ${node2.value} cannot be associated to a block`, node2);
    replaceWithComment(node2.value, node2, index2, parent);
    return;
  }
  parent.children.splice(index2, 1);
  return {
    target: parent.children[index2 - 1],
    name: node2.value,
    removeNode: true
  };
}
function replaceWithComment(text4, node2, index2, parent) {
  if (parent === void 0 || index2 === null)
    return;
  const marker = {
    type: "comment",
    name: text4,
    attributes: "",
    parameters: {},
    node: node2
  };
  parent.children[index2] = marker;
}

// src/transform/labels/index.ts
function labels() {
  const slugger = new import_github_slugger.default();
  const labels3 = /* @__PURE__ */ new Map();
  return (tree, file) => {
    associateLabels(slugger, labels3, tree, file);
    setLinkTargets(labels3, tree, file);
  };
}

// src/compile/getRef.ts
var keyPrefixes = {
  heading: "sec",
  math: "eq",
  image: "fig"
};
function getPrefix(targetType) {
  if (targetType !== void 0 && targetType in keyPrefixes) {
    return keyPrefixes[targetType] + ":";
  }
  return "";
}
function getRef(settings, label4) {
  const { refCommand, generateLabels } = settings;
  if (!generateLabels)
    return "";
  return `\\${refCommand}{${getPrefix(label4.type)}${label4.name}}`;
}
function getLabel(settings, label4) {
  const { generateLabels } = settings;
  if (!generateLabels)
    return "";
  return `\\label{${getPrefix(label4.type)}${label4.name}}`;
}

// src/compile/types/math.ts
var mathEnvironments = [
  "equation",
  "multline",
  "gather",
  "align",
  "flalign",
  "split",
  "alignat"
];
var endRegex = /^\s*\\end{\s*(\w+)\*?\s*}/m;
function displayMath(settings, math2) {
  const { value: value2 } = math2;
  const match = endRegex.exec(value2);
  const { additionalMathEnvironments, defaultToEquation } = settings;
  const label4 = math2.data.label;
  if (match !== null && (mathEnvironments.contains(match[1]) || additionalMathEnvironments.contains(match[1]))) {
    if (label4 !== void 0) {
      return `${value2.slice(0, match.index)}${getLabel(settings, label4)}
${value2.slice(match.index)}`;
    }
    return value2;
  }
  if (defaultToEquation || label4 !== void 0) {
    const labelText = label4 === void 0 ? "" : getLabel(settings, label4);
    return `\\begin{equation}
${value2}${labelText}
\\end{equation}`;
  }
  return `\\[
${value2}
\\]`;
}

// src/compile/visitor.ts
var headingNames = [
  "section",
  "subsection",
  "subsubsection",
  "paragraph",
  "subparagraph"
];
var Visitor = class {
  constructor(settings, file) {
    this._commenting = false;
    this._footnotes = /* @__PURE__ */ new Map();
    this.greekMap = {
      \u03B1: "\\alpha",
      \u03B2: "\\beta",
      \u03B3: "\\gamma",
      \u03B4: "\\delta",
      \u03B5: "\\epsilon",
      \u03B6: "\\zeta",
      \u03B7: "\\eta",
      \u03B8: "\\theta",
      \u03B9: "\\iota",
      \u03BA: "\\kappa",
      \u03BB: "\\lambda",
      \u03BC: "\\mu",
      \u03BD: "\\nu",
      \u03BE: "\\xi",
      \u03BF: "\\omicron",
      \u03C0: "\\pi",
      \u03C1: "\\rho",
      \u03C3: "\\sigma",
      \u03C4: "\\tau",
      \u03C5: "\\upsilon",
      \u03C6: "\\phi",
      \u03C7: "\\chi",
      \u03C8: "\\psi",
      \u03C9: "\\omega",
      \u0391: "\\Alpha",
      \u0392: "\\Beta",
      \u0393: "\\Gamma",
      \u0394: "\\Delta",
      \u0395: "\\Epsilon",
      \u0396: "\\Zeta",
      \u0397: "\\Eta",
      \u0398: "\\Theta",
      \u0399: "\\Iota",
      \u039A: "\\Kappa",
      \u039B: "\\Lambda",
      \u039C: "\\Mu",
      \u039D: "\\Nu",
      \u039E: "\\Xi",
      \u039F: "\\Omicron",
      \u03A0: "\\Pi",
      \u03A1: "\\Rho",
      \u03A3: "\\Sigma",
      \u03A4: "\\Tau",
      \u03A5: "\\Upsilon",
      \u03A6: "\\Phi",
      \u03A7: "\\Chi",
      \u03A8: "\\Psi",
      \u03A9: "\\Omega"
    };
    this.symbolMap = {
      "\u2264": "\\leq",
      "\u2265": "\\geq",
      "\u2260": "\\neq",
      "\u2248": "\\approx",
      "\u2261": "\\equiv",
      "\u221E": "\\infty",
      "\u2211": "\\sum",
      "\u220F": "\\prod",
      "\u222B": "\\int",
      "\u222E": "\\oint",
      "\u221A": "\\sqrt",
      "\u2202": "\\partial",
      "\u2207": "\\nabla",
      "\u2206": "\\Delta",
      "\u2208": "\\in",
      "\u2209": "\\notin",
      "\u2282": "\\subset",
      "\u2286": "\\subseteq",
      "\u2283": "\\supset",
      "\u2287": "\\supseteq",
      "\u2229": "\\cap",
      "\u222A": "\\cup",
      "\u2227": "\\wedge",
      "\u2228": "\\vee",
      "\xAC": "\\neg",
      "\u2200": "\\forall",
      "\u2203": "\\exists",
      "\u21D2": "\\implies",
      "\u21D4": "\\iff",
      "\u2192": "\\to",
      "\u2190": "\\leftarrow",
      "\u2191": "\\uparrow",
      "\u2193": "\\downarrow",
      "\u2194": "\\leftrightarrow",
      "\xB1": "\\pm",
      "\xD7": "\\times",
      "\xF7": "\\div",
      "\u22C5": "\\cdot",
      "\xB0": "\\degree",
      "\u2032": "\\prime",
      "\u2033": "\\dprime",
      "\u2034": "\\trprime"
    };
    this._tables = [];
    this._figures = [];
    this._markdownSource = "";
    this._itemsInOrder = [];
    this._tableCounter = 0;
    this._figureCounter = 0;
    this._output = [];
    this._settings = settings;
    this._file = file;
    this._markdownSource = file.value;
  }
  escapeRegExp(string3) {
    return string3.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  getTables() {
    return this._tables;
  }
  getFigures() {
    return this._figures;
  }
  getItemsInOrder() {
    return this._itemsInOrder.map((item) => ({
      type: item.type,
      displayIndex: item.displayIndex,
      data: item.type === "table" ? this._tables[item.displayIndex] : this._figures[item.displayIndex]
    }));
  }
  extractNodeSource(node2) {
    var _a, _b, _c;
    if (!node2.position || !node2.position.start || !node2.position.end) {
      return "";
    }
    const { start, end } = node2.position;
    const sourceLines = this._markdownSource.split("\n");
    const startLine = start.line - 1;
    const endLine = end.line - 1;
    const startCol = start.column - 1;
    const endCol = end.column - 1;
    let result = "";
    if (startLine === endLine) {
      result = ((_a = sourceLines[startLine]) == null ? void 0 : _a.substring(startCol, endCol)) || "";
    } else {
      result = ((_b = sourceLines[startLine]) == null ? void 0 : _b.substring(startCol)) || "";
      for (let i = startLine + 1; i < endLine; i++) {
        result += "\n" + (sourceLines[i] || "");
      }
      result += "\n" + (((_c = sourceLines[endLine]) == null ? void 0 : _c.substring(0, endCol)) || "");
    }
    return result.trim();
  }
  toString() {
    return this._output.join("");
  }
  visit(node2) {
    switch (node2.type) {
      case "root":
        this.visitChildren(node2);
        break;
      case "heading":
        this.visitHeading(node2);
        break;
      case "blockquote":
        this.visitBlockquote(node2);
        break;
      case "paragraph":
        this.visitParagraph(node2);
        break;
      case "image":
        this.visitImage(node2);
        break;
      case "table":
        this.visitTable(node2);
        break;
      case "tableCell":
        this.visitTableCell(node2);
        break;
      case "inlineMath":
        this.emit(`$${node2.value}$`);
        break;
      case "math":
        this.visitMath(node2);
        break;
      case "inlineCode":
        this.emit(`\\verb{${node2.value}}`);
        break;
      case "code":
        this.visitCode(node2);
        break;
      case "list":
        this.visitList(node2);
        break;
      case "listItem":
        this.visitListItem(node2);
        break;
      case "wikiLink":
        this.visitWikiLink(node2);
        break;
      case "link":
        this.visitLink(node2);
        break;
      case "emphasis":
        this.commandChildren("emph", node2);
        break;
      case "strong":
        this.commandChildren("textbf", node2);
        break;
      case "text":
        this.visitText(node2);
        break;
      case "break":
        this.emit("\\\\\n");
        break;
      case "thematicBreak":
        this.emit("\n\\hrulefill\n");
        break;
      case "footnoteDefinition":
        this.visitFootnoteDefinition(node2);
        break;
      case "footnoteReference":
        this.visitFootnoteReference(node2);
        break;
      case "html":
        this.visitHtml(node2);
        break;
      case "yaml":
        break;
      default:
        this.visitUnknown(node2);
    }
  }
  visitHeading(heading) {
    if (heading.depth > 5) {
      return;
    }
    const cmd = headingNames[heading.depth - 1] + (this._settings.numberedSections ? "" : "*");
    this.commandChildren(cmd, heading);
    this.label(heading);
  }
  visitBlockquote(blockquote) {
    this.begin("blockquote");
    this.visitChildren(blockquote);
    this.end("blockquote");
  }
  visitParagraph(paragraph) {
    this.emit("\n");
    this.visitChildren(paragraph);
    this.emit("\n");
  }
  visitImage(image) {
    const figureIndex = this._figures.length;
    const caption = image.alt || image.title || "Figure";
    let imageSource = this.extractNodeSource(image);
    if (!imageSource && (image.url || image.alt)) {
      imageSource = `![${image.alt || ""}](${image.url || ""})`;
    }
    this._figures.push({
      index: figureIndex,
      alt: image.alt || "",
      title: image.title || void 0,
      source: imageSource
    });
    this._itemsInOrder.push({
      type: "figure",
      displayIndex: this._figureCounter++
    });
    if (this._settings.generateCaptions) {
      this.emit(`\\begin{figure}[${this._settings.figurePosition}]
`);
      this.emit("\\centering\n");
      this.emit("\\includegraphics[width=0.8\\textwidth,keepaspectratio]{");
      this.emit(image.url);
      this.emit("}\n");
      this.emit(`\\caption{\\sffamily ${caption}}
`);
      this.label(image);
      this.emit("\\end{figure}\n");
    } else {
      this.begin("center");
      this.emit("\\includegraphics[width=0.9\\textwidth,keepaspectratio]{");
      this.emit(image.url);
      this.emit("}\n");
      this.end("center");
    }
  }
  visitTable(table) {
    const columns = table.children[0].children.length;
    const rows = table.children.length;
    let tableSource = this.extractNodeSource(table);
    if (!tableSource) {
      const headerRow = table.children[0];
      const headerCells = headerRow.children.map(() => "Header").join(" | ");
      const separator = headerRow.children.map(() => "---").join(" | ");
      tableSource = `| ${headerCells} |
| ${separator} |
| ... ${rows - 1} more rows ... |`;
    }
    const tableIndex = this._tables.length;
    this._tables.push({
      index: tableIndex,
      rows,
      cols: columns,
      source: tableSource
    });
    this._itemsInOrder.push({
      type: "table",
      displayIndex: this._tableCounter++
    });
    if (rows > 50) {
      this._file.message(`Large table detected (${rows} rows). Export may be slow or cause freezing.`, table);
    }
    const useLongtable = rows > 30;
    const useSmallFont = columns >= 6;
    if (useLongtable) {
      if (rows > 50 && columns <= 4) {
        this.emit("\\clearpage\n");
        const rowsPerTable = 30;
        let currentIndex = 1;
        if (useSmallFont) {
          this.emit("{\\small\n");
          this.emit("\\setlength{\\tabcolsep}{2pt}\n");
        }
        const columnLayout = 2;
        const minipageWidth = 0.48;
        const minipageHeightMm = 115;
        let rowCounter = 0;
        while (currentIndex < rows) {
          if (rowCounter % columnLayout === 0) {
            this.emit("\\noindent\n");
          }
          const endIndex = Math.min(currentIndex + rowsPerTable, rows);
          const subtable = {
            type: "table",
            children: [
              table.children[0],
              ...table.children.slice(currentIndex, endIndex)
            ]
          };
          const subcolumns = subtable.children[0].children.length;
          const colSpec2 = "l ".repeat(subcolumns).trim();
          this.emit(`\\begin{minipage}[t][${minipageHeightMm}mm][t]{${minipageWidth}\\textwidth}
`);
          this.emit("\\setlength{\\parskip}{0pt}\n");
          this.emit("\\setlength{\\baselineskip}{10pt}\n");
          this.emit(`\\begin{longtable}[c]{${colSpec2}}
`);
          if (rowCounter === 0 && this._settings.generateCaptions) {
            this.emit("\\caption{\\sffamily Table}\\\\\n");
            this.label(table);
          }
          this.emit("\\toprule\n");
          subtable.children.forEach((row, index2) => {
            this.visitTableRowWithSummaryDetection(row, index2, subtable.children.length, true);
            this.emit("\\\\\n");
            if (index2 === 0) {
              this.emit("\\midrule\n");
              this.emit("\\endhead\n");
            }
          });
          this.emit("\\bottomrule\n");
          this.emit("\\end{longtable}\n");
          this.emit("\\end{minipage}\n");
          const isLastInRow = (rowCounter + 1) % columnLayout === 0;
          const isLastTable = endIndex >= rows;
          if (isLastInRow && !isLastTable) {
            this.emit("\\par\\vspace{1em}\n");
          } else if (!isLastInRow) {
            this.emit("\\hfill\n");
          }
          currentIndex = endIndex;
          rowCounter++;
        }
        if (useSmallFont) {
          this.emit("}\n");
        }
        return;
      }
      const colSpec = "l ".repeat(columns).trim();
      if (useSmallFont) {
        this.emit("{\\small\n");
        this.emit("\\setlength{\\tabcolsep}{2pt}\n");
      }
      this.emit(`\\begin{longtable}[c]{${colSpec}}
`);
      if (this._settings.generateCaptions) {
        this.emit("\\caption{\\sffamily Table}\\\\\n");
        this.label(table);
      }
      this.emit("\\toprule\n");
      table.children.forEach((row, index2) => {
        this.visitTableRowWithSummaryDetection(row, index2, table.children.length, true);
        this.emit("\\\\\n");
        if (index2 === 0) {
          this.emit("\\midrule\n");
          this.emit("\\endhead\n");
        }
      });
      this.emit("\\bottomrule\n");
      this.emit("\\end{longtable}\n");
      if (useSmallFont) {
        this.emit("}\n");
      }
    } else {
      this.emit(`\\begin{table}[${this._settings.tablePosition}]
`);
      this.emit("\\centering\n");
      if (this._settings.generateCaptions) {
        this.emit("\\caption{\\sffamily Table}\n");
        this.label(table);
      }
      if (useSmallFont) {
        this.emit("{\\small\n");
        this.emit("\\setlength{\\tabcolsep}{2pt}\n");
      }
      this.emit(`\\begin{tabularx}{\\textwidth}{${"X".repeat(columns)}}
`);
      this.emit("\\toprule\n");
      table.children.forEach((row, index2) => {
        this.visitTableRowWithSummaryDetection(row, index2, table.children.length, false);
        this.emit("\\\\\n");
        if (index2 === 0)
          this.emit("\\midrule\n");
      });
      this.emit("\\bottomrule\n");
      this.emit("\\end{tabularx}\n");
      if (useSmallFont) {
        this.emit("}\n");
      }
      this.emit("\\end{table}\n");
    }
  }
  visitTableRow(row) {
    const cells = row.children.length;
    row.children.forEach((cell, index2) => {
      this.visit(cell);
      if (index2 < cells - 1)
        this.emit("&");
    });
  }
  visitTableCell(cell) {
    const originalOutput = this._output;
    this._output = [];
    this.visitChildren(cell);
    let content3 = this._output.join("").replace(/\n/g, " ");
    content3 = content3.replace(/\\\\/g, "\\newline");
    this._output = originalOutput;
    this.emit(content3);
  }
  visitMath(math2) {
    this.emit(displayMath(this._settings, math2));
  }
  visitCode(code2) {
    this.emit(`% ${code2.lang} ${code2.meta}
`);
    this.begin("verbatim");
    this.emit(code2.value);
    this.emit("\n");
    this.end("verbatim");
  }
  visitList(list2) {
    const listEnvironment = list2.ordered ? "enumerate" : "itemize";
    this.begin(listEnvironment);
    this.visitChildren(list2);
    this.end(listEnvironment);
  }
  visitListItem(listItem2) {
    this.emit("\\item ");
    this.visitChildren(listItem2);
  }
  visitWikiLink(wikiLink2) {
    const { alias } = wikiLink2.data;
    const label4 = wikiLink2.data.label;
    const fallbackText = !wikiLink2.value.contains("#") || label4 === void 0 ? wikiLink2.value : "";
    this.emit((alias != null ? alias : fallbackText).replaceAll("#", ""));
    this.reference(wikiLink2);
  }
  visitLink(link) {
    this.emit(`\\href{${link.url}}{`);
    this.visitChildren(link);
    this.emit("}");
  }
  visitText(text4) {
    let value2 = text4.value;
    value2 = value2.replace(//g, "\uFF0C");
    value2 = value2.replace(//g, "\uFF0E");
    value2 = value2.replace(/\\/g, "\\textbackslash{}");
    value2 = value2.replace(/%/g, "\\%");
    value2 = value2.replace(/~/g, "\\textasciitilde{}");
    value2 = value2.replace(/&/g, "\\&");
    value2 = value2.replace(/_/g, "\\_");
    value2 = value2.replace(/\^/g, "\\textasciicircum{}");
    value2 = value2.replace(/\$/g, "\\$");
    value2 = value2.replace(/#/g, "\\#");
    value2 = value2.replace(/\{/g, "\\{");
    value2 = value2.replace(/\}/g, "\\}");
    for (const [greek, latex] of Object.entries(this.greekMap)) {
      value2 = value2.replace(new RegExp(greek, "g"), latex + "{}");
    }
    for (const [symbol, latex] of Object.entries(this.symbolMap)) {
      value2 = value2.replace(new RegExp(this.escapeRegExp(symbol), "g"), latex + "{}");
    }
    this.emit(value2);
  }
  visitChildren(node2) {
    node2.children.forEach((node3) => this.visit(node3));
  }
  visitUnknown(node2) {
    this._file.message(`Encountered unknown node type ${node2.type}`, node2);
    this.comment(() => {
      this.emit(`Unknown Node :: ${node2.type}
`);
      if (is(node2, (x) => "value" in x)) {
        this.emit(node2.value);
      } else if (isParent(node2)) {
        this.visitChildren(node2);
      }
    });
  }
  emit(content3) {
    if (this._commenting && this._output[this._output.length - 1].endsWith("\n"))
      this._output.push("%");
    this._output.push(content3);
  }
  comment(callback) {
    const previous5 = this._commenting;
    this._commenting = true;
    callback();
    this._commenting = previous5;
  }
  command(cmd, callback) {
    this.emit(`\\${cmd}{`);
    callback();
    this.emit("}");
  }
  commandChildren(cmd, node2) {
    this.command(cmd, () => this.visitChildren(node2));
  }
  begin(name) {
    this.emit(`\\begin{${name}}
`);
  }
  end(name) {
    this.emit(`\\end{${name}}
`);
  }
  label(node2) {
    var _a;
    if (((_a = node2 == null ? void 0 : node2.data) == null ? void 0 : _a.label) === void 0)
      return;
    this.emit(getLabel(this._settings, node2.data.label));
  }
  reference(node2) {
    var _a;
    if (((_a = node2.data) == null ? void 0 : _a.label) === void 0)
      return;
    this.emit(getRef(this._settings, node2.data.label));
  }
  visitFootnoteDefinition(node2) {
    this._footnotes.set(node2.identifier, node2);
  }
  visitFootnoteReference(node2) {
    const def = this._footnotes.get(node2.identifier);
    if (def) {
      this.emit("\\footnote{");
      this.visitChildren(def);
      this.emit("}");
    } else {
      this.emit(`[^${node2.identifier}]`);
    }
  }
  visitHtml(node2) {
    let html = node2.value;
    html = html.replace(/<br\s*\/?>/gi, "\\\\");
    this.emit(html);
  }
  extractCellText(cell) {
    const originalOutput = this._output;
    this._output = [];
    this.visitChildren(cell);
    const text4 = this._output.join("").trim();
    this._output = originalOutput;
    return text4;
  }
  isSummaryRow(rowText) {
    const summaryKeywords = [
      "\u5408\u8A08",
      "\u5E73\u5747",
      "\u5C0F\u8A08",
      "\u8A08",
      "\u7DCF\u8A08",
      "\u7DCF\u548C",
      "\u5408\u7B97",
      "\u5E73\u5747\u5024",
      "\u4E2D\u592E\u5024",
      "total",
      "average",
      "sum",
      "mean",
      "subtotal",
      "grand total"
    ];
    const lowerText = rowText.toLowerCase();
    return summaryKeywords.some((keyword) => rowText.includes(keyword) || lowerText.includes(keyword.toLowerCase()));
  }
  visitTableRowWithSummaryDetection(row, rowIndex, totalRows, isLongtable = false) {
    if (row.children.length > 0) {
      const firstCellText = this.extractCellText(row.children[0]);
      if (rowIndex > 0 && this.isSummaryRow(firstCellText)) {
        if (isLongtable) {
          this.emit("\\hline\n");
        } else {
          this.emit("\\hline\n");
        }
      }
    }
    const cells = row.children.length;
    row.children.forEach((cell, index2) => {
      this.visit(cell);
      if (index2 < cells - 1)
        this.emit("&");
    });
  }
};

// src/compile/texCompiler.ts
function texCompiler() {
  this.Compiler = (tree, file) => {
    const settings = this.data("settings");
    const visitor = new Visitor(settings.exportToTex, file);
    visitor.visit(tree);
    if (!file.data) {
      file.data = {};
    }
    file.data.visitor = visitor;
    return visitor.toString();
  };
}

// src/processor.ts
var markdownToTex = unified().use(remarkParse).use(remarkGfm).use(remarkMath).use(remarkFrontmatter).use(remarkDirective).use(remarkFootnotes).use(index_umd_default, {
  aliasDivider: "|"
}).use(embed).use(labels).use(texCompiler).freeze();

// node_modules/.pnpm/ansi-regex@6.2.2/node_modules/ansi-regex/index.js
function ansiRegex({ onlyFirst = false } = {}) {
  const ST = "(?:\\u0007|\\u001B\\u005C|\\u009C)";
  const osc = `(?:\\u001B\\][\\s\\S]*?${ST})`;
  const csi = "[\\u001B\\u009B][[\\]()#;?]*(?:\\d{1,4}(?:[;:]\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]";
  const pattern = `${osc}|${csi}`;
  return new RegExp(pattern, onlyFirst ? void 0 : "g");
}

// node_modules/.pnpm/strip-ansi@7.1.2/node_modules/strip-ansi/index.js
var regex = ansiRegex();
function stripAnsi(string3) {
  if (typeof string3 !== "string") {
    throw new TypeError(`Expected a \`string\`, got \`${typeof string3}\``);
  }
  return string3.replace(regex, "");
}

// node_modules/.pnpm/string-width@5.1.2/node_modules/string-width/index.js
var import_eastasianwidth = __toESM(require_eastasianwidth(), 1);
var import_emoji_regex = __toESM(require_emoji_regex(), 1);
function stringWidth(string3, options = {}) {
  if (typeof string3 !== "string" || string3.length === 0) {
    return 0;
  }
  options = __spreadValues({
    ambiguousIsNarrow: true
  }, options);
  string3 = stripAnsi(string3);
  if (string3.length === 0) {
    return 0;
  }
  string3 = string3.replace((0, import_emoji_regex.default)(), "  ");
  const ambiguousCharacterWidth = options.ambiguousIsNarrow ? 1 : 2;
  let width = 0;
  for (const character of string3) {
    const codePoint = character.codePointAt(0);
    if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) {
      continue;
    }
    if (codePoint >= 768 && codePoint <= 879) {
      continue;
    }
    const code2 = import_eastasianwidth.default.eastAsianWidth(character);
    switch (code2) {
      case "F":
      case "W":
        width += 2;
        break;
      case "A":
        width += ambiguousCharacterWidth;
        break;
      default:
        width += 1;
    }
  }
  return width;
}

// node_modules/.pnpm/vfile-statistics@2.0.1/node_modules/vfile-statistics/lib/index.js
function statistics(value2) {
  const result = { true: 0, false: 0, null: 0 };
  if (value2) {
    if (Array.isArray(value2)) {
      list2(value2);
    } else {
      one2(value2);
    }
  }
  return {
    fatal: result.true,
    nonfatal: result.false + result.null,
    warn: result.false,
    info: result.null,
    total: result.true + result.false + result.null
  };
  function list2(value3) {
    let index2 = -1;
    while (++index2 < value3.length) {
      one2(value3[index2]);
    }
  }
  function one2(value3) {
    if ("messages" in value3)
      return list2(value3.messages);
    const field = String(value3.fatal === void 0 || value3.fatal === null ? null : Boolean(value3.fatal));
    result[field]++;
  }
}

// node_modules/.pnpm/vfile-sort@3.0.1/node_modules/vfile-sort/lib/index.js
var severities = { true: 2, false: 1, null: 0, undefined: 0 };
function sort(file) {
  file.messages.sort(comparator);
  return file;
}
function comparator(a, b) {
  return check(a, b, "line") || check(a, b, "column") || severities[String(b.fatal)] - severities[String(a.fatal)] || compare(a, b, "source") || compare(a, b, "ruleId") || compare(a, b, "reason") || 0;
}
function check(a, b, field) {
  return (a[field] || 0) - (b[field] || 0);
}
function compare(a, b, field) {
  return String(a[field] || "").localeCompare(b[field] || "");
}

// node_modules/.pnpm/vfile-reporter@7.0.5/node_modules/vfile-reporter/lib/color.browser.js
var color2 = false;

// node_modules/.pnpm/vfile-reporter@7.0.5/node_modules/vfile-reporter/lib/platform.browser.js
var platform = "darwin";

// node_modules/.pnpm/vfile-reporter@7.0.5/node_modules/vfile-reporter/lib/index.js
var own6 = {}.hasOwnProperty;
var chars = platform === "win32" ? { error: "\xD7", warning: "\u203C" } : { error: "\u2716", warning: "\u26A0" };
var labels2 = {
  true: "error",
  false: "warning",
  null: "info",
  undefined: "info"
};
function reporter(files, options) {
  if (!files) {
    return "";
  }
  if ("name" in files && "message" in files) {
    return String(files.stack || files);
  }
  const options_ = options || {};
  if (Array.isArray(files)) {
    return format(transform(files, options_), false, options_);
  }
  return format(transform([files], options_), true, options_);
}
function transform(files, options) {
  const rows = [];
  const all2 = [];
  const sizes = { place: 0, label: 0, reason: 0, ruleId: 0, source: 0 };
  let index2 = -1;
  while (++index2 < files.length) {
    const messages2 = sort({ messages: [...files[index2].messages] }).messages;
    const messageRows = [];
    let offset = -1;
    while (++offset < messages2.length) {
      const message = messages2[offset];
      if (!options.silent || message.fatal) {
        all2.push(message);
        const row = {
          place: stringifyPosition(message.position ? message.position.end.line && message.position.end.column ? message.position : message.position.start : void 0),
          label: labels2[String(message.fatal)],
          reason: (message.stack || message.message) + (options.verbose && message.note ? "\n" + message.note : ""),
          ruleId: message.ruleId || "",
          source: message.source || ""
        };
        let key;
        for (key in row) {
          if (own6.call(row, key)) {
            sizes[key] = Math.max(size(row[key]), sizes[key] || 0);
          }
        }
        messageRows.push(row);
      }
    }
    if (!options.quiet && !options.silent || messageRows.length > 0) {
      rows.push({ type: "file", file: files[index2], stats: statistics(messages2) }, ...messageRows);
    }
  }
  return { rows, stats: statistics(all2), sizes };
}
function format(map2, one2, options) {
  const enabled = options.color === void 0 || options.color === null ? color2 : options.color;
  const lines = [];
  let index2 = -1;
  while (++index2 < map2.rows.length) {
    const row = map2.rows[index2];
    if ("type" in row) {
      const stats2 = row.stats;
      let line = row.file.history[0] || options.defaultName || "<stdin>";
      line = one2 && !options.defaultName && !row.file.history[0] ? "" : (enabled ? "\x1B[4m" + (stats2.fatal ? "\x1B[31m" : stats2.total ? "\x1B[33m" : "\x1B[32m") + line + "\x1B[39m\x1B[24m" : line) + (row.file.stored && row.file.path !== row.file.history[0] ? " > " + row.file.path : "");
      if (!stats2.total) {
        line = (line ? line + ": " : "") + (row.file.stored ? enabled ? "\x1B[33mwritten\x1B[39m" : "written" : "no issues found");
      }
      if (line) {
        if (index2 && !("type" in map2.rows[index2 - 1])) {
          lines.push("");
        }
        lines.push(line);
      }
    } else {
      let reason = row.reason;
      const match = /\r?\n|\r/.exec(reason);
      let rest;
      if (match) {
        rest = reason.slice(match.index);
        reason = reason.slice(0, match.index);
      } else {
        rest = "";
      }
      lines.push(("  " + " ".repeat(map2.sizes.place - size(row.place)) + row.place + "  " + (enabled ? (row.label === "error" ? "\x1B[31m" : "\x1B[33m") + row.label + "\x1B[39m" : row.label) + " ".repeat(map2.sizes.label - size(row.label)) + "  " + reason + " ".repeat(map2.sizes.reason - size(reason)) + "  " + row.ruleId + " ".repeat(map2.sizes.ruleId - size(row.ruleId)) + "  " + (row.source || "")).replace(/ +$/, "") + rest);
    }
  }
  const stats = map2.stats;
  if (stats.fatal || stats.warn) {
    let line = "";
    if (stats.fatal) {
      line = (enabled ? "\x1B[31m" + chars.error + "\x1B[39m" : chars.error) + " " + stats.fatal + " " + (labels2.true + (stats.fatal === 1 ? "" : "s"));
    }
    if (stats.warn) {
      line = (line ? line + ", " : "") + (enabled ? "\x1B[33m" + chars.warning + "\x1B[39m" : chars.warning) + " " + stats.warn + " " + (labels2.false + (stats.warn === 1 ? "" : "s"));
    }
    if (stats.total !== stats.fatal && stats.total !== stats.warn) {
      line = stats.total + " messages (" + line + ")";
    }
    lines.push("", line);
  }
  return lines.join("\n");
}
function size(value2) {
  const match = /\r?\n|\r/.exec(value2);
  return stringWidth(match ? value2.slice(0, match.index) : value2);
}

// src/texPrinter.ts
var TeXPrinter = class {
  constructor(app, settings, exportPath) {
    this.app = app;
    this.settings = settings;
    this.exportPath = exportPath;
  }
  extractTemplateKeys(template) {
    const keys2 = /* @__PURE__ */ new Set();
    const regex2 = /\{\{(\w+)\}\}/g;
    let match;
    while ((match = regex2.exec(template)) !== null) {
      keys2.add(match[1]);
    }
    return Array.from(keys2);
  }
  replaceTemplate(template, frontmatter2) {
    return template.replace(/\{\{(\w+)\}\}/g, (match, key) => {
      const value2 = frontmatter2[key];
      if (value2 !== void 0) {
        return value2.toString().replace(/[&%$#_{}[\]]/g, "\\$&").replace(/\\/g, "\\textbackslash{}");
      }
      if (key === "date") {
        return new Date().toISOString().split("T")[0];
      } else {
        return "undefined";
      }
    });
  }
  process(vfile2) {
    return __async(this, null, function* () {
      const output = yield markdownToTex().data("settings", {
        exportToTex: this.settings
      }).data("metadata", this.app.metadataCache).process(vfile2);
      return output.toString();
    });
  }
  getTablesAndFigures(vfile2) {
    var _a;
    const visitor = (_a = vfile2.data) == null ? void 0 : _a.visitor;
    if (!visitor) {
      return { tables: [], figures: [], itemsInOrder: [] };
    }
    return {
      tables: visitor.getTables(),
      figures: visitor.getFigures(),
      itemsInOrder: visitor.getItemsInOrder()
    };
  }
  toTex(vfile2) {
    return __async(this, null, function* () {
      return this.toTexWithFrontmatter(vfile2, {});
    });
  }
  toTexWithFrontmatter(vfile2, overrideFrontmatter) {
    return __async(this, null, function* () {
      var _a, _b;
      console.groupCollapsed("export-to-tex");
      let tex = yield this.process(vfile2);
      console.log(reporter(vfile2));
      if (this.settings.compressNewlines) {
        console.log("Compressing newlines");
        tex = TeXPrinter.compressNewlines(tex);
      }
      let frontmatter2 = {};
      if (overrideFrontmatter && Object.keys(overrideFrontmatter).length > 0) {
        frontmatter2 = __spreadValues({}, overrideFrontmatter);
      } else {
        const fileFrontmatter = ((_a = this.app.metadataCache.getFileCache(this.app.vault.getAbstractFileByPath(vfile2.path))) == null ? void 0 : _a.frontmatter) || {};
        frontmatter2 = __spreadValues({}, fileFrontmatter);
      }
      if (!frontmatter2.title) {
        const fileName = ((_b = vfile2.path.split("/").pop()) == null ? void 0 : _b.replace(/\.md$/, "")) || "Untitled";
        frontmatter2.title = fileName;
      }
      let preamble = this.settings.preamble;
      let postamble = this.settings.postamble;
      if (!preamble.includes("\\documentclass")) {
        preamble = "\\documentclass{article}\n" + preamble;
      }
      if (this.settings.generateCaptions) {
        let packages = "";
        if ((this.settings.figurePosition.includes("H") || this.settings.figurePosition.includes("h") || this.settings.tablePosition.includes("H") || this.settings.tablePosition.includes("h")) && !preamble.includes("\\usepackage{float}")) {
          packages += "\\usepackage{float}\n";
        }
        if ((this.settings.figurePosition.includes("!") || this.settings.tablePosition.includes("!")) && !preamble.includes("\\usepackage{here}")) {
          packages += "\\usepackage{here}\n";
        }
        if (packages) {
          const docClassMatch = preamble.match(/^(\\documentclass[^}]*}\s*)/);
          if (docClassMatch) {
            preamble = docClassMatch[1] + packages + preamble.slice(docClassMatch[1].length);
          } else {
            preamble = packages + preamble;
          }
        }
      }
      preamble = this.replaceTemplate(preamble, frontmatter2);
      if (frontmatter2 && frontmatter2.title && typeof frontmatter2.title === "string" && frontmatter2.title.trim()) {
        preamble += "\n\\maketitle";
      }
      tex = preamble + tex + this.replaceTemplate(postamble, frontmatter2);
      console.groupEnd();
      return tex;
    });
  }
  static compressNewlines(tex) {
    const lines = tex.split("\n");
    const output = [];
    let wasEmpty = false;
    for (const line of lines) {
      if (line === "") {
        wasEmpty = true;
        continue;
      }
      if (wasEmpty) {
        output.push("");
        wasEmpty = false;
      }
      output.push(line);
    }
    return output.join("\n");
  }
};

// src/plugin/settingsTabs.ts
var import_obsidian3 = require("obsidian");

// src/i18n/translations.ts
var translations = {
  en: {
    settings: {
      title: "Settings for exporting to TeX",
      generateLabels: {
        name: "Generate labels and refs",
        desc: "Automatically generate TeX labels and refs for blocks and headings?"
      },
      refCommand: {
        name: "Ref command",
        desc: "Command to use when converting links to headings/blocks to refs."
      },
      numberedSections: {
        name: "Numbered sections",
        desc: "When enabled emit headers as \\section{...}. When disabled instead use \\section*{...}"
      },
      compressNewlines: {
        name: "Compress newlines",
        desc: "Reduce any instance of 2 or more blank lines to a single blank line"
      },
      preamble: {
        name: "Preamble",
        desc: "Text to insert at the beginning of the exported TeX file. Use {{key}} to reference frontmatter variables."
      },
      postamble: {
        name: "Postamble",
        desc: "Text to insert at the end of the exported TeX file. Use {{key}} to reference frontmatter variables."
      },
      generateCaptions: {
        name: "Generate captions for images and tables",
        desc: "Automatically generate captions for images and tables"
      },
      figurePosition: {
        name: "Figure position specifier",
        desc: "Position specifier for figures (e.g., h, t, b, p, H)"
      },
      tablePosition: {
        name: "Table position specifier",
        desc: "Position specifier for tables (e.g., h, t, b, p, H)"
      },
      askForFrontmatter: {
        name: "Ask for missing frontmatter",
        desc: "Show a dialog to add missing frontmatter fields before export"
      },
      askForCaptions: {
        name: "Ask for table/figure captions",
        desc: "Show a dialog to input captions for tables and figures before export"
      },
      askForExportPath: {
        name: "Ask for export path (Desktop)",
        desc: "Prompt to choose export location each time (only on Desktop). When disabled, exports to same directory as markdown file with {filename}_{date}.tex"
      },
      resetButton: "Reset to default",
      resetConfirm: "Reset settings to default?"
    },
    modals: {
      frontmatter: {
        title: "Edit Frontmatter Fields",
        description: "Update or add frontmatter fields:",
        saveToMarkdown: "Save to Markdown file",
        saveToMarkdownDesc: "Update the frontmatter in the Markdown file",
        ok: "OK",
        cancel: "Cancel"
      },
      caption: {
        title: "Add Captions",
        noItems: "No tables or figures found.",
        items: "Items",
        preview: "Preview:",
        imageInfo: "Image Info:",
        path: "Path:",
        altText: "Alt text:",
        noImagePath: "No image path",
        noAltText: "No alt text",
        captionLabel: "Caption",
        captionPlaceholder: 'E.g., "Comparison of results"',
        ok: "OK",
        cancel: "Cancel"
      },
      overwrite: {
        title: "File already exists",
        message: 'A file named "{0}" already exists. Do you want to overwrite it?',
        overwrite: "Overwrite",
        cancel: "Cancel"
      }
    },
    notices: {
      exported: "Tex exported to {0}",
      exportedToClipboard: "Tex exported to clipboard",
      overwritten: "Tex file overwritten: {0}",
      frontmatterUpdated: "Frontmatter updated in Markdown file",
      frontmatterAdded: "Frontmatter added to Markdown file",
      frontmatterUpdateFailed: "Failed to update frontmatter in Markdown file"
    }
  },
  ja: {
    settings: {
      title: "Export to TeX \u306E\u8A2D\u5B9A",
      generateLabels: {
        name: "\u30E9\u30D9\u30EB\u3068\u53C2\u7167\u3092\u751F\u6210\u3059\u308B",
        desc: "\u30D6\u30ED\u30C3\u30AF\u3068\u898B\u51FA\u3057\u306ETeX \u30E9\u30D9\u30EB\u3068\u53C2\u7167\u3092\u81EA\u52D5\u751F\u6210\u3057\u307E\u3059\u3002"
      },
      refCommand: {
        name: "\u53C2\u7167\u30B3\u30DE\u30F3\u30C9",
        desc: "\u898B\u51FA\u3057/\u30D6\u30ED\u30C3\u30AF\u3078\u306E\u30EA\u30F3\u30AF\u3092\u53C2\u7167\u306B\u5909\u63DB\u3059\u308B\u969B\u306B\u4F7F\u7528\u3059\u308B\u30B3\u30DE\u30F3\u30C9\u3067\u3059\u3002"
      },
      numberedSections: {
        name: "\u30BB\u30AF\u30B7\u30E7\u30F3\u756A\u53F7\u4ED8\u3051\u3092\u6709\u52B9\u5316",
        desc: "\u6709\u52B9\u306B\u3059\u308B\u3068\\section{...} \u3068\u3057\u3066\u898B\u51FA\u3057\u3092\u51FA\u529B\u3057\u3001\u7121\u52B9\u3060\u3068 \\section*{...} \u3068\u3057\u3066\u51FA\u529B\u3057\u307E\u3059\u3002"
      },
      compressNewlines: {
        name: "\u6539\u884C\u3092\u5727\u7E2E\u3059\u308B",
        desc: "2\u884C\u4EE5\u4E0A\u306E\u7A7A\u767D\u884C\u30921\u884C\u306B\u3057\u307E\u3059\u3002"
      },
      preamble: {
        name: "\u524D\u65B9\u30C6\u30F3\u30D7\u30EC\u30FC\u30C8",
        desc: "\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u3055\u308C\u305FTeX \u30D5\u30A1\u30A4\u30EB\u306E\u59CB\u307E\u308A\u306B\u633F\u5165\u3059\u308B\u30C6\u30AD\u30B9\u30C8\u3067\u3059\u3002{{key}} \u3092\u4F7F\u7528\u3057\u3066\u30D5\u30ED\u30F3\u30C8\u30DE\u30BF\u30FC\u5909\u6570\u3092\u53C2\u7167\u3067\u304D\u307E\u3059\u3002"
      },
      postamble: {
        name: "\u5F8C\u65B9\u30C6\u30F3\u30D7\u30EC\u30FC\u30C8",
        desc: "\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u3055\u308C\u305FTeX \u30D5\u30A1\u30A4\u30EB\u306E\u7D42\u308F\u308A\u306B\u633F\u5165\u3059\u308B\u30C6\u30AD\u30B9\u30C8\u3067\u3059\u3002{{key}} \u3092\u4F7F\u7528\u3057\u3066\u30D5\u30ED\u30F3\u30C8\u30DE\u30BF\u30FC\u5909\u6570\u3092\u53C2\u7167\u3067\u304D\u307E\u3059\u3002"
      },
      generateCaptions: {
        name: "\u753B\u50CF\u3068\u8868\u306E\u30AD\u30E3\u30D7\u30B7\u30E7\u30F3\u3092\u751F\u6210\u3059\u308B",
        desc: "\u753B\u50CF\u3068\u8868\u306E\u30AD\u30E3\u30D7\u30B7\u30E7\u30F3\u3092\u751F\u6210\u3057\u307E\u3059\u3002\u6709\u52B9\u306B\u3059\u308B\u3068\u66F8\u304D\u51FA\u3057\u6642\u306B\u78BA\u8A8D\u30C0\u30A4\u30A2\u30ED\u30B0\u304C\u8868\u793A\u3055\u308C\u307E\u3059\u3002"
      },
      figurePosition: {
        name: "\u56F3\u306E\u4F4D\u7F6E\u6307\u5B9A\u5B50",
        desc: "\uFF08\u4F8B\uFF1Ah, t, b, p, H\uFF09"
      },
      tablePosition: {
        name: "\u8868\u306E\u4F4D\u7F6E\u6307\u5B9A\u5B50",
        desc: "\uFF08\u4F8B\uFF1Ah, t, b, p, H\uFF09"
      },
      askForFrontmatter: {
        name: "\u4E0D\u8DB3\u3057\u3066\u3044\u308B\u30D5\u30ED\u30F3\u30C8\u30DE\u30BF\u30FC\u3092\u78BA\u8A8D\u3059\u308B",
        desc: "\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u524D\u306B\u4E0D\u8DB3\u3057\u3066\u3044\u308B\u30D5\u30ED\u30F3\u30C8\u30DE\u30BF\u30FC\u9805\u76EE\u3092\u8FFD\u52A0\u3059\u308B\u304B\u30C0\u30A4\u30A2\u30ED\u30B0\u3067\u78BA\u8A8D\u3057\u307E\u3059\u3002"
      },
      askForCaptions: {
        name: "\u8868/\u56F3\u306E\u30AD\u30E3\u30D7\u30B7\u30E7\u30F3\u3092\u78BA\u8A8D\u3059\u308B",
        desc: "\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u524D\u306B\u8868\u3068\u56F3\u306E\u30AD\u30E3\u30D7\u30B7\u30E7\u30F3\u3092\u30C0\u30A4\u30A2\u30ED\u30B0\u3067\u5165\u529B\u3055\u305B\u307E\u3059\u3002"
      },
      askForExportPath: {
        name: "\u30D5\u30A1\u30A4\u30EB\u66F8\u304D\u51FA\u3057\u30D1\u30B9\u3092\u9078\u629E\u3059\u308B\uFF08\u30C7\u30B9\u30AF\u30C8\u30C3\u30D7\u306E\u307F\uFF09",
        desc: "\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u6642\u6BCE\u56DE\u66F8\u304D\u51FA\u3057\u5148\u3092\u9078\u629E\u3057\u307E\u3059\uFF08\u30C7\u30B9\u30AF\u30C8\u30C3\u30D7 \u306E\u307F\uFF09\u3002\u7121\u52B9\u306B\u3059\u308B\u3068 Markdown \u3068\u540C\u3058\u30C7\u30A3\u30EC\u30AF\u30C8\u30EA\u306B {\u30D5\u30A1\u30A4\u30EB\u540D}_{\u65E5\u4ED8}.tex \u3067\u4FDD\u5B58\u3057\u307E\u3059\u3002"
      },
      resetButton: "\u30C7\u30D5\u30A9\u30EB\u30C8\u306B\u30EA\u30BB\u30C3\u30C8",
      resetConfirm: "\u8A2D\u5B9A\u3092\u30EA\u30BB\u30C3\u30C8\u3057\u307E\u3059\u304B\uFF1F"
    },
    modals: {
      frontmatter: {
        title: "\u30D5\u30ED\u30F3\u30C8\u30DE\u30BF\u30FC\u3092\u7DE8\u96C6",
        description: "\u30D5\u30ED\u30F3\u30C8\u30DE\u30BF\u30FC\u9805\u76EE\u3092\u66F4\u65B0\u307E\u305F\u306F\u8FFD\u52A0:",
        saveToMarkdown: "Markdown\u30D5\u30A1\u30A4\u30EB\u306B\u4FDD\u5B58",
        saveToMarkdownDesc: "Markdown\u30D5\u30A1\u30A4\u30EB\u306E\u30D5\u30ED\u30F3\u30C8\u30DE\u30BF\u30FC\u3092\u66F4\u65B0\u3059\u308B",
        ok: "OK",
        cancel: "\u30AD\u30E3\u30F3\u30BB\u30EB"
      },
      caption: {
        title: "\u30AD\u30E3\u30D7\u30B7\u30E7\u30F3\u3092\u8FFD\u52A0",
        noItems: "\u8868\u3084\u56F3\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3067\u3057\u305F\u3002",
        items: "\u30A2\u30A4\u30C6\u30E0",
        preview: "\u30D7\u30EC\u30D3\u30E5\u30FC:",
        imageInfo: "\u753B\u50CF\u60C5\u5831:",
        path: "\u30D1\u30B9:",
        altText: "Alt \u30C6\u30AD\u30B9\u30C8:",
        noImagePath: "\u753B\u50CF\u30D1\u30B9\u306A\u3057",
        noAltText: "Alt \u30C6\u30AD\u30B9\u30C8\u306A\u3057",
        captionLabel: "\u30AD\u30E3\u30D7\u30B7\u30E7\u30F3",
        captionPlaceholder: '\u4F8B: "\u7D50\u679C\u306E\u6BD4\u8F03"',
        ok: "OK",
        cancel: "\u30AD\u30E3\u30F3\u30BB\u30EB"
      },
      overwrite: {
        title: "\u30D5\u30A1\u30A4\u30EB\u304C\u65E2\u306B\u5B58\u5728\u3057\u307E\u3059",
        message: '"{0}" \u3068\u3044\u3046\u540D\u524D\u306E\u30D5\u30A1\u30A4\u30EB\u304C\u65E2\u306B\u5B58\u5728\u3057\u307E\u3059\u3002\u4E0A\u66F8\u304D\u3057\u307E\u3059\u304B\uFF1F',
        overwrite: "\u4E0A\u66F8\u304D",
        cancel: "\u30AD\u30E3\u30F3\u30BB\u30EB"
      }
    },
    notices: {
      exported: "TeX\u30D5\u30A1\u30A4\u30EB\u3092 {0} \u306B\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u3057\u307E\u3057\u305F",
      exportedToClipboard: "TeX\u3092\u30AF\u30EA\u30C3\u30D7\u30DC\u30FC\u30C9\u306B\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u3057\u307E\u3057\u305F",
      overwritten: "TeX\u30D5\u30A1\u30A4\u30EB\u3092\u4E0A\u66F8\u304D\u3057\u307E\u3057\u305F: {0}",
      frontmatterUpdated: "Markdown\u30D5\u30A1\u30A4\u30EB\u306E\u30D5\u30ED\u30F3\u30C8\u30DE\u30BF\u30FC\u3092\u66F4\u65B0\u3057\u307E\u3057\u305F",
      frontmatterAdded: "Markdown\u30D5\u30A1\u30A4\u30EB\u306B\u30D5\u30ED\u30F3\u30C8\u30DE\u30BF\u30FC\u3092\u8FFD\u52A0\u3057\u307E\u3057\u305F",
      frontmatterUpdateFailed: "Markdown\u30D5\u30A1\u30A4\u30EB\u306E\u30D5\u30ED\u30F3\u30C8\u30DE\u30BF\u30FC\u66F4\u65B0\u306B\u5931\u6557\u3057\u307E\u3057\u305F"
    }
  }
};
function getCurrentLanguage() {
  var _a, _b, _c, _d;
  const lang = ((_c = (_b = (_a = window.app) == null ? void 0 : _a.vault) == null ? void 0 : _b.adapter) == null ? void 0 : _c.basePath) || "";
  const browserLang = navigator.language || ((_d = navigator.languages) == null ? void 0 : _d[0]) || "en";
  if (browserLang.startsWith("ja")) {
    return "ja";
  }
  return "en";
}
function t(key, language = getCurrentLanguage()) {
  const keys2 = key.split(".");
  let value2 = translations[language];
  for (const k of keys2) {
    value2 = value2 == null ? void 0 : value2[k];
    if (value2 === void 0) {
      value2 = translations["en"];
      for (const k2 of keys2) {
        value2 = value2 == null ? void 0 : value2[k2];
      }
      return value2 != null ? value2 : key;
    }
  }
  return value2 != null ? value2 : key;
}

// src/plugin/settingsTabs.ts
var ExportToTeXSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    const lang = getCurrentLanguage();
    const t2 = (key) => {
      const keys2 = key.split(".");
      let value2 = translations[lang].settings;
      for (const k of keys2) {
        value2 = value2 == null ? void 0 : value2[k];
      }
      return value2 != null ? value2 : key;
    };
    containerEl.empty();
    containerEl.createEl("h2", { text: t2("title") });
    new import_obsidian3.Setting(containerEl).setName(t2("generateLabels.name")).setDesc(t2("generateLabels.desc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.generateLabels).onChange((value2) => __async(this, null, function* () {
        this.plugin.settings.generateLabels = value2;
        yield this.plugin.saveData(this.plugin.settings);
      }));
    });
    new import_obsidian3.Setting(containerEl).setName(t2("refCommand.name")).setDesc(t2("refCommand.desc")).addText((text4) => text4.setValue(this.plugin.settings.refCommand).onChange((value2) => __async(this, null, function* () {
      this.plugin.settings.refCommand = value2;
      yield this.plugin.saveData(this.plugin.settings);
    })));
    new import_obsidian3.Setting(containerEl).setName(t2("numberedSections.name")).setDesc(t2("numberedSections.desc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.numberedSections).onChange((value2) => __async(this, null, function* () {
        this.plugin.settings.numberedSections = value2;
        yield this.plugin.saveData(this.plugin.settings);
      }));
    });
    new import_obsidian3.Setting(containerEl).setName(t2("compressNewlines.name")).setDesc(t2("compressNewlines.desc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.compressNewlines).onChange((value2) => __async(this, null, function* () {
        this.plugin.settings.compressNewlines = value2;
        yield this.plugin.saveData(this.plugin.settings);
      }));
    });
    new import_obsidian3.Setting(containerEl).setName(t2("preamble.name")).setDesc(t2("preamble.desc")).addTextArea((text4) => {
      text4.setValue(this.plugin.settings.preamble).onChange((value2) => __async(this, null, function* () {
        this.plugin.settings.preamble = value2;
        yield this.plugin.saveData(this.plugin.settings);
      }));
      text4.inputEl.style.height = "400px";
      text4.inputEl.style.fontFamily = "monospace";
      text4.inputEl.style.fontSize = "12px";
    });
    new import_obsidian3.Setting(containerEl).setName(t2("postamble.name")).setDesc(t2("postamble.desc")).addTextArea((text4) => {
      text4.setValue(this.plugin.settings.postamble).onChange((value2) => __async(this, null, function* () {
        this.plugin.settings.postamble = value2;
        yield this.plugin.saveData(this.plugin.settings);
      }));
      text4.inputEl.style.height = "200px";
      text4.inputEl.style.fontFamily = "monospace";
      text4.inputEl.style.fontSize = "12px";
    });
    new import_obsidian3.Setting(containerEl).setName(t2("generateCaptions.name")).setDesc(t2("generateCaptions.desc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.generateCaptions).onChange((value2) => __async(this, null, function* () {
        this.plugin.settings.generateCaptions = value2;
        yield this.plugin.saveData(this.plugin.settings);
      }));
    });
    new import_obsidian3.Setting(containerEl).setName(t2("figurePosition.name")).setDesc(t2("figurePosition.desc")).addText((text4) => {
      text4.setValue(this.plugin.settings.figurePosition);
      text4.onChange((value2) => __async(this, null, function* () {
        this.plugin.settings.figurePosition = value2;
        yield this.plugin.saveData(this.plugin.settings);
      }));
    });
    new import_obsidian3.Setting(containerEl).setName(t2("tablePosition.name")).setDesc(t2("tablePosition.desc")).addText((text4) => {
      text4.setValue(this.plugin.settings.tablePosition);
      text4.onChange((value2) => __async(this, null, function* () {
        this.plugin.settings.tablePosition = value2;
        yield this.plugin.saveData(this.plugin.settings);
      }));
    });
    new import_obsidian3.Setting(containerEl).setName(t2("askForFrontmatter.name")).setDesc(t2("askForFrontmatter.desc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.askForFrontmatter).onChange((value2) => __async(this, null, function* () {
        this.plugin.settings.askForFrontmatter = value2;
        yield this.plugin.saveData(this.plugin.settings);
      }));
    });
    new import_obsidian3.Setting(containerEl).setName(t2("askForCaptions.name")).setDesc(t2("askForCaptions.desc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.askForCaptions).onChange((value2) => __async(this, null, function* () {
        this.plugin.settings.askForCaptions = value2;
        yield this.plugin.saveData(this.plugin.settings);
      }));
    });
    new import_obsidian3.Setting(containerEl).setName(t2("askForExportPath.name")).setDesc(t2("askForExportPath.desc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.askForExportPath).onChange((value2) => __async(this, null, function* () {
        this.plugin.settings.askForExportPath = value2;
        yield this.plugin.saveData(this.plugin.settings);
      }));
    });
    new import_obsidian3.ButtonComponent(containerEl).setButtonText(t2("resetButton")).onClick(() => __async(this, null, function* () {
      if (!window.confirm(t2("resetConfirm")))
        return;
      this.plugin.settings = new ExportToTexSettings();
      yield this.plugin.saveData(this.plugin.settings);
      this.display();
    }));
  }
};

// src/debug/ast.ts
function exportAstToConsole(file) {
  return __async(this, null, function* () {
    const vfile2 = yield toVFile(file);
    const ast = yield markdownToTex().parse(vfile2);
    console.log(ast);
  });
}
function exportModifiedAstToConsole(file, settings, metadata) {
  return __async(this, null, function* () {
    const processor = yield markdownToTex().data("settings", {
      exportToTex: settings
    }).data("metadata", metadata).freeze();
    const vfile2 = yield toVFile(file);
    const ast = yield processor.parse(vfile2);
    console.log(yield processor.run(ast, vfile2));
  });
}

// src/modals/frontmatterModal.ts
var import_obsidian4 = require("obsidian");
var FrontmatterCheckModal = class extends import_obsidian4.Modal {
  constructor(app, currentFrontmatter, resolve, templateKeys) {
    super(app);
    this.allFields = [];
    this.inputValues = {};
    this.saveToMarkdown = false;
    this.templateKeys = [];
    this.resolve = resolve;
    this.templateKeys = templateKeys || [];
    const fieldsToShow = this.buildFieldsToShow(currentFrontmatter);
    this.allFields = fieldsToShow;
    for (const field of this.allFields) {
      this.inputValues[field.key] = field.value;
    }
  }
  buildFieldsToShow(currentFrontmatter) {
    const fields = [];
    const addedKeys = /* @__PURE__ */ new Set();
    if (this.templateKeys.length > 0) {
      for (const key of this.templateKeys) {
        if (addedKeys.has(key)) {
          continue;
        }
        const value2 = currentFrontmatter[key] !== void 0 ? String(currentFrontmatter[key]) : "";
        fields.push({
          key,
          label: this.formatLabel(key),
          placeholder: `Enter ${key}`,
          value: value2
        });
        addedKeys.add(key);
      }
    }
    for (const key in currentFrontmatter) {
      if (!addedKeys.has(key)) {
        const value2 = currentFrontmatter[key] !== void 0 ? String(currentFrontmatter[key]) : "";
        fields.push({
          key,
          label: this.formatLabel(key),
          placeholder: `Enter ${key}`,
          value: value2
        });
        addedKeys.add(key);
      }
    }
    return fields;
  }
  formatLabel(key) {
    return key.replace(/_/g, " ").split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
  }
  onOpen() {
    const { contentEl } = this;
    const lang = getCurrentLanguage();
    contentEl.createEl("h2", { text: t("modals.frontmatter.title", lang) });
    contentEl.createEl("p", {
      text: t("modals.frontmatter.description", lang)
    });
    for (const field of this.allFields) {
      let inputEl;
      new import_obsidian4.Setting(contentEl).setName(field.label).addText((text4) => {
        inputEl = text4.setPlaceholder(field.placeholder).setValue(field.value).onChange((value2) => {
          this.inputValues[field.key] = value2;
        });
      });
    }
    new import_obsidian4.Setting(contentEl).setName(t("modals.frontmatter.saveToMarkdown", lang)).setDesc(t("modals.frontmatter.saveToMarkdownDesc", lang)).addToggle((toggle) => {
      toggle.setValue(this.saveToMarkdown).onChange((value2) => {
        this.saveToMarkdown = value2;
      });
    });
    contentEl.createEl("div", { attr: { style: "margin-top: 20px;" } });
    const buttonContainer = contentEl.createEl("div", {
      attr: { style: "display: flex; gap: 10px; justify-content: flex-end;" }
    });
    const submitBtn = buttonContainer.createEl("button", {
      text: t("modals.frontmatter.ok", lang),
      attr: { style: "padding: 8px 16px; cursor: pointer;" }
    });
    submitBtn.addEventListener("click", () => {
      this.close();
      this.resolve({
        data: this.inputValues,
        saveToMarkdown: this.saveToMarkdown
      });
    });
    const cancelBtn = buttonContainer.createEl("button", {
      text: t("modals.frontmatter.cancel", lang),
      attr: { style: "padding: 8px 16px; cursor: pointer;" }
    });
    cancelBtn.addEventListener("click", () => {
      this.close();
      this.resolve(null);
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/modals/captionModal.ts
var import_obsidian5 = require("obsidian");
var CaptionInputModal = class extends import_obsidian5.Modal {
  constructor(app, items, resolve) {
    super(app);
    this.captions = {};
    this.currentItemIndex = 0;
    this.tableCounter = 0;
    this.figureCounter = 0;
    this.items = items;
    this.resolve = resolve;
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      if (item.type === "figure" && item.alt) {
        this.captions[i] = item.alt;
      } else {
        this.captions[i] = "";
      }
    }
    for (const item of items) {
      if (item.type === "table") {
        this.tableCounter++;
      } else {
        this.figureCounter++;
      }
    }
  }
  onOpen() {
    const { contentEl } = this;
    const lang = getCurrentLanguage();
    contentEl.style.maxWidth = "900px";
    contentEl.style.maxHeight = "90vh";
    contentEl.style.overflow = "auto";
    contentEl.createEl("h2", { text: t("modals.caption.title", lang) });
    if (this.items.length === 0) {
      contentEl.createEl("p", { text: t("modals.caption.noItems", lang) });
      return;
    }
    const mainContainer = contentEl.createEl("div", {
      attr: { style: "display: flex; gap: 16px; height: 65vh;" }
    });
    const listPanel = mainContainer.createEl("div", {
      attr: {
        style: "flex: 0 0 160px; border-right: 1px solid var(--divider-color); overflow-y: auto; padding-right: 12px;"
      }
    });
    listPanel.createEl("p", {
      text: t("modals.caption.items", lang),
      attr: { style: "margin: 0 0 8px 0; font-weight: bold; font-size: 12px;" }
    });
    const listContainer = listPanel.createEl("div", {
      attr: { style: "display: flex; flex-direction: column; gap: 4px;" }
    });
    let tableIndex = 1;
    let figureIndex = 1;
    for (let i = 0; i < this.items.length; i++) {
      const item = this.items[i];
      const label4 = item.type === "table" ? `Table ${tableIndex++}` : `Figure ${figureIndex++}`;
      const btn = listContainer.createEl("button", {
        text: label4,
        attr: {
          style: `padding: 8px 12px; text-align: left; border-radius: 4px; border: 1px solid transparent; cursor: pointer; font-size: 13px; transition: all 0.2s; ${i === 0 ? "background-color: var(--interactive-accent); color: white;" : "background-color: var(--background-secondary); color: var(--text-normal);"}`
        }
      });
      btn.addEventListener("click", () => {
        this.currentItemIndex = i;
        this.updateEditorPanel(editorPanel);
        listContainer.querySelectorAll("button").forEach((b, idx) => {
          if (idx === i) {
            b.style.backgroundColor = "var(--interactive-accent)";
            b.style.color = "white";
          } else {
            b.style.backgroundColor = "var(--background-secondary)";
            b.style.color = "var(--text-normal)";
          }
        });
      });
    }
    const editorPanel = mainContainer.createEl("div", {
      attr: {
        style: "flex: 1; display: flex; flex-direction: column; gap: 12px; overflow-y: auto;"
      }
    });
    this.updateEditorPanel(editorPanel);
    const buttonContainer = contentEl.createEl("div", {
      attr: {
        style: "display: flex; gap: 10px; justify-content: flex-end; margin-top: 16px; border-top: 1px solid var(--divider-color); padding-top: 12px;"
      }
    });
    const okBtn = buttonContainer.createEl("button", {
      text: t("modals.caption.ok", lang),
      attr: {
        style: "padding: 8px 16px; background-color: var(--interactive-accent); color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500;"
      }
    });
    okBtn.addEventListener("click", () => {
      this.close();
      this.resolve(this.captions);
    });
    const cancelBtn = buttonContainer.createEl("button", {
      text: t("modals.caption.cancel", lang),
      attr: {
        style: "padding: 8px 16px; background-color: var(--background-secondary); color: var(--text-normal); border: 1px solid var(--divider-color); border-radius: 4px; cursor: pointer;"
      }
    });
    cancelBtn.addEventListener("click", () => {
      this.close();
      this.resolve(null);
    });
  }
  updateEditorPanel(editorPanel) {
    editorPanel.empty();
    const lang = getCurrentLanguage();
    const item = this.items[this.currentItemIndex];
    let label4;
    if (item.type === "table") {
      const tableNum = this.items.slice(0, this.currentItemIndex).filter((i) => i.type === "table").length + 1;
      label4 = `Table ${tableNum}`;
    } else {
      const figNum = this.items.slice(0, this.currentItemIndex).filter((i) => i.type === "figure").length + 1;
      label4 = `Figure ${figNum}`;
    }
    editorPanel.createEl("h3", {
      text: label4,
      attr: { style: "margin: 0 0 12px 0;" }
    });
    const previewSection = editorPanel.createEl("div");
    previewSection.createEl("p", {
      text: t("modals.caption.preview", lang),
      attr: {
        style: "margin: 0 0 8px 0; font-size: 12px; font-weight: bold; color: var(--text-muted);"
      }
    });
    const previewContainer = previewSection.createEl("div", {
      attr: {
        style: "background-color: var(--background-secondary); padding: 12px; border-radius: 4px; max-height: 250px; overflow-y: auto; border: 1px solid var(--divider-color); font-size: 12px;"
      }
    });
    if (item.source) {
      if (item.type === "table") {
        this.renderMarkdownTable(item.source, previewContainer).catch(console.error);
      } else {
        const imagePath = this.extractImagePath(item.source);
        if (imagePath && item.filePath) {
          this.renderImagePreview(imagePath, item.filePath, previewContainer);
        }
        const infoDiv = previewContainer.createEl("div", {
          attr: {
            style: "padding: 8px 0; margin-top: 12px; border-top: 1px solid var(--divider-color); padding-top: 8px;"
          }
        });
        infoDiv.innerHTML = `
          <div style="font-weight: bold; margin-bottom: 8px;">${t("modals.caption.imageInfo", lang)}</div>
          <div style="word-break: break-word; font-family: monospace; font-size: 11px;">
            ${imagePath ? `<div><strong>${t("modals.caption.path", lang)}</strong> ${this.escapeHtml(imagePath)}</div>` : `<div><em>${t("modals.caption.noImagePath", lang)}</em></div>`}
            ${item.alt ? `<div style="margin-top: 4px;"><strong>${t("modals.caption.altText", lang)}</strong> ${this.escapeHtml(item.alt)}</div>` : ""}
          </div>
        `;
      }
    } else {
      if (item.type === "table") {
        previewContainer.createEl("p", {
          text: `${item.rows} rows \xD7 ${item.cols} columns`
        });
      } else {
        const infoDiv = previewContainer.createEl("div", {
          attr: {
            style: "padding: 8px; font-size: 12px;"
          }
        });
        infoDiv.innerHTML = `
          <div style="color: var(--text-muted); margin-bottom: 8px;">
            <em>${t("modals.caption.noImagePath", lang)}</em>
          </div>
          ${item.alt ? `<div><strong>${t("modals.caption.altText", lang)}</strong> ${this.escapeHtml(item.alt)}</div>` : `<div><em>${t("modals.caption.noAltText", lang)}</em></div>`}
        `;
      }
    }
    const metaContainer = editorPanel.createEl("div", {
      attr: { style: "font-size: 12px; color: var(--text-muted);" }
    });
    if (item.type === "table") {
      metaContainer.createEl("p", {
        text: `${item.rows} rows \xD7 ${item.cols} columns`,
        attr: { style: "margin: 4px 0;" }
      });
    } else if (item.alt) {
      metaContainer.createEl("p", {
        text: `Alt: ${item.alt}`,
        attr: { style: "margin: 4px 0;" }
      });
    }
    new import_obsidian5.Setting(editorPanel).setName(t("modals.caption.captionLabel", lang)).addText((text4) => {
      text4.setPlaceholder(t("modals.caption.captionPlaceholder", lang)).setValue(this.captions[this.currentItemIndex] || "").onChange((value2) => {
        this.captions[this.currentItemIndex] = value2;
      });
    });
  }
  renderMarkdownTable(markdownSource, container) {
    return __async(this, null, function* () {
      const lines = markdownSource.trim().split("\n");
      if (lines.length < 2) {
        container.createEl("code", { text: markdownSource });
        return;
      }
      const headerLine = lines[0];
      const separatorLine = lines[1];
      const bodyLines = lines.slice(2);
      const colCount = (separatorLine.match(/\|/g) || []).length - 1;
      const table = container.createEl("table", {
        attr: {
          style: "border-collapse: collapse; width: 100%; font-size: 11px; border: 1px solid var(--divider-color);"
        }
      });
      const headerCells = this.parseCells(headerLine);
      const thead = table.createEl("thead");
      const headerRow = thead.createEl("tr");
      for (const cell of headerCells) {
        const th = headerRow.createEl("th", {
          attr: {
            style: "border: 1px solid var(--divider-color); padding: 4px; background-color: var(--background-tertiary); font-weight: bold; text-align: left;"
          }
        });
        yield import_obsidian5.MarkdownRenderer.renderMarkdown(cell.trim(), th, "", this);
      }
      const tbody = table.createEl("tbody");
      for (const line of bodyLines) {
        if (!line.trim())
          continue;
        const cells = this.parseCells(line);
        const row = tbody.createEl("tr");
        for (const cell of cells) {
          const td = row.createEl("td", {
            attr: {
              style: "border: 1px solid var(--divider-color); padding: 4px; text-align: left;"
            }
          });
          yield import_obsidian5.MarkdownRenderer.renderMarkdown(cell.trim(), td, "", this);
        }
      }
    });
  }
  parseCells(line) {
    return line.split("|").slice(1, -1).map((cell) => cell.trim());
  }
  extractImagePath(markdownSource) {
    const match = markdownSource.match(/!\[.*?\]\((.*?)\)/);
    return match ? match[1] : null;
  }
  renderImagePreview(imagePath, filePath, container) {
    return __async(this, null, function* () {
      try {
        const absolutePath = this.resolveImagePath(imagePath, filePath);
        const imageFile = this.app.vault.getAbstractFileByPath(absolutePath);
        if (!imageFile || imageFile instanceof import_obsidian5.TFolder) {
          return;
        }
        const data = yield this.app.vault.readBinary(imageFile);
        const blob = new Blob([data]);
        const dataUrl = yield new Promise((resolve) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.readAsDataURL(blob);
        });
        const imgContainer = container.createEl("div", {
          attr: {
            style: "margin-bottom: 12px; text-align: center;"
          }
        });
        const img = imgContainer.createEl("img", {
          attr: {
            src: dataUrl,
            style: "max-width: 100%; max-height: 200px; border-radius: 4px; border: 1px solid var(--divider-color);"
          }
        });
      } catch (error) {
        console.error("Failed to load image preview:", error);
      }
    });
  }
  resolveImagePath(imagePath, filePath) {
    const decodedPath = decodeURI(imagePath);
    if (decodedPath.startsWith("/")) {
      return decodedPath;
    }
    const fileDir = filePath.substring(0, filePath.lastIndexOf("/"));
    if (fileDir) {
      return fileDir + "/" + decodedPath;
    }
    return decodedPath;
  }
  escapeHtml(text4) {
    const div = document.createElement("div");
    div.textContent = text4;
    return div.innerHTML;
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/modals/overwriteConfirmModal.ts
var import_obsidian6 = require("obsidian");
var OverwriteConfirmModal = class extends import_obsidian6.Modal {
  constructor(app, fileName, resolve) {
    super(app);
    this.fileName = fileName;
    this.resolve = resolve;
  }
  onOpen() {
    const { contentEl } = this;
    const lang = getCurrentLanguage();
    contentEl.createEl("h2", { text: t("modals.overwrite.title", lang) });
    contentEl.createEl("p", {
      text: t("modals.overwrite.message", lang).replace("{0}", this.fileName)
    });
    const buttonContainer = contentEl.createEl("div", {
      attr: {
        style: "display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;"
      }
    });
    const overwriteBtn = buttonContainer.createEl("button", {
      text: t("modals.overwrite.overwrite", lang),
      attr: {
        style: "padding: 8px 16px; background-color: var(--interactive-accent); color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500;"
      }
    });
    overwriteBtn.addEventListener("click", () => {
      this.close();
      this.resolve(true);
    });
    const cancelBtn = buttonContainer.createEl("button", {
      text: t("modals.overwrite.cancel", lang),
      attr: {
        style: "padding: 8px 16px; background-color: var(--background-secondary); color: var(--text-normal); border: 1px solid var(--divider-color); border-radius: 4px; cursor: pointer;"
      }
    });
    cancelBtn.addEventListener("click", () => {
      this.close();
      this.resolve(false);
    });
    cancelBtn.focus();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/main.ts
var ExportToTeXPlugin = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    this.settings = new ExportToTexSettings();
  }
  onload() {
    return __async(this, null, function* () {
      const settings = yield this.loadData();
      if (settings !== null) {
        this.settings = ensureSettings(settings);
      }
      this.addCommands();
      this.addRibbonButtons();
      if (false) {
        this.addDebugCommands();
      }
      this.addSettingTab(new ExportToTeXSettingTab(this.app, this));
    });
  }
  addCommands() {
    this.addExportCommand("export-to-tex", "Export To TeX", () => this.app.workspace.getActiveFile(), (x) => this.exportFileToFile(x));
    this.addExportCommand("export-tex-to-clipboard", "Export To Clipboard", () => this.app.workspace.getActiveFile(), (x) => this.exportFileToClipboard(x));
    this.addExportCommand("export-selection-to-tex", "Export Selection To TeX", () => this.app.workspace.getActiveViewOfType(import_obsidian7.MarkdownView), (x) => this.exportSelectionToFile(x));
    this.addExportCommand("export-selection-tex-to-clipboard", "Export Selection To Clipboard", () => this.app.workspace.getActiveViewOfType(import_obsidian7.MarkdownView), (x) => this.exportSelectionToClipboard(x));
  }
  addDebugCommands() {
    this.addExportCommand("export-ast-to-console", "Show AST", () => this.app.workspace.getActiveFile(), exportAstToConsole);
    this.addExportCommand("export-modified-ast-to-console", "Show modified AST", () => this.app.workspace.getActiveFile(), (file) => exportModifiedAstToConsole(file, this.settings, this.app.metadataCache));
  }
  addExportCommand(id, name, getFileOrView, doExport) {
    this.addCommand({
      id,
      name,
      checkCallback: (checking) => {
        const fileOrView = getFileOrView();
        if (fileOrView !== null) {
          if (!checking) {
            doExport(fileOrView).catch(this.onExportError);
          }
          return true;
        }
        return false;
      }
    });
  }
  addRibbonButtons() {
    this.addRibbonIcon("save", "Export current file to TeX", () => __async(this, null, function* () {
      const file = this.app.workspace.getActiveFile();
      if (file) {
        yield this.exportFileToFile(file).catch(this.onExportError.bind(this));
      }
    }));
    this.addRibbonIcon("copy", "Export current file to clipboard", () => __async(this, null, function* () {
      const file = this.app.workspace.getActiveFile();
      if (file) {
        yield this.exportFileToClipboard(file).catch(this.onExportError.bind(this));
      }
    }));
  }
  confirmFrontmatter(printer, file, currentFrontmatter) {
    return __async(this, null, function* () {
      if (!this.settings.askForFrontmatter) {
        return currentFrontmatter;
      }
      const templateKeys = printer.extractTemplateKeys(this.settings.preamble + "\n" + this.settings.postamble);
      const result = yield new Promise((resolve) => {
        const modal = new FrontmatterCheckModal(this.app, currentFrontmatter, (data) => {
          resolve(data);
        }, templateKeys);
        modal.open();
      });
      if (!result) {
        return null;
      }
      const finalFrontmatter = __spreadValues(__spreadValues({}, currentFrontmatter), result.data);
      if (result.saveToMarkdown) {
        yield this.updateFrontmatterInMarkdown(file, finalFrontmatter);
      }
      return finalFrontmatter;
    });
  }
  confirmCaptions(printer, vfile2) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      if (!this.settings.askForCaptions || !this.settings.generateCaptions) {
        return {};
      }
      const { itemsInOrder } = printer.getTablesAndFigures(vfile2);
      const items = [];
      for (let i = 0; i < itemsInOrder.length; i++) {
        const item = itemsInOrder[i];
        items.push({
          index: i,
          type: item.type,
          rows: (_a = item.data) == null ? void 0 : _a.rows,
          cols: (_b = item.data) == null ? void 0 : _b.cols,
          alt: (_c = item.data) == null ? void 0 : _c.alt,
          source: (_d = item.data) == null ? void 0 : _d.source,
          filePath: vfile2.path,
          preview: item.type === "table" ? `Table with ${(_e = item.data) == null ? void 0 : _e.rows} rows and ${(_f = item.data) == null ? void 0 : _f.cols} columns` : ((_g = item.data) == null ? void 0 : _g.alt) || ((_h = item.data) == null ? void 0 : _h.title) || "(no alt text)"
        });
      }
      if (items.length === 0) {
        return {};
      }
      const captionData = yield new Promise((resolve) => {
        const modal = new CaptionInputModal(this.app, items, (captions) => {
          resolve(captions);
        });
        modal.open();
      });
      return captionData;
    });
  }
  exportFileToFile(file) {
    return __async(this, null, function* () {
      yield this.exportToFile(yield toVFile(file));
    });
  }
  exportSelectionToFile(view) {
    return __async(this, null, function* () {
      yield this.exportToFile(vfileFromSelection(view));
    });
  }
  exportToFile(vfile2) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      const file = this.app.vault.getAbstractFileByPath(vfile2.path);
      const printer = new TeXPrinter(this.app, this.settings);
      const currentFrontmatter = ((_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter) || {};
      const finalFrontmatter = yield this.confirmFrontmatter(printer, file, currentFrontmatter);
      if (finalFrontmatter === null) {
        return;
      }
      let contents = yield printer.toTexWithFrontmatter(vfile2, finalFrontmatter);
      const captionData = yield this.confirmCaptions(printer, vfile2);
      if (captionData === null) {
        return;
      }
      if (Object.keys(captionData).length > 0) {
        const { tables, figures } = printer.getTablesAndFigures(vfile2);
        console.log("Applying captions:", {
          captionCount: Object.keys(captionData).length,
          tableCount: tables.length,
          figureCount: figures.length,
          totalItems: tables.length + figures.length
        });
        contents = this.applyCaptions(contents, captionData, tables, figures);
      }
      if (typeof window.showSaveFilePicker !== "function") {
        const now = new Date();
        const dateStr = now.getFullYear() + "-" + String(now.getMonth() + 1).padStart(2, "0") + "-" + String(now.getDate()).padStart(2, "0") + "_" + String(now.getHours()).padStart(2, "0") + "-" + String(now.getMinutes()).padStart(2, "0") + "-" + String(now.getSeconds()).padStart(2, "0");
        const newName = `${file.basename}_${dateStr}.tex`;
        const newPath = `${((_b = file.parent) == null ? void 0 : _b.path) || ""}/${newName}`;
        const existingFile = this.app.vault.getAbstractFileByPath(newPath);
        if (existingFile) {
          const shouldOverwrite = yield new Promise((resolve) => {
            const modal = new OverwriteConfirmModal(this.app, newName, resolve);
            modal.open();
          });
          if (!shouldOverwrite) {
            return;
          }
          yield this.app.vault.modify(existingFile, contents);
          const lang = getCurrentLanguage();
          new import_obsidian7.Notice(t("notices.overwritten", lang).replace("{0}", newName));
        } else {
          yield this.app.vault.create(newPath, contents);
          const lang = getCurrentLanguage();
          new import_obsidian7.Notice(t("notices.exported", lang).replace("{0}", newName));
        }
      } else {
        if (this.settings.askForExportPath) {
          try {
            const fileHandle = yield window.showSaveFilePicker({
              types: [
                {
                  description: "LaTeX",
                  accept: {
                    "application/x-tex": [".tex"]
                  }
                }
              ]
            });
            const writeable = yield fileHandle.createWritable();
            yield writeable.write(contents);
            writeable.close();
            const lang = getCurrentLanguage();
            new import_obsidian7.Notice(t("notices.exported", lang).replace("{0}", fileHandle.name));
          } catch (AbortError) {
            return;
          }
        } else {
          const now = new Date();
          const dateStr = now.getFullYear() + "-" + String(now.getMonth() + 1).padStart(2, "0") + "-" + String(now.getDate()).padStart(2, "0");
          const newName = `${file.basename}_${dateStr}.tex`;
          const newPath = `${((_c = file.parent) == null ? void 0 : _c.path) || ""}/${newName}`;
          const existingFile = this.app.vault.getAbstractFileByPath(newPath);
          if (existingFile) {
            const shouldOverwrite = yield new Promise((resolve) => {
              const modal = new OverwriteConfirmModal(this.app, newName, resolve);
              modal.open();
            });
            if (!shouldOverwrite) {
              return;
            }
            yield this.app.vault.modify(existingFile, contents);
            const lang = getCurrentLanguage();
            new import_obsidian7.Notice(t("notices.overwritten", lang).replace("{0}", newName));
          } else {
            yield this.app.vault.create(newPath, contents);
            const lang = getCurrentLanguage();
            new import_obsidian7.Notice(t("notices.exported", lang).replace("{0}", newName));
          }
        }
      }
    });
  }
  applyCaptions(contents, captions, tables, figures) {
    let result = contents;
    const allItems = [];
    for (const table of tables) {
      allItems.push({ index: table.index, type: "table" });
    }
    for (const figure of figures) {
      allItems.push({ index: figure.index, type: "figure" });
    }
    allItems.sort((a, b) => a.index - b.index);
    let captionIndex = 0;
    let replacementCount = 0;
    result = result.replace(/\\(?:caption\{[^}]*\}|captionof\{(figure|table)\}\{[^}]*\})/g, (match, captionofType) => {
      if (captionIndex < Object.keys(captions).length) {
        const captionText = captions[captionIndex];
        captionIndex++;
        if (captionText) {
          replacementCount++;
          if (captionofType) {
            return `\\captionof{${captionofType}}{\\sffamily ${captionText}}`;
          } else {
            return `\\caption{\\sffamily ${captionText}}`;
          }
        }
      }
      return match;
    });
    console.log("Caption replacement completed:", {
      totalCaptions: Object.keys(captions).length,
      replacements: replacementCount,
      captionsProcessed: captionIndex
    });
    return result;
  }
  exportFileToClipboard(file) {
    return __async(this, null, function* () {
      yield this.exportToClipboard(yield toVFile(file));
    });
  }
  exportSelectionToClipboard(view) {
    return __async(this, null, function* () {
      yield this.exportToClipboard(vfileFromSelection(view));
    });
  }
  exportToClipboard(vfile2) {
    return __async(this, null, function* () {
      var _a;
      const file = this.app.vault.getAbstractFileByPath(vfile2.path);
      const printer = new TeXPrinter(this.app, this.settings);
      const currentFrontmatter = ((_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter) || {};
      const finalFrontmatter = yield this.confirmFrontmatter(printer, file, currentFrontmatter);
      if (finalFrontmatter === null) {
        return;
      }
      let contents = yield printer.toTexWithFrontmatter(vfile2, finalFrontmatter);
      const captionData = yield this.confirmCaptions(printer, vfile2);
      if (captionData === null) {
        return;
      }
      if (Object.keys(captionData).length > 0) {
        const { tables, figures } = printer.getTablesAndFigures(vfile2);
        console.log("Applying captions (clipboard):", {
          captionCount: Object.keys(captionData).length,
          tableCount: tables.length,
          figureCount: figures.length,
          totalItems: tables.length + figures.length
        });
        contents = this.applyCaptions(contents, captionData, tables, figures);
      }
      yield navigator.clipboard.writeText(contents);
      const lang = getCurrentLanguage();
      new import_obsidian7.Notice(t("notices.exportedToClipboard", lang));
    });
  }
  onExportError(e) {
    console.log(e);
    new import_obsidian7.Notice(`Error of type "${e.name}" occurred on export. See console for details.`);
  }
  updateFrontmatterInMarkdown(file, frontmatter2) {
    return __async(this, null, function* () {
      try {
        let fileContent = yield this.app.vault.read(file);
        const frontmatterRegex = /^---\n([\s\S]*?)\n---\n/;
        const match = fileContent.match(frontmatterRegex);
        if (match) {
          const newFrontmatterYaml = this.objectToYaml(frontmatter2);
          const newContent = fileContent.replace(frontmatterRegex, `---
${newFrontmatterYaml}
---
`);
          yield this.app.vault.modify(file, newContent);
          const lang = getCurrentLanguage();
          new import_obsidian7.Notice(t("notices.frontmatterUpdated", lang));
        } else {
          const newFrontmatterYaml = this.objectToYaml(frontmatter2);
          const newContent = `---
${newFrontmatterYaml}
---
${fileContent}`;
          yield this.app.vault.modify(file, newContent);
          const lang = getCurrentLanguage();
          new import_obsidian7.Notice(t("notices.frontmatterAdded", lang));
        }
      } catch (error) {
        console.error("Failed to update frontmatter:", error);
        const lang = getCurrentLanguage();
        new import_obsidian7.Notice(t("notices.frontmatterUpdateFailed", lang));
      }
    });
  }
  objectToYaml(obj) {
    const lines = [];
    for (const [key, value2] of Object.entries(obj)) {
      if (value2 === null || value2 === void 0 || value2 === "") {
        continue;
      }
      const stringValue = String(value2);
      if (stringValue.includes(":") || stringValue.includes("\n")) {
        lines.push(`${key}: '${stringValue.replace(/'/g, "''")}'`);
      } else {
        lines.push(`${key}: ${stringValue}`);
      }
    }
    return lines.join("\n");
  }
};
module.exports = __toCommonJS(main_exports);
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */
